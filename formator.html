<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C89 Studio: Advanced Code Formatter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #0f172a; }
        ::-webkit-scrollbar-thumb { background: #334155; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #475569; }
        .code-font { font-family: 'JetBrains Mono', 'Fira Code', 'Menlo', 'Monaco', 'Consolas', monospace; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%; background: #3b82f6; cursor: pointer; margin-top: -6px; box-shadow: 0 0 0 2px #1e293b; }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; cursor: pointer; background: #334155; border-radius: 2px; }
        .custom-checkbox { appearance: none; width: 1rem; height: 1rem; border: 1px solid #475569; border-radius: 0.25rem; background-color: #020617; transition: all 0.2s; position: relative; cursor: pointer; }
        .custom-checkbox:checked { background-color: #3b82f6; border-color: #3b82f6; }
        .custom-checkbox:checked::after { content: ''; position: absolute; left: 5px; top: 1px; width: 4px; height: 10px; border: solid white; border-width: 0 2px 2px 0; transform: rotate(45deg); }
        .tok-kw { color: #c678dd; font-weight: bold; } .tok-ty { color: #e5c07b; } .tok-str { color: #98c379; } .tok-num { color: #d19a66; } .tok-cm { color: #5c6370; font-style: italic; } .tok-pp { color: #e06c75; } .tok-op { color: #56b6c2; } .tok-id { color: #abb2bf; } .tok-punc { color: #abb2bf; }
    </style>
</head>
<body class="bg-slate-950 text-slate-200 flex flex-col h-screen overflow-hidden font-sans selection:bg-blue-500/30">
    <header class="bg-slate-900 border-b border-slate-800 h-14 shrink-0 flex items-center justify-between px-4 z-30">
        <div class="flex items-center gap-3"><div class="w-8 h-8 bg-gradient-to-br from-blue-600 to-blue-700 rounded-lg flex items-center justify-center text-white font-bold shadow-lg shadow-blue-900/20">C</div><div><h1 class="text-sm font-bold text-slate-100 tracking-tight leading-tight">C89 Studio</h1><div class="text-[10px] text-slate-500 font-medium uppercase tracking-wider">Formatter & Linter</div></div></div>
        <div class="flex items-center gap-3">
             <div class="relative group"><select id="snippetSelect" class="appearance-none bg-slate-800 border border-slate-700 hover:border-slate-600 text-xs text-slate-300 rounded pl-3 pr-8 py-1.5 outline-none focus:ring-1 focus:ring-blue-500 transition-all cursor-pointer w-48 truncate"><option value="" disabled selected>Load Example Code...</option><option value="structs">Grouping & Structs</option><option value="allFeatures">All Features Test</option><option value="linkedList">Linked List</option><option value="matrix">Matrix Mult</option><option value="funcStyle">Function Arguments</option></select><div class="absolute right-2 top-1/2 -translate-y-1/2 pointer-events-none text-slate-500"><svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/></svg></div></div><div class="h-6 w-px bg-slate-800 mx-1"></div><button id="resetBtn" class="px-3 py-1.5 bg-slate-800 hover:bg-slate-700 border border-slate-700 rounded text-xs text-slate-300">Reset</button><button id="copyBtn" class="px-4 py-1.5 bg-blue-600 hover:bg-blue-500 text-white rounded text-xs font-bold shadow-lg shadow-blue-900/20">Copy Output</button>
        </div>
    </header>
    <div class="flex flex-1 overflow-hidden">
        <aside class="w-80 bg-slate-900 border-r border-slate-800 flex flex-col shrink-0 z-20 shadow-xl overflow-hidden">
            <div class="p-3 border-b border-slate-800 bg-slate-900 shrink-0 sticky top-0"><input type="text" id="searchInput" placeholder="Search settings..." class="w-full bg-slate-950 border border-slate-800 text-slate-300 text-xs rounded px-3 py-1.5 focus:border-blue-500 focus:ring-1 focus:ring-blue-500 outline-none placeholder-slate-600 transition-all"></div>
            <div class="overflow-y-auto flex-1 custom-scrollbar p-2 space-y-1" id="settingsContainer"></div>
        </aside>
        <div class="flex-1 flex flex-col md:flex-row min-h-0 bg-[#0b1120]">
            <div class="flex-1 flex flex-col border-r border-slate-800 min-h-0 relative">
                <div class="absolute top-0 left-0 right-0 bg-slate-900/95 backdrop-blur-sm px-4 py-1.5 border-b border-slate-800 flex justify-between items-center z-10"><span class="text-[10px] font-bold text-slate-500 uppercase tracking-wider">Input</span><span id="inputCharCount" class="text-[10px] text-slate-600 font-mono">0 chars</span></div>
                <textarea id="inputArea" class="flex-1 bg-[#0b1120] pt-10 p-4 text-xs md:text-sm code-font text-slate-300 resize-none outline-none focus:bg-[#0f172a] selection:bg-blue-900/60 selection:text-white transition-colors" spellcheck="false" placeholder="// Paste your C code here..."></textarea>
            </div>
            <div class="flex-1 flex flex-col min-h-0 relative">
                 <div class="absolute top-0 left-0 right-0 bg-slate-900/95 backdrop-blur-sm px-4 py-1.5 border-b border-slate-800 flex justify-between items-center z-10"><span class="text-[10px] font-bold text-blue-500 uppercase tracking-wider">Formatted Output</span><div id="statusIndicator" class="flex items-center gap-1.5 opacity-0 transition-opacity duration-300"><div class="w-1.5 h-1.5 rounded-full bg-green-500"></div><span class="text-[10px] text-green-500 font-medium">Ready</span></div></div>
                <div class="flex-1 overflow-auto bg-[#0b1120] relative cursor-text"><pre id="outputArea" class="absolute inset-0 pt-10 p-4 text-xs md:text-sm code-font text-slate-300 whitespace-pre select-text outline-none" tabindex="0"></pre></div>
            </div>
        </div>
    </div>
    <script>
        const TokenType = { WS: 'WS', NL: 'NL', CB: 'CB', CL: 'CL', PP: 'PP', KW: 'KW', TY: 'TY', ID: 'ID', STR: 'STR', CHR: 'CHR', NUM: 'NUM', OP: 'OP', PUNC: 'PUNC', LBR: '{', RBR: '}', LPAR: '(', RPAR: ')', LBRA: '[', RBRA: ']', SEMI: ';', COLON: ':', UNK: '?' };
        const KEYWORDS = new Set(['auto', 'break', 'case', 'const', 'continue', 'default', 'do', 'else', 'enum', 'extern', 'for', 'goto', 'if', 'register', 'return', 'sizeof', 'static', 'struct', 'switch', 'typedef', 'union', 'volatile', 'while', 'void']);
        const TYPES = new Set(['char', 'double', 'float', 'int', 'long', 'short', 'signed', 'unsigned', 'size_t', 'FILE', 'bool', 'int8_t', 'uint8_t', 'int16_t', 'uint16_t', 'int32_t', 'uint32_t', 'int64_t', 'uint64_t']);
        const OPS = { assign: new Set(['=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '&=', '|=', '^=']), logical: new Set(['&&', '||']), equality: new Set(['==', '!=']), relational: new Set(['<', '>', '<=', '>=']), bitwise: new Set(['&', '|', '^']), additive: new Set(['+', '-']), multiplicative: new Set(['*', '/', '%']), shift: new Set(['<<', '>>']), unary: new Set(['!', '~', '++', '--', 'sizeof']) };
        let currentRawOutput = "";

        const DEFAULT_CONFIG = {
            indentWidth: 4, useTabs: false, indentCase: false, indentGoto: false, indentPP: false,
            breakAfterStructClosingBrace: false, groupTopLevelItems: true, topLevelEmptyLines: 1,
            groupIncludes: true, groupDefines: true, groupTypedefs: true, groupStructs: false, groupFuncProtos: true, groupVarDecls: true, groupPreproc: true,
            emptyLineBeforeIncludes: false, emptyLineAfterIncludes: true, emptyLineBeforeDefines: false, emptyLineAfterDefines: false,
            emptyLineBeforeTypedefs: false, emptyLineAfterTypedefs: false, emptyLineBeforeFuncProtos: false, emptyLineAfterFuncProtos: false,
            emptyLineBeforeVarDecls: false, emptyLineAfterVarDecls: false, emptyLineBeforeStructs: false, emptyLineAfterStructs: false,
            breakAfterFuncReturnType: false, breakAfterFuncOpenParen: false, breakFuncArgsOnLimit: true, breakBeforeFuncCloseParen: false, funcParamStyle: 'Pack', columnLimit: 80, emptyLinesBetweenFunctions: 2,
            breakBeforeFuncBrace: false, breakBeforeIfBrace: false, breakBeforeForBrace: false, breakBeforeWhileBrace: false, breakBeforeSwitchBrace: false, breakBeforeElse: false, breakBeforeWhile: false, oneLinerIf: false, oneLinerFunc: false,

            // New / Updated Features
            preserveEmptyLines: true, maxEmptyLines: 1,
            structMemberOnePerLine: true,

            emptyLineBeforeIf: false, emptyLineBeforeFor: false, emptyLineBeforeWhile: false, emptyLineBeforeDo: false, emptyLineBeforeSwitch: false, emptyLineBeforeCase: false, emptyLineBeforeBreak: false, emptyLineBeforeReturn: false,
            emptyLineStartOfBlock: false, emptyLineEndOfBlock: false, braceStyle: 'K&R',
            spaceAfterKeywords: true, spaceAfterCast: false, spaceBeforeFuncDefParen: false, spaceBeforeFuncCallParen: false, spaceInParens: false, spaceInBrackets: false, spaceInBraces: true, spaceInEmptyBraces: false, spaceAssign: true, spaceLogical: true, spaceEquality: true, spaceRelational: true, spaceBitwise: true, spaceAdditive: true, spaceMultiplicative: true, spaceShift: true, spaceUnary: false, spaceTernary: true, spaceComma: true, spaceSemi: true, pointerAlignment: 'Right'
        };

        let config = { ...DEFAULT_CONFIG };
        const settingsGroups = [
            { title: "Indentation", items: [ { id: 'indentWidth', type: 'range', min: 2, max: 8, label: 'Indent Width' }, { id: 'useTabs', type: 'bool', label: 'Use Tabs' }, { id: 'indentCase', type: 'bool', label: 'Indent Case Labels' }, { id: 'indentGoto', type: 'bool', label: 'Indent Goto Labels' }, { id: 'indentPP', type: 'bool', label: 'Indent Preprocessor' } ] },
            { title: "Structs & Data", items: [ { id: 'structMemberOnePerLine', type: 'bool', label: 'One Member Per Line' }, { id: 'breakAfterStructClosingBrace', type: 'bool', label: 'Break After Struct Brace' } ] },
            { title: "Item Grouping (Logic)", items: [ { id: 'groupIncludes', type: 'bool', label: 'Group Includes' }, { id: 'groupDefines', type: 'bool', label: 'Group Defines' }, { id: 'groupTypedefs', type: 'bool', label: 'Group Typedefs' }, { id: 'groupStructs', type: 'bool', label: 'Group Structs' }, { id: 'groupFuncProtos', type: 'bool', label: 'Group Func Prototypes' }, { id: 'groupVarDecls', type: 'bool', label: 'Group Variable Decls' }, { id: 'groupPreproc', type: 'bool', label: 'Group Preprocessor Blocks' } ] },
            { title: "Group Spacing (Add +1 Line)", items: [ { type: 'custom', html: `<div class="grid grid-cols-2 gap-x-4 gap-y-1 text-[10px] text-slate-400"><div class="font-bold border-b border-slate-700 mb-1">Type</div><div class="font-bold border-b border-slate-700 mb-1 flex justify-between"><span>Before</span><span>After</span></div><span>Includes</span><div class="flex justify-between px-1"><input type="checkbox" id="opt-emptyLineBeforeIncludes" class="custom-checkbox"><input type="checkbox" id="opt-emptyLineAfterIncludes" class="custom-checkbox"></div><span>Defines</span><div class="flex justify-between px-1"><input type="checkbox" id="opt-emptyLineBeforeDefines" class="custom-checkbox"><input type="checkbox" id="opt-emptyLineAfterDefines" class="custom-checkbox"></div><span>Typedefs</span><div class="flex justify-between px-1"><input type="checkbox" id="opt-emptyLineBeforeTypedefs" class="custom-checkbox"><input type="checkbox" id="opt-emptyLineAfterTypedefs" class="custom-checkbox"></div><span>Prototypes</span><div class="flex justify-between px-1"><input type="checkbox" id="opt-emptyLineBeforeFuncProtos" class="custom-checkbox"><input type="checkbox" id="opt-emptyLineAfterFuncProtos" class="custom-checkbox"></div><span>Var Decls</span><div class="flex justify-between px-1"><input type="checkbox" id="opt-emptyLineBeforeVarDecls" class="custom-checkbox"><input type="checkbox" id="opt-emptyLineAfterVarDecls" class="custom-checkbox"></div><span>Structs</span><div class="flex justify-between px-1"><input type="checkbox" id="opt-emptyLineBeforeStructs" class="custom-checkbox"><input type="checkbox" id="opt-emptyLineAfterStructs" class="custom-checkbox"></div></div>` } ] },
            { title: "Structure & Whitespace", items: [ { id: 'preserveEmptyLines', type: 'bool', label: 'Preserve Empty Lines' }, { id: 'topLevelEmptyLines', type: 'range', min: 0, max: 4, label: 'Top Level Empty Lines' }, { id: 'emptyLinesBetweenFunctions', type: 'range', min: 0, max: 4, label: 'Lines Between Funcs' }, { id: 'maxEmptyLines', type: 'range', min: 0, max: 4, label: 'Max Preserved Empty Lines' }, { id: 'emptyLineStartOfBlock', type: 'bool', label: 'Empty Line After {' }, { id: 'emptyLineEndOfBlock', type: 'bool', label: 'Empty Line Before }' } ] },
            { title: "Function Formatting", items: [ { id: 'columnLimit', type: 'range', min: 40, max: 120, label: 'Column Limit' }, { id: 'breakAfterFuncReturnType', type: 'bool', label: 'Break After Return Type' }, { id: 'breakAfterFuncOpenParen', type: 'bool', label: 'Break After Open Paren' }, { id: 'breakFuncArgsOnLimit', type: 'bool', label: 'Only Break if > Limit' }, { id: 'breakBeforeFuncCloseParen', type: 'bool', label: 'Break Before Close Paren' }, { id: 'funcParamStyle', type: 'select', options: ['Pack', 'Vertical'], label: 'Parameter Style' }, { id: 'breakBeforeFuncBrace', type: 'bool', label: 'Break Before Body Brace' } ] },
            { title: "Brace Wrapping", items: [ { id: 'braceStyle', type: 'select', options: ['K&R', 'Allman', 'GNU'], label: 'Brace Style' }, { id: 'breakBeforeIfBrace', type: 'bool', label: 'Break Before If Brace' }, { id: 'breakBeforeForBrace', type: 'bool', label: 'Break Before For Brace' }, { id: 'breakBeforeWhileBrace', type: 'bool', label: 'Break Before While Brace' }, { id: 'breakBeforeSwitchBrace', type: 'bool', label: 'Break Before Switch Brace' }, { id: 'breakBeforeElse', type: 'bool', label: 'Break Before Else' } ] },
            { title: "Formatting", items: [ { id: 'pointerAlignment', type: 'select', options: ['Left', 'Middle', 'Right'], label: 'Pointer Alignment' }, { id: 'spaceAfterKeywords', type: 'bool', label: 'Space After Keywords' } ] }
        ];

        function initUI() {
            const container = document.getElementById('settingsContainer'); container.innerHTML = '';
            settingsGroups.forEach(group => {
                const groupEl = document.createElement('div'); groupEl.className = 'mb-4';
                groupEl.innerHTML = `<h3 class="text-[10px] font-bold text-blue-400 uppercase tracking-widest mb-2 px-2 border-l-2 border-blue-500/50">${group.title}</h3>`;
                const itemsDiv = document.createElement('div'); itemsDiv.className = 'space-y-1';
                group.items.forEach(item => {
                    const row = document.createElement('div');
                    if (item.type === 'custom') row.innerHTML = item.html;
                    else {
                        row.className = 'flex items-center justify-between px-2 py-1 hover:bg-slate-800/50 rounded group';
                        if (item.type === 'bool') row.innerHTML = `<span class="text-xs text-slate-400 group-hover:text-slate-200 transition-colors">${item.label}</span><input type="checkbox" id="opt-${item.id}" ${config[item.id] ? 'checked' : ''} class="custom-checkbox">`;
                        else if (item.type === 'range') row.innerHTML = `<div class="flex flex-col w-full"><div class="flex justify-between w-full"><span class="text-xs text-slate-400 group-hover:text-slate-200">${item.label}</span><span id="val-${item.id}" class="text-[10px] text-blue-400 font-mono">${config[item.id]}</span></div><input type="range" id="opt-${item.id}" min="${item.min}" max="${item.max}" value="${config[item.id]}" class="w-full h-1"></div>`;
                        else if (item.type === 'select') row.innerHTML = `<span class="text-xs text-slate-400 group-hover:text-slate-200">${item.label}</span><select id="opt-${item.id}" class="bg-slate-950 border border-slate-700 text-[10px] text-slate-300 rounded px-1 py-0.5 outline-none focus:border-blue-500">${item.options.map(o => `<option value="${o}" ${config[item.id] === o ? 'selected' : ''}>${o}</option>`).join('')}</select>`;
                    }
                    itemsDiv.appendChild(row);
                });
                groupEl.appendChild(itemsDiv); container.appendChild(groupEl);
            });
            document.querySelectorAll('[id^="opt-"]').forEach(el => {
                el.addEventListener('change', (e) => {
                    const key = el.id.replace('opt-', '');
                    if (el.type === 'checkbox') config[key] = el.checked;
                    else if (el.type === 'range') { config[key] = parseInt(el.value); document.getElementById(`val-${key}`).textContent = el.value; }
                    else config[key] = el.value;
                    runFormat();
                });
                if(el.type === 'range') el.addEventListener('input', (e) => document.getElementById(`val-${el.id.replace('opt-', '')}`).textContent = e.target.value);
            });
        }
        function tokenize(src) {
            const tokens = []; let i = 0, len = src.length;
            const push = (t, v) => tokens.push({ t, v });
            while (i < len) {
                const c = src[i];
                if (c === '\n') { push(TokenType.NL, '\n'); i++; continue; }
                if (/\s/.test(c)) { let v = c; i++; while(i < len && /\s/.test(src[i]) && src[i] !== '\n') { v += src[i]; i++; } push(TokenType.WS, v); continue; }
                if (c === '/' && src[i+1] === '*') { let v = '/*'; i += 2; while (i < len && !(src[i] === '*' && src[i+1] === '/')) { v += src[i]; i++; } if (i < len) { v += '*/'; i += 2; } push(TokenType.CB, v); continue; }
                if (c === '/' && src[i+1] === '/') { let v = '//'; i += 2; while (i < len && src[i] !== '\n') { v += src[i]; i++; } push(TokenType.CL, v); continue; }
                if (c === '#') { let v = '#'; i++; while (i < len) { if (src[i] === '\n' && src[i-1] !== '\\') break; v += src[i]; i++; } push(TokenType.PP, v.trim()); continue; }
                if (c === '"' || c === "'") { let v = c; const q = c; i++; while (i < len) { if (src[i] === q && src[i-1] !== '\\') { v += q; i++; break; } v += src[i]; i++; } push(c === '"' ? TokenType.STR : TokenType.CHR, v); continue; }
                if (/[a-zA-Z_]/.test(c)) { let v = c; i++; while (i < len && /[a-zA-Z0-9_]/.test(src[i])) { v += src[i]; i++; } if (KEYWORDS.has(v)) push(TokenType.KW, v); else if (TYPES.has(v) || v.endsWith('_t')) push(TokenType.TY, v); else push(TokenType.ID, v); continue; }
                if (/[0-9]/.test(c) || (c === '.' && /[0-9]/.test(src[i+1]))) { let v = c; i++; while (i < len && /[0-9a-fA-FxX.uUlL]/.test(src[i])) { v += src[i]; i++; } push(TokenType.NUM, v); continue; }
                const s3 = src.substr(i, 3); if (OPS.assign.has(s3) || OPS.shift.has(s3)) { push(TokenType.OP, s3); i+=3; continue; }
                const s2 = src.substr(i, 2); if (['++', '--', '==', '!=', '<=', '>=', '&&', '||', '<<', '>>', '+=', '-=', '*=', '/=', '%=', '&=', '|=', '^=', '->'].includes(s2)) { push(TokenType.OP, s2); i+=2; continue; }
                if ('+-*/%=!&|^~<>?.'.includes(c)) { push(TokenType.OP, c); i++; continue; }
                if (c === '{') { push(TokenType.LBR, c); i++; continue; } else if (c === '}') { push(TokenType.RBR, c); i++; continue; } else if (c === '(') { push(TokenType.LPAR, c); i++; continue; } else if (c === ')') { push(TokenType.RPAR, c); i++; continue; } else if (c === '[') { push(TokenType.LBRA, c); i++; continue; } else if (c === ']') { push(TokenType.RBRA, c); i++; continue; } else if (c === ';') { push(TokenType.SEMI, c); i++; continue; } else if (c === ':') { push(TokenType.COLON, c); i++; continue; } else if (c === ',') { push(TokenType.PUNC, c); i++; continue; }
                push(TokenType.UNK, c); i++;
            }
            return tokens;
        }

        // --- PARTITIONER ---
        function parseStatements(tokens) {
            const stmts = [];
            let currentTokens = [];

            // Classifier
            const classify = (toks) => {
                let k = 0;
                // Skip leading comments
                while(k < toks.length && (toks[k].t === TokenType.CB || toks[k].t === TokenType.CL)) k++;
                if (k >= toks.length) return 'COMMENT';

                const first = toks[k];

                if (first.t === TokenType.PP) {
                    if (first.v.startsWith('#include')) return 'INCLUDE';
                    if (first.v.startsWith('#define')) return 'DEFINE';
                    if (first.v.startsWith('#if') || first.v.startsWith('#ifdef') || first.v.startsWith('#else') || first.v.startsWith('#endif')) return 'PREPROC_BLOCK';
                    return 'PREPROC';
                }

                if (first.v === 'typedef') {
                    // Check if this typedef defines a struct/union/enum with a body
                    // Look for an opening brace '{'
                    for (let j = k + 1; j < toks.length; j++) {
                        if (toks[j].t === TokenType.LBR) return 'STRUCT_DEF';
                    }
                    return 'TYPEDEF';
                }

                // Scan for structure/enum defs
                if (first.v === 'struct' || first.v === 'union' || first.v === 'enum') return 'STRUCT_DEF';

                // Scan for function definition vs prototype
                let hasParen = false, hasBrace = false;
                for (let i = k; i < toks.length; i++) {
                    if (toks[i].t === TokenType.LPAR) hasParen = true;
                    if (toks[i].t === TokenType.LBR) hasBrace = true;
                }

                // If ends in }, it's a function body (unless it started with typedef/struct)
                if (hasParen && hasBrace && toks[toks.length-1].t === TokenType.RBR) return 'FUNC_DEF';

                // If ends in ; and has parens, likely proto
                if (hasParen && toks[toks.length-1].t === TokenType.SEMI) {
                    // Check if it's actually a variable decl with initialization: int a = (1+2);
                    let hasAssign = false;
                    for (let i = k; i < toks.length; i++) {
                        if (OPS.assign.has(toks[i].v) || toks[i].v === '=') hasAssign = true;
                    }
                    if (hasAssign) return 'VAR_DECL';
                    // Check if parens are function args or just grouping.
                    // Heuristic: Type ID ( ... ) ;
                    return 'FUNC_PROTO';
                }

                return 'VAR_DECL';
            };

            let indent = 0;
            let i = 0;

            while (i < tokens.length) {
                const t = tokens[i];
                currentTokens.push(t);

                if (t.t === TokenType.LBR) indent++;
                else if (t.t === TokenType.RBR) indent--;

                let pushStmt = false;

                if (indent === 0) {
                    if (t.t === TokenType.PP) pushStmt = true;
                    else if (t.t === TokenType.SEMI) pushStmt = true;
                    else if (t.t === TokenType.RBR) {
                        // Check if this RBR closes a struct/enum or a function
                        let k = 0;
                        while(k < currentTokens.length && (currentTokens[k].t === TokenType.CB || currentTokens[k].t === TokenType.CL)) k++;
                        const first = currentTokens[k];
                        // If it started with struct/enum/union, we expect a semicolon later, so DON'T push yet.
                        // EXCEPT if it's an anonymous struct variable? "struct { } a;" -> waits for semi.
                        // "struct S { };" -> waits for semi.
                        // Functions: "void f() { }" -> ends at }.
                        const isDataStruct = first && (['struct','union','enum','typedef'].includes(first.v));

                        if (!isDataStruct) {
                            pushStmt = true; // Function definition end
                        }
                    }
                }

                if (pushStmt) {
                    stmts.push({ type: classify(currentTokens), tokens: [...currentTokens] });
                    currentTokens = [];
                }
                i++;
            }
            if (currentTokens.length > 0) stmts.push({ type: classify(currentTokens), tokens: currentTokens });
            return stmts;
        }

        // --- FORMATTER ---
        function format(source) {
            // Pre-process tokens to capture newline counts before filtering
            const rawTokensWithNL = tokenize(source);
            const procTokens = [];
            let nlCount = 0;

            for (const t of rawTokensWithNL) {
                if (t.t === TokenType.NL) {
                    nlCount++;
                } else if (t.t === TokenType.WS) {
                    // ignore generic whitespace
                } else {
                    t.nlBefore = nlCount;
                    nlCount = 0;
                    procTokens.push(t);
                }
            }

            if (procTokens.length === 0) return "";

            const stmts = parseStatements(procTokens);
            let finalOutput = "";
            let globalCol = 0;

            // Inner Formatter
            const formatStatementTokens = (tokens) => {
                let output = "";
                let indent = 0;
                let isStartOfLine = true;
                let parenDepth = 0;
                let inFuncArgs = false;
                let col = 0;

                // Stack to track blocks ({...}) and parenthesis contexts ((...))
                // blockStack types: 'BLOCK', 'STRUCT'
                // parenStack types: 'GENERIC', 'FOR_HEADER'
                const blockStack = [];
                const parenStack = [];

                const append = (s) => { output += s; col += s.length; isStartOfLine = false; };
                const newline = () => { output = output.trimEnd() + '\n'; col = 0; isStartOfLine = true; };
                const space = () => { if (!isStartOfLine && !output.endsWith(' ')) { output += ' '; col++; } };
                const writeIndent = () => {
                    if (isStartOfLine) {
                        const lvl = Math.max(0, indent);
                        const char = config.useTabs ? '\t' : ' ';
                        const mult = config.useTabs ? 1 : config.indentWidth;
                        output += char.repeat(lvl * mult);
                        col += config.useTabs ? (lvl * config.indentWidth) : (lvl * config.indentWidth);
                        isStartOfLine = false;
                    }
                };

                const ensureEmptyLine = () => {
                    output = output.trimEnd();
                    if (output.length > 0 && !output.endsWith('\n\n')) { if (!output.endsWith('\n')) output += '\n'; output += '\n'; }
                    isStartOfLine = true; col = 0; writeIndent();
                };

                // --- Helpers ---
                const isPointer = (idx) => { if (tokens[idx].v !== '*') return false; const p = tokens[idx-1]; if (!p) return false; if (p.t === TokenType.TY) return true; if (p.t === TokenType.ID && tokens[idx-2] && ['struct','union'].includes(tokens[idx-2].v)) return true; if (p.v === 'void' || (p.t === TokenType.ID && tokens[idx+1] && tokens[idx+1].t === TokenType.RPAR)) return true; return false; };
                const isUnary = (idx) => { const t = tokens[idx].v; if (!['+','-','*','&'].includes(t)) return false; const p = tokens[idx-1]; if (!p) return true; if (p.t === TokenType.OP || p.t === TokenType.LPAR || p.t === TokenType.LBRA || p.t === TokenType.SEMI || p.t === TokenType.KW || p.t === TokenType.COLON || p.t === TokenType.LBR || p.t === TokenType.PUNC) return true; return false; };
                const isControlParen = (idx) => { const prev = tokens[idx-1]; return prev && ['if','for','while','switch'].includes(prev.v); };
                const predictLineLength = (startIdx) => { let len = col; let j = startIdx; let balance = 0; while (j < tokens.length) { const t = tokens[j]; len += t.v.length; if (t.t === TokenType.LPAR) balance++; if (t.t === TokenType.RPAR) { balance--; if (balance < 0) break; } if (t.t === TokenType.LBR || t.t === TokenType.SEMI) break; if ([TokenType.KW, TokenType.TY, TokenType.ID, TokenType.NUM, TokenType.PUNC].includes(t.t)) len += 1; j++; } return len; };
                const isStructDef = (idx) => { let k = idx - 1; while (k >= 0 && k > idx - 5) { if (['struct','union','enum'].includes(tokens[k].v)) return true; if (tokens[k].t === TokenType.SEMI || tokens[k].t === TokenType.LBR || tokens[k].t === TokenType.RBR) break; k--; } return false; };

                for (let i = 0; i < tokens.length; i++) {
                    const t = tokens[i];
                    const prev = tokens[i-1];
                    const next = tokens[i+1];

                    // --- Manual Empty Line Preservation ---
                    if (config.preserveEmptyLines && t.nlBefore > 1) {
                         // Only insert lines if we aren't already at start of file or already spaced
                         if (output.trim().length > 0) {
                             // Determine how many lines to insert.
                             // If the previous token logic forced a newline (like ; or }), we might already be on a new line.
                             // We essentially want to ensure 'maxEmptyLines' blank lines exist.
                             const limit = config.maxEmptyLines;
                             const requested = t.nlBefore - 1; // 2 NLs in source = 1 blank line
                             const toAdd = Math.min(requested, limit);

                             if (toAdd > 0) {
                                 output = output.trimEnd(); // remove spaces from current line end
                                 // Add existing newline for the previous line completion if needed
                                 if (!output.endsWith('\n')) output += '\n';

                                 // Add blank lines
                                 for(let k=0; k<toAdd; k++) output += '\n';

                                 // Prepare for next content
                                 isStartOfLine = true; col = 0;
                             }
                         }
                    }

                    if (t.t === TokenType.RBR) { indent = Math.max(0, indent - 1); newline(); }
                    writeIndent();

                    if (t.t === TokenType.PP) {
                        if (!config.indentPP) { output = output.trimEnd() + '\n'; isStartOfLine = true; col=0; }
                        append(t.v);
                        continue;
                    }
                    if (t.t === TokenType.CB || t.t === TokenType.CL) { space(); append(t.v); newline(); continue; }

                    if (t.t === TokenType.LBR) {
                        if (isStructDef(i)) blockStack.push('STRUCT'); else blockStack.push('BLOCK');
                        if (prev && (prev.v === '=' || prev.t === TokenType.LBRA)) {
                            space(); append('{');
                            if (next && next.t === TokenType.RBR) { if (config.spaceInEmptyBraces) space(); } else if (config.spaceInBraces) space();
                        } else {
                            let breakBrace = false;
                            if (config.braceStyle === 'Allman' || config.braceStyle === 'GNU') breakBrace = true;
                            if (prev && prev.t === TokenType.RPAR) {
                                let j = i - 1; let bal = 0; while (j >= 0) { if (tokens[j].t === TokenType.RPAR) bal++; else if (tokens[j].t === TokenType.LPAR) bal--; if (bal === 0) break; j--; }
                                const kw = tokens[j-1];
                                if (kw) { if (kw.v === 'if' && config.breakBeforeIfBrace) breakBrace = true; else if (kw.v === 'for' && config.breakBeforeForBrace) breakBrace = true; else if (kw.v === 'while' && config.breakBeforeWhileBrace) breakBrace = true; else if (kw.v === 'switch' && config.breakBeforeSwitchBrace) breakBrace = true; else if (kw.t === TokenType.ID && config.breakBeforeFuncBrace) breakBrace = true; }
                            } else if (prev && prev.v === 'else' && config.breakBeforeElse) breakBrace = true;
                            if (breakBrace) { newline(); writeIndent(); append('{'); } else { space(); append('{'); }
                            indent++; newline();
                            if (config.emptyLineStartOfBlock) ensureEmptyLine();
                        }
                    }
                    else if (t.t === TokenType.RBR) {
                        const blockType = blockStack.pop();
                        if (config.emptyLineEndOfBlock && prev && prev.t !== TokenType.LBR) { output = output.trimEnd(); if(!output.endsWith('\n\n')) { if(!output.endsWith('\n')) output += '\n'; output += '\n'; } writeIndent(); }
                        append('}');
                        if (blockType === 'STRUCT') { if (next && next.t !== TokenType.SEMI) { if (config.breakAfterStructClosingBrace) newline(); else space(); } }
                        else if (next) { if (next.v === 'else' || next.v === 'while') { if (config.braceStyle === 'K&R' && !config.breakBeforeElse && !(next.v==='while' && config.breakBeforeWhile)) space(); else newline(); } else if (next.t !== TokenType.SEMI && next.t !== TokenType.PUNC && next.t !== TokenType.RPAR) { newline(); } }
                    }
                    else if (t.t === TokenType.SEMI) {
                        append(';');

                        // Smart Semicolon Logic
                        let forceNewline = true;

                        // 1. Inside a 'for' loop header?
                        if (parenStack.length > 0 && parenStack[parenStack.length-1] === 'FOR_HEADER') {
                            forceNewline = false;
                        }

                        // 2. Inside a struct definition?
                        if (blockStack.length > 0 && blockStack[blockStack.length-1] === 'STRUCT') {
                            if (config.structMemberOnePerLine) forceNewline = true;
                            else forceNewline = false;
                        }

                        if (forceNewline) {
                             if (next && next.t !== TokenType.NL && next.t !== TokenType.RBR) newline();
                        } else {
                            if (config.spaceSemi && next && next.t !== TokenType.NL && next.t !== TokenType.RBR) space();
                        }
                    }
                    else if (t.t === TokenType.KW) {
                        if (t.v === 'if' && config.emptyLineBeforeIf) { if(!prev || prev.v !== 'else') ensureEmptyLine(); }
                        else if (t.v === 'for' && config.emptyLineBeforeFor) ensureEmptyLine();
                        else if (t.v === 'while' && config.emptyLineBeforeWhile) { if(!prev || prev.t !== TokenType.RBR) ensureEmptyLine(); }
                        else if (t.v === 'do' && config.emptyLineBeforeDo) ensureEmptyLine();
                        else if (t.v === 'switch' && config.emptyLineBeforeSwitch) ensureEmptyLine();
                        else if (t.v === 'case' && config.emptyLineBeforeCase) ensureEmptyLine();
                        else if (t.v === 'default' && config.emptyLineBeforeCase) ensureEmptyLine();
                        else if (t.v === 'break' && config.emptyLineBeforeBreak) ensureEmptyLine();
                        else if (t.v === 'return' && config.emptyLineBeforeReturn) ensureEmptyLine();

                        if (t.v === 'case' || t.v === 'default') { const saved = indent; if (!config.indentCase) indent = Math.max(0, indent - 1); if (!isStartOfLine) newline(); isStartOfLine = true; writeIndent(); append(t.v); indent = saved; }
                        else if (t.v === 'return') { append(t.v); if (next && (next.t === TokenType.ID || next.t === TokenType.NUM || next.t === TokenType.STR || next.t === TokenType.CHR || next.t === TokenType.TY || next.t === TokenType.KW || next.t === TokenType.OP)) { space(); } }
                        else { append(t.v); if (['if', 'for', 'while', 'switch'].includes(t.v)) { if (config.spaceAfterKeywords) space(); } else { if (next && (next.t===TokenType.ID || next.t===TokenType.KW || next.t===TokenType.TY)) space(); } }
                    }
                    else if (t.t === TokenType.TY || t.t === TokenType.ID || t.t === TokenType.NUM) {
                        if (t.t === TokenType.ID && next && next.t === TokenType.LPAR && config.breakAfterFuncReturnType) { if (prev && (prev.t === TokenType.TY || (prev.t === TokenType.OP && prev.v === '*') || prev.v === 'void')) { newline(); writeIndent(); } }
                        append(t.v); if (next && (next.t===TokenType.TY || next.t===TokenType.ID || next.t===TokenType.KW || next.t===TokenType.NUM)) space();
                    }
                    else if (t.t === TokenType.OP) {
                        const v = t.v;
                        if (v === '*') { if (isPointer(i)) { if (config.pointerAlignment === 'Left') append('*'); else if (config.pointerAlignment === 'Right') { space(); append('*'); } else { space(); append('* '); } } else if (isUnary(i)) { if (config.spaceUnary) space(); append('*'); } else { if (config.spaceMultiplicative) { space(); append('*'); space(); } else append('*'); } }
                        else if (v === '&') { if (isUnary(i)) { if (config.spaceUnary) space(); append('&'); } else { if (config.spaceBitwise) { space(); append('&'); space(); } else append('&'); } }
                        else if (['+','-'].includes(v)) { if (isUnary(i)) { if (config.spaceUnary) space(); append(v); } else { if (config.spaceAdditive) { space(); append(v); space(); } else append(v); } }
                        else if (OPS.assign.has(v)) { if (config.spaceAssign) { space(); append(v); space(); } else append(v); }
                        else if (OPS.equality.has(v)) { if (config.spaceEquality) { space(); append(v); space(); } else append(v); }
                        else if (OPS.relational.has(v)) { if (config.spaceRelational) { space(); append(v); space(); } else append(v); }
                        else if (OPS.logical.has(v)) { if (config.spaceLogical) { space(); append(v); space(); } else append(v); }
                        else if (OPS.shift.has(v)) { if (config.spaceShift) { space(); append(v); space(); } else append(v); }
                        else if (OPS.unary.has(v)) { if (v.length===2 && prev && (prev.t===TokenType.ID||prev.t===TokenType.RPAR||prev.t===TokenType.RBRA)) { append(v); } else { append(v); if(config.spaceUnary) space(); } }
                        else if (['.', '->'].includes(v)) { append(v); } else { space(); append(v); space(); }
                    }
                    else if (t.t === TokenType.COLON) { if (prev && prev.v === '?') { if (config.spaceTernary) { space(); append(':'); space(); } else append(':'); } else if (next && next.t !== TokenType.NL) { append(':'); space(); } else { append(':'); newline(); } }
                    else if (t.t === TokenType.PUNC) {
                        append(',');
                        if (inFuncArgs) {
                            if (config.funcParamStyle === 'Vertical') { newline(); } else { if (config.spaceComma) space(); }
                        } else if (blockStack.length > 0 && blockStack[blockStack.length-1] === 'STRUCT') {
                            // Enum list or struct member list
                            if (config.structMemberOnePerLine) newline(); else if (config.spaceComma) space();
                        } else {
                            if (config.spaceComma) space();
                        }
                    }
                    else if (t.t === TokenType.LPAR) {
                        const isCtrl = isControlParen(i);

                        // Push context
                        if (prev && prev.v === 'for') parenStack.push('FOR_HEADER');
                        else parenStack.push('GENERIC');

                        if (prev && prev.t === TokenType.ID) { if (isCtrl) { } else if (config.spaceBeforeFuncCallParen) space(); }
                        append('(');
                        parenDepth++;
                        if (!isCtrl && prev && prev.t === TokenType.ID) {
                            inFuncArgs = true;
                            let shouldBreak = config.breakAfterFuncOpenParen;
                            if (shouldBreak && config.breakFuncArgsOnLimit) { const predicted = predictLineLength(i + 1); if (predicted <= config.columnLimit) shouldBreak = false; }
                            if (shouldBreak) newline(); else if (config.spaceInParens) space();
                        } else {
                            if (config.spaceInParens) space();
                        }
                    }
                    else if (t.t === TokenType.RPAR) {
                        parenStack.pop();
                        parenDepth--;
                        if (inFuncArgs && parenDepth === 0) {
                            inFuncArgs = false;
                            if (config.breakBeforeFuncCloseParen) { newline(); writeIndent(); }
                        }
                        if (!config.breakBeforeFuncCloseParen && config.spaceInParens) { if (output.endsWith(' ')) output = output.slice(0, -1); if (!prev || prev.t !== TokenType.LPAR) append(' '); }
                        append(')');
                    }
                    else if (t.t === TokenType.LBRA) { append('['); if (config.spaceInBrackets) space(); }
                    else if (t.t === TokenType.RBRA) { if (config.spaceInBrackets) { if (output.endsWith(' ')) output = output.slice(0, -1); if (!prev || prev.t !== TokenType.LBRA) append(' '); } append(']'); }
                    else { append(t.v); }
                }
                return output.trim();
            };

            for (let i = 0; i < stmts.length; i++) {
                const curr = stmts[i];
                const prev = i > 0 ? stmts[i-1] : null;

                if (prev) {
                    let newlines = config.topLevelEmptyLines + 1;
                    let grouping = false;

                    if (prev.type === curr.type) {
                        if (curr.type === 'INCLUDE' && config.groupIncludes) grouping = true;
                        else if (curr.type === 'DEFINE' && config.groupDefines) grouping = true;
                        else if (curr.type === 'TYPEDEF' && config.groupTypedefs) grouping = true;
                        else if (curr.type === 'STRUCT_DEF' && config.groupStructs) grouping = true;
                        else if (curr.type === 'FUNC_PROTO' && config.groupFuncProtos) grouping = true;
                        else if (curr.type === 'VAR_DECL' && config.groupVarDecls) grouping = true;
                        else if (curr.type === 'PREPROC' && config.groupPreproc) grouping = true;
                    }

                    if (prev.type === 'FUNC_DEF' || curr.type === 'FUNC_DEF') {
                        newlines = config.emptyLinesBetweenFunctions + 1;
                        grouping = false;
                    }

                    if (grouping) {
                        newlines = 1; // Tight packing
                    } else {
                        // Apply Overrides Additively when NOT grouping
                        let extra = 0;
                        // After Previous
                        if (prev.type === 'INCLUDE' && config.emptyLineAfterIncludes) extra = 1;
                        else if (prev.type === 'DEFINE' && config.emptyLineAfterDefines) extra = 1;
                        else if (prev.type === 'TYPEDEF' && config.emptyLineAfterTypedefs) extra = 1;
                        else if (prev.type === 'FUNC_PROTO' && config.emptyLineAfterFuncProtos) extra = 1;
                        else if (prev.type === 'VAR_DECL' && config.emptyLineAfterVarDecls) extra = 1;
                        else if (prev.type === 'STRUCT_DEF' && config.emptyLineAfterStructs) extra = 1;

                        // Before Current
                        if (curr.type === 'INCLUDE' && config.emptyLineBeforeIncludes) extra = Math.max(extra, 1);
                        else if (curr.type === 'DEFINE' && config.emptyLineBeforeDefines) extra = Math.max(extra, 1);
                        else if (curr.type === 'TYPEDEF' && config.emptyLineBeforeTypedefs) extra = Math.max(extra, 1);
                        else if (curr.type === 'FUNC_PROTO' && config.emptyLineBeforeFuncProtos) extra = Math.max(extra, 1);
                        else if (curr.type === 'VAR_DECL' && config.emptyLineBeforeVarDecls) extra = Math.max(extra, 1);
                        else if (curr.type === 'STRUCT_DEF' && config.emptyLineBeforeStructs) extra = Math.max(extra, 1);

                        newlines += extra;
                    }

                    finalOutput += '\n'.repeat(newlines);
                }

                finalOutput += formatStatementTokens(curr.tokens);
            }
            return finalOutput;
        }

        function highlight(code) {
            const tokens = tokenize(code); let html = "";
            const esc = (s) => s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
            for (const t of tokens) {
                const v = esc(t.v);
                if (t.t === TokenType.KW) html += `<span class="tok-kw">${v}</span>`;
                else if (t.t === TokenType.TY) html += `<span class="tok-ty">${v}</span>`;
                else if (t.t === TokenType.STR || t.t === TokenType.CHR) html += `<span class="tok-str">${v}</span>`;
                else if (t.t === TokenType.NUM) html += `<span class="tok-num">${v}</span>`;
                else if (t.t === TokenType.CB || t.t === TokenType.CL) html += `<span class="tok-cm">${v}</span>`;
                else if (t.t === TokenType.PP) html += `<span class="tok-pp">${v}</span>`;
                else if (t.t === TokenType.OP) html += `<span class="tok-op">${v}</span>`;
                else if (t.t === TokenType.PUNC) html += `<span class="tok-punc">${v}</span>`;
                else if (t.t === TokenType.ID) html += `<span class="tok-id">${v}</span>`;
                else html += v;
            }
            return html;
        }
        const inputArea = document.getElementById('inputArea');
        const outputArea = document.getElementById('outputArea');
        const status = document.getElementById('statusIndicator');
        const charCount = document.getElementById('inputCharCount');
        function runFormat() {
            const code = inputArea.value; charCount.textContent = code.length + " chars";
            try {
                const start = performance.now(); const formatted = format(code);
                currentRawOutput = formatted; outputArea.innerHTML = highlight(formatted);
                const time = (performance.now() - start).toFixed(1);
                status.innerHTML = `<div class="w-1.5 h-1.5 rounded-full bg-green-500"></div><span class="text-[10px] text-green-500 font-medium">Ready (${time}ms)</span>`;
                status.style.opacity = '1';
            } catch (e) {
                console.error(e); outputArea.innerHTML = `<span class="text-red-400">Error: ${e.message}</span>`;
            }
        }
        const SNIPPETS = {
            structs: `typedef unsigned short uint16;
typedef unsigned int uint32;
typedef float real32;
typedef double real64;

#if defined(REICH_PLATFORM_WIN32)

typedef __int64 int64;
typedef unsigned __int64 uint64;

#else

typedef long long int64;
typedef unsigned long long uint64;

#endif

typedef unsigned long reichSize;

typedef struct Vector3 {
    real32 x; real32 y; real32 z;
} Vector3;

typedef struct Matrix4 {
    real32 m[4][4];
} Matrix4;

#define REICH_FILE_READ  1
#define REICH_FILE_WRITE 2
#define REICH_SEEK_SET   0`,
            allFeatures: `/* Comprehensive C89 Formatting Test */
#include <stdlib.h>
#define SCALE(x) ((x) * 2)

typedef struct Node {
    int val;
    struct Node *next;
} Node;

void complexFunction(int param1, int param2, char *name, Node *list, int flags);

int main() {
    int a = 1, b = 2, c = 3;
    int *ptr = &a;
    Node *head = NULL;

    /* Control Structures */
    if(a > b) {
        a = b;
    } else if(c > a) {
        c = a;
    } else {
        b = c;
    }

    for(a = 0; a < 10; a++) {
        if(a % 2 == 0) continue;
        switch(a) {
            case 1: b++; break;
            case 2: /* Fallthrough */
            default: c--;
        }
    }

    while(b > 0) b >>= 1;

    do { c++; } while(c < 100);

    /* Operators & Spacing */
    a = (b + c) * 2;
    c += (a | b) ^ 0xFF;
    if(!ptr && (a || b)) return -1;

    /* Function Call & Arguments */
    complexFunction(a, b, "test", head, (c > 10) ? 1 : 0);

    return 0;
}

void complexFunction(int param1, int param2, char *name, Node *list, int flags) {
    if(!list) return;
    list->val = param1 + param2;
}`,
            linkedList: `#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data;\n    struct Node *next;\n} Node;\n\nNode *createNode(int data) {\n    Node *newNode = (Node *)malloc(sizeof(Node));\n    if (!newNode) return NULL;\n    newNode->data = data;\n    newNode->next = NULL;\n    return newNode;\n}\n\nint main() {\n    Node *head = createNode(1);\n    head->next = createNode(2);\n    \n    Node *curr = head;\n    while(curr) {\n        printf("%d -> ", curr->data);\n        curr = curr->next;\n    }\n    printf("NULL\\n");\n    return 0;\n}`,
            funcStyle: `// Test Function Styles\nvoid longFunctionName(int param1, int param2, int param3) {\n    return;\n}\n\nint calculate(int a, int b) {\n    return a + b;\n}`,
            matrix: `#define SIZE 3\n\nvoid multiply(int A[SIZE][SIZE], int B[SIZE][SIZE], int C[SIZE][SIZE]) {\n    int i, j, k;\n    for (i = 0; i < SIZE; i++) {\n        for (j = 0; j < SIZE; j++) {\n            C[i][j] = 0;\n            for (k = 0; k < SIZE; k++)\n                C[i][j] += A[i][k] * B[k][j];\n        }\n    }\n}`
        };
        initUI();
        document.getElementById('snippetSelect').addEventListener('change', (e) => { if (SNIPPETS[e.target.value]) { inputArea.value = SNIPPETS[e.target.value]; runFormat(); e.target.value=""; } });
        document.getElementById('resetBtn').onclick = () => { config = { ...DEFAULT_CONFIG }; initUI(); runFormat(); };
        document.getElementById('copyBtn').onclick = () => { navigator.clipboard.writeText(currentRawOutput); const btn = document.getElementById('copyBtn'); const orig = btn.innerText; btn.innerText = 'Copied!'; btn.classList.add('bg-green-600'); setTimeout(() => { btn.innerText = orig; btn.classList.remove('bg-green-600'); }, 1000); };
        document.getElementById('searchInput').addEventListener('input', (e) => { const term = e.target.value.toLowerCase(); document.querySelectorAll('#settingsContainer > div').forEach(grp => { const visibleItems = Array.from(grp.querySelectorAll('.group')).filter(row => { const txt = row.textContent.toLowerCase(); const visible = txt.includes(term); row.style.display = visible ? '' : 'none'; return visible; }); grp.style.display = visibleItems.length > 0 ? '' : 'none'; }); });
        inputArea.addEventListener('input', runFormat);
        inputArea.value = SNIPPETS.structs;
        runFormat();
    </script>
</body>
</html>
