<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Volumetric Cloud Layers</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; user-select: none; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
        }

        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); backdrop-filter: blur(10px);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; transition: opacity 0.5s; cursor: pointer; pointer-events: auto;
        }
        #start-screen.fade-out { opacity: 0; pointer-events: none; }
        #start-btn {
            padding: 20px 40px; border: 2px solid white; color: white;
            font-size: 1.5rem; font-family: monospace; letter-spacing: 4px;
            background: transparent; transition: all 0.2s;
        }
        #start-btn:hover { background: white; color: black; }

        #loading {
            position: absolute; top: 50%; left: 50%; 
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.9); 
            font-family: monospace; font-size: 1.2rem; letter-spacing: 2px;
            transition: opacity 0.5s ease-out;
            text-align: center;
            background: rgba(0,0,0,0.5); padding: 20px; border-radius: 8px;
            backdrop-filter: blur(5px);
        }

        #overlay {
            position: absolute; bottom: 20px; left: 20px;
            color: white; font-family: 'Segoe UI', sans-serif;
            text-align: left; pointer-events: auto;
            background: rgba(0, 0, 0, 0.6);
            padding: 20px; border-radius: 8px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.1);
            transition: opacity 0.3s;
        }

        #telemetry {
            position: absolute; top: 20px; right: 20px;
            text-align: right; color: rgba(255, 255, 255, 0.9);
            font-family: monospace; font-size: 0.9rem;
            text-shadow: 0 1px 2px rgba(0,0,0,0.8);
            pointer-events: none;
        }

        #audio-status {
            color: #888; font-weight: bold; margin-top: 8px; font-size: 0.8em; letter-spacing: 1px;
        }
        #audio-status.active { color: #00ff88; }
        #chord-display {
            color: #aaa; font-size: 0.8em; margin-top: 5px; font-family: monospace;
        }

        h1 { margin: 0 0 10px 0; font-weight: 300; font-size: 1.2rem; letter-spacing: 2px; }
        
        .control-row { margin: 4px 0; display: flex; align-items: center; }
        .key {
            display: inline-block; padding: 2px 6px;
            background: rgba(255,255,255,0.1); border-radius: 4px;
            font-family: monospace; color: #fff; margin: 0 2px;
            border: 1px solid rgba(255,255,255,0.2);
            font-size: 0.9rem; transition: background 0.1s, border-color 0.1s;
        }
        .key.active { background: #fff; color: #000; border-color: #fff; box-shadow: 0 0 10px white; }

        .hidden { opacity: 0 !important; pointer-events: none !important; }
        .lil-gui { --width: 320px; }
    </style>
</head>
<body>
    <div id="start-screen">
        <div id="start-btn">ENGAGE LAYER SYSTEM</div>
        <div style="margin-top: 20px; color: #aaa; font-family: monospace;">Multi-Scale Cloud Engine</div>
    </div>

    <div id="loading">GENERATING NOISE TEXTURE...</div>
    
    <div id="ui-layer">
        <div id="telemetry">
            ALT: <span id="val-alt">0</span> ft<br>
            SPD: <span id="val-spd">0</span> kts<br>
            POS: <span id="val-pos">0, 0</span><br>
            DENS: <span id="val-dens">0%</span>
        </div>

        <div id="overlay">
            <h1>CONTROLS</h1>
            <div style="line-height: 1.6; font-size: 0.9rem;">
                <div class="control-row"><span class="key" id="k-w">W</span><span class="key" id="k-s">S</span> Dive / Climb</div>
                <div class="control-row"><span class="key" id="k-a">A</span><span class="key" id="k-d">D</span> Roll Left / Right</div>
                <div class="control-row"><span class="key" id="k-l">←</span><span class="key" id="k-r">→</span> Yaw Left / Right</div>
                <div class="control-row"><span class="key" id="k-u">↑</span><span class="key" id="k-dn">↓</span> Throttle +/-</div>
                <div class="control-row"><span class="key">H</span> Toggle UI</div>
                <div id="audio-status">AUDIO STANDBY</div>
                <div id="chord-display">Scale: Initializing...</div>
            </div>
        </div>
    </div>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        let renderer, scene, camera, flightControls, audioManager;
        let worldScene, terrainMesh, terrainTarget, dirLight; 
        let cloudTarget, denoiseTarget, rayTarget;
        let cloudMat, denoiseMat, rayMat, compositeMat;
        let postScene, postQuad;
        let clock = new THREE.Clock();
        let uiGui, layersFolder; 
        
        
        const MAX_LAYERS = 4;

        // small helpers to keep uniform allocation concise and explicit
        function allocFloat(n) { return new Float32Array(n); }
        function allocVec2Array(n) { return Array.from({length:n}, () => new THREE.Vector2()); }
        function allocVec3Array(n) { return Array.from({length:n}, () => new THREE.Vector3()); }
        
        
        const createDefaultLayer = (id) => ({
            id: id,
            active: true,
            name: `Layer ${id + 1}`,
            bottom: 2000 + (id * 3000),
            top: 4500 + (id * 3000),
            density: 1.0,
            // densityUI is the user-facing slider value (0..1) mapped exponentially to density
            densityUI: Math.pow(1.0 / 3.0, 1.0 / 3.0),
            coverage: 0.55,
            colorTop: '#ffffff',
            colorBottom: '#5c6e8c',
            
            
            scaleMacro: 0.15, 
            macroOctaves: 2,
            scaleMicro: 3.0,  
            microOctaves: 3,
            detailMix: 0.8, 
            turbulence: 0.15, 
            coverageExponent: 1.0, 
            
            absorption: 0.2, 
            silver: 0.15, 
            darkEdge: 0.08, 
            scattering: 0.08, 
            microContrast: 1.0, 
            
            macroDensity: 0.2, 
            macroFalloff: 2.0, 
            macroCoreBias: 1.0, 
            macroEdgeSoftness: 0.15, 
            
            windSpeed: 0.2 + (id * 0.1),
            windAngle: 0.0,
            erosion: 0.6,
            type: 0.5 
        });

        const LAYERS = [
            createDefaultLayer(0) 
        ];

        const GLOBAL_CONFIG = {
            
            sunElevation: 12,
            sunAzimuth: 180,
            sunIntensity: 1.0,
            ambientIntensity: 0.2,
            silverLining: 0.7, 
            silverSpread: 0.5, 
            powder: 1.0,
            cloudAbsorption: 1.2,
            sunDiskIntensity: 50.0,
            exposure: 1.0,
            skySaturation: 1.0,
            shadowTint: '#0a1a2b',
            // automatic quality scaling to reduce steps at high altitudes
            autoQuality: true,
            minSteps: 32,
            enableClouds: true,
            
            
            skyColorZenith: '#3a76c4',
            skyColorHorizon: '#e8f4f8',
            skySunsetZenith: '#2a3b55',
            skySunsetHorizon: '#ff8800',
            groundColor: '#050508',
            rayleigh: 1.2, 
            mieCoefficient: 0.005,
            mieDirectionalG: 0.8,
            fogDensity: 0.000015,
            
            
            resolution: 0.5,    
            steps: 96,          
            lightSteps: 12, 
            noiseOctaves: 3,    
            dithering: true,
            lodDistance: 20000.0,
            maxDist: 100000.0, 
            enableDenoise: true,

            
            rayIntensity: 1.0,
            rayDensity: 1.2,
            rayWeight: 0.58,
            rayDecay: 0.985,
            rayExposure: 0.55,
            raySamples: 60,

            
            masterVolume: 0.5,
            volSynths: 0.6,
            volBass: 0.7,
            volWind: 0.4,
            volReverb: 0.7,
            volCabin: 0.4,
            volArp: 0.5,
            volAtmos: 0.5
        };

        
        const NOTES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        const SCALES = {
            AEOLIAN: [0, 2, 3, 5, 7, 8, 10], 
            DORIAN:  [0, 2, 3, 5, 7, 9, 10], 
            PHRYGIAN:[0, 1, 3, 5, 7, 8, 10], 
            LYDIAN:  [0, 2, 4, 6, 7, 9, 11]  
        };
        const mtof = (note) => 440 * Math.pow(2, (note - 69) / 12);
        const HARMONIC_PROGRESSION = [
            { scale: 'AEOLIAN', rootOff: 0, bars: 8 },  
            { scale: 'DORIAN',  rootOff: 5, bars: 4 },  
            { scale: 'AEOLIAN', rootOff: 0, bars: 4 },  
            { scale: 'PHRYGIAN',rootOff: 7, bars: 2 },  
            { scale: 'PHRYGIAN',rootOff: 2, bars: 2 },  
            { scale: 'AEOLIAN', rootOff: 0, bars: 4 }   
        ];

        class AtmosphereAudio {
            constructor() {
                this.ctx = null;
                this.masterGain = null;
                this.windNodes = {};
                this.reverbNodes = {};
                this.delayNodes = {};
                this.busses = {}; 
                this.droneNodes = { osc: [] }; 
                this.bassNodes = {};
                this.cabinNodes = {};
                this.initialized = false;
                
                this.tempo = 90; 
                this.nextNoteTime = 0;
                this.scheduleAheadTime = 0.1;
                this.current16thNote = 0;
                this.barCount = 0;
                this.cycleCount = 0; 
                
                this.rootNoteBase = 58; 
                this.progressionIndex = 0;
                this.barsInCurrentStage = 0;
                this.currentScaleType = 'AEOLIAN';
                this.currentRoot = 58;

                this.currentPadType = 'IDLE'; 
                this.activePad = null; 
                this.speedFactor = 0.0;
                this.synthVolumeMult = 1.0;
                this.cloudDensity = 0.0;
                this.timeOfDay = 1.0; 
                this.altitudeFactor = 0.0; 
                
                this.masterFilter = null;
            }

            init() {
                if (this.initialized) return;
                try {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.ctx = new AudioContext();
                    
                    this.masterGain = this.ctx.createGain();
                    this.masterGain.gain.value = GLOBAL_CONFIG.masterVolume;
                    
                    const compressor = this.ctx.createDynamicsCompressor();
                    compressor.threshold.value = -18;
                    compressor.ratio.value = 8;
                    
                    this.masterFilter = this.ctx.createBiquadFilter();
                    this.masterFilter.type = 'lowpass';
                    this.masterFilter.frequency.value = 20000;

                    this.masterGain.connect(compressor);
                    compressor.connect(this.masterFilter);
                    this.masterFilter.connect(this.ctx.destination);

                    this.busses.synth = this.ctx.createGain();
                    this.busses.synth.connect(this.masterGain);

                    this.busses.bass = this.ctx.createGain();
                    this.busses.bass.connect(this.masterGain);

                    this.busses.wind = this.ctx.createGain();
                    this.busses.wind.connect(this.masterGain);
                    
                    this.busses.cabin = this.ctx.createGain();
                    this.busses.cabin.connect(this.masterGain);

                    this.busses.arp = this.ctx.createGain();
                    this.busses.arp.connect(this.masterGain);

                    this.busses.atmos = this.ctx.createGain();
                    this.busses.atmos.connect(this.masterGain);

                    this.setupReverb();
                    this.setupDelay();
                    this.setupWind();
                    this.setupCabin();
                    this.setupDrone();
                    this.setupBass();

                    this.initialized = true;
                    this.nextNoteTime = this.ctx.currentTime + 0.1;
                    this.updateStatus(true);
                    this.scheduler(); 
                } catch (e) { 
                    console.warn("Audio Init Failed", e);
                    this.updateStatus(false);
                }
            }

            updateStatus(success) {
                const el = document.getElementById('audio-status');
                if (success) {
                    el.innerText = "AUDIO ONLINE";
                    el.classList.add('active');
                } else {
                    el.innerText = "AUDIO FAILED";
                }
            }

            updateVolumes() {
                if(!this.initialized) return;
                
                const movementFade = THREE.MathUtils.smoothstep(this.speedFactor, 0.0, 0.15);
                
                this.masterGain.gain.setTargetAtTime(GLOBAL_CONFIG.masterVolume, this.ctx.currentTime, 0.1);
                
                const droneVol = 0.04 * (0.2 + 0.8 * movementFade);
                this.droneNodes.osc.forEach(d => d.gain.gain.setTargetAtTime(droneVol, this.ctx.currentTime, 0.5));

                this.busses.synth.gain.setTargetAtTime(GLOBAL_CONFIG.volSynths * movementFade, this.ctx.currentTime, 0.1);
                this.busses.bass.gain.setTargetAtTime(GLOBAL_CONFIG.volBass * movementFade, this.ctx.currentTime, 0.1);
                this.busses.arp.gain.setTargetAtTime(GLOBAL_CONFIG.volArp * movementFade, this.ctx.currentTime, 0.1);
                this.busses.atmos.gain.setTargetAtTime(GLOBAL_CONFIG.volAtmos * movementFade, this.ctx.currentTime, 0.1);
                
                this.busses.cabin.gain.setTargetAtTime(GLOBAL_CONFIG.volCabin, this.ctx.currentTime, 0.1);
                this.reverbNodes.input.gain.setTargetAtTime(GLOBAL_CONFIG.volReverb, this.ctx.currentTime, 0.1);
            }

            setupReverb() {
                const duration = 5.0;
                const decay = 4.0;
                const len = this.ctx.sampleRate * duration;
                const buffer = this.ctx.createBuffer(2, len, this.ctx.sampleRate);
                for (let c = 0; c < 2; c++) {
                    const data = buffer.getChannelData(c);
                    for (let i = 0; i < len; i++) {
                        data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / len, decay);
                    }
                }
                this.reverbNodes.convolver = this.ctx.createConvolver();
                this.reverbNodes.convolver.buffer = buffer;
                this.reverbNodes.input = this.ctx.createGain();
                this.reverbNodes.input.connect(this.reverbNodes.convolver);
                this.reverbNodes.convolver.connect(this.masterGain);
            }

            setupDelay() {
                this.delayNodes.delay = this.ctx.createDelay(1.0);
                this.delayNodes.delay.delayTime.value = 0.35; 
                this.delayNodes.feedback = this.ctx.createGain();
                this.delayNodes.feedback.gain.value = 0.4;
                
                this.delayNodes.delay.connect(this.delayNodes.feedback);
                this.delayNodes.feedback.connect(this.delayNodes.delay);
                this.delayNodes.delay.connect(this.busses.atmos);
            }

            setupWind() {
                const bSize = 2 * this.ctx.sampleRate;
                const buff = this.ctx.createBuffer(1, bSize, this.ctx.sampleRate);
                const data = buff.getChannelData(0);
                let b0=0, b1=0, b2=0, b3=0, b4=0, b5=0, b6=0;
                for(let i=0; i<bSize; i++) {
                    let white = Math.random() * 2 - 1;
                    b0 = 0.99886 * b0 + white * 0.0555179;
                    b1 = 0.99332 * b1 + white * 0.0750759;
                    b2 = 0.96900 * b2 + white * 0.1538520;
                    b3 = 0.86650 * b3 + white * 0.3104856;
                    b4 = 0.55000 * b4 + white * 0.5329522;
                    b5 = -0.7616 * b5 - white * 0.0168980;
                    data[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
                    data[i] *= 0.11; 
                    b6 = white * 0.115926;
                }
                const src = this.ctx.createBufferSource();
                src.buffer = buff;
                src.loop = true;
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 200;
                const gain = this.ctx.createGain();
                gain.gain.value = 0.0;
                src.connect(filter);
                filter.connect(gain);
                gain.connect(this.busses.wind); 
                this.windNodes = { src, filter, gain };
                src.start();
            }

            setupCabin() {
                const bSize = 2 * this.ctx.sampleRate;
                const buff = this.ctx.createBuffer(1, bSize, this.ctx.sampleRate);
                const data = buff.getChannelData(0);
                let lastOut = 0;
                for(let i=0; i<bSize; i++) {
                    let white = Math.random() * 2 - 1;
                    data[i] = (lastOut + (0.02 * white)) / 1.02;
                    lastOut = data[i];
                    data[i] *= 3.5; 
                }
                
                const src = this.ctx.createBufferSource();
                src.buffer = buff;
                src.loop = true;
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 120; 
                const gain = this.ctx.createGain();
                gain.gain.value = 0.3; 
                src.connect(filter);
                filter.connect(gain);
                gain.connect(this.busses.cabin);
                this.cabinNodes = { src, filter, gain };
                src.start();
            }

            setupDrone() {
                this.droneNodes.osc = [];
                const freqs = [0.5, 1.0, 1.5];
                freqs.forEach(mult => {
                    const osc = this.ctx.createOscillator();
                    osc.type = 'triangle';
                    osc.frequency.value = mtof(this.rootNoteBase - 24) * mult;
                    const gain = this.ctx.createGain();
                    gain.gain.value = 0.04; 
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.value = 150; 
                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.reverbNodes.input); 
                    osc.start();
                    this.droneNodes.osc.push({osc, gain, filter, mult});
                });
            }

            setupBass() {
                this.bassNodes.gain = this.ctx.createGain();
                this.bassNodes.gain.gain.value = 1.0; 
                this.bassNodes.filter = this.ctx.createBiquadFilter();
                this.bassNodes.filter.type = 'lowpass';
                this.bassNodes.filter.frequency.value = 200;
                this.bassNodes.gain.connect(this.bassNodes.filter);
                this.bassNodes.filter.connect(this.busses.bass);
            }

            getScaleNotes(root, type) {
                const scale = SCALES[type];
                return scale.map(interval => root + interval);
            }
            
            getKeyName() {
                const noteName = NOTES[this.currentRoot % 12];
                return `${noteName} ${this.currentScaleType}`;
            }

            advanceHarmony() {
                this.progressionIndex++;
                if (this.progressionIndex >= HARMONIC_PROGRESSION.length) {
                    this.progressionIndex = 0;
                    this.cycleCount++; 
                }

                const stage = HARMONIC_PROGRESSION[this.progressionIndex];
                
                this.currentScaleType = stage.scale;
                this.currentRoot = this.rootNoteBase + stage.rootOff;
                this.barsInCurrentStage = 0; 

                while(this.currentRoot > 65) this.currentRoot -= 12;
                while(this.currentRoot < 45) this.currentRoot += 12;

                this.droneNodes.osc.forEach(node => {
                    const targetFreq = mtof(this.currentRoot - 24) * node.mult;
                    node.osc.frequency.setTargetAtTime(targetFreq, this.ctx.currentTime, 4.0);
                    const cutoff = 100 + (this.timeOfDay * 200);
                    node.filter.frequency.setTargetAtTime(cutoff, this.ctx.currentTime, 2.0);
                });

                document.getElementById('chord-display').innerText = `Key: ${this.getKeyName()} | Stage: ${this.progressionIndex + 1}/${HARMONIC_PROGRESSION.length} | Cycle: ${this.cycleCount}`;
            }

            getNotesForType(type) {
                const s = this.getScaleNotes(this.currentRoot, this.currentScaleType);
                if (type === 'IDLE') return [s[0], s[4]]; 
                if (type === 'RISE') return [s[0], s[4], s[0]+12, s[2]+12];
                if (type === 'FALL') return [s[0], s[2], s[4], s[0]-12]; 
                if (type === 'ROLL_L') return [s[3]-12, s[3], s[5], s[0]+12]; 
                if (type === 'ROLL_R') return [s[4]-12, s[4], s[6], s[1]+12]; 
                if (type === 'YAW_L') return [s[1]-12, s[1], s[3], s[5]];
                if (type === 'YAW_R') return [s[5]-12, s[5], s[0]+12, s[2]+12]; 
                if (type === 'THROTTLE_UP') return [s[0]-12, s[0], s[2], s[4], s[6], s[1]+12];
                if (type === 'THROTTLE_DOWN') return [s[0]-24, s[0]-12, s[4]-12];
                return [];
            }

            getConfigForType(type) {
                if (type.includes('YAW')) return { pan: type.includes('L') ? -0.4 : 0.4, glide: type.includes('L') ? -1 : 1, vol: 0.35 };
                if (type.includes('ROLL')) return { pan: type.includes('L') ? -0.7 : 0.7, glide: 0, vol: 0.4 };
                if (type.includes('THROTTLE')) return { pan: 0, glide: 0, vol: 0.5 };
                if (type === 'RISE') return { pan: 0, glide: 0, vol: 0.45 };
                if (type === 'FALL') return { pan: 0, glide: 0, vol: 0.45 };
                return { pan: 0, glide: 0, vol: 0.35 };
            }

            startPad(notes, config, time) {
                const oscs = [];
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0, time);
                gain.gain.linearRampToValueAtTime(config.vol * this.synthVolumeMult, time + 1.0); 

                const panner = this.ctx.createStereoPanner();
                panner.pan.value = config.pan;

                gain.connect(panner);
                panner.connect(this.busses.synth);
                panner.connect(this.reverbNodes.input);

                notes.forEach((midi, i) => {
                    const osc = this.ctx.createOscillator();
                    osc.type = 'sawtooth'; 
                    
                    const freq = mtof(midi);
                    if (config.glide !== 0) {
                        osc.frequency.setValueAtTime(mtof(midi - config.glide), time);
                        osc.frequency.exponentialRampToValueAtTime(freq, time + 0.5);
                    } else {
                        osc.frequency.value = freq;
                    }

                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'lowpass';
                    const dayBright = 200 + (this.timeOfDay * 400);
                    filter.frequency.value = dayBright + (this.speedFactor * 800); 
                    
                    osc.detune.value = (i % 2 === 0 ? 6 : -6);

                    osc.connect(filter);
                    filter.connect(gain);
                    osc.start(time);
                    oscs.push(osc);
                });

                return { oscs, gain };
            }

            transitionPad(newType, time) {
                if (this.currentPadType === newType) return;
                
                if (newType !== 'IDLE' && this.currentPadType !== newType && this.speedFactor > 0.1) {
                    this.triggerInputArp(newType, time);
                }

                if (this.activePad) {
                    const pad = this.activePad;
                    const gainParam = pad.gain.gain;
                    try {
                        gainParam.cancelScheduledValues(time);
                        gainParam.setTargetAtTime(0, time, 0.4); 
                    } catch(e) {}
                    pad.oscs.forEach(o => {
                         try { o.stop(time + 2.0); } catch(e){}
                    });
                }

                this.currentPadType = newType;
                
                if (newType !== 'IDLE') {
                    const notes = this.getNotesForType(newType);
                    const config = this.getConfigForType(newType);
                    this.activePad = this.startPad(notes, config, time);
                    try {
                        const g = this.activePad.gain.gain;
                        g.setTargetAtTime(config.vol * this.synthVolumeMult * 0.6, time + 1.5, 1.0);
                    } catch(e) {}
                } else {
                    this.activePad = null;
                }
            }

            triggerInputArp(type, time) {
                const notes = this.getNotesForType(type).slice(0, 4); 
                let speed = 0.06;

                
                const shuffleType = Math.floor(time) % 2; 
                if (shuffleType === 1) notes.reverse();
                
                notes.forEach((midi, i) => {
                    const osc = this.ctx.createOscillator();
                    osc.type = this.altitudeFactor > 0.6 ? 'sine' : 'triangle';
                    osc.frequency.value = mtof(midi + 24); 
                    
                    const gain = this.ctx.createGain();
                    gain.gain.setValueAtTime(0, time + i * speed);
                    gain.gain.linearRampToValueAtTime(0.08, time + i * speed + 0.01);
                    gain.gain.exponentialRampToValueAtTime(0.001, time + i * speed + 0.3);
                    
                    const pan = this.ctx.createStereoPanner();
                    pan.pan.value = (Math.sin(time) * 0.5);

                    osc.connect(gain);
                    gain.connect(pan);
                    pan.connect(this.busses.arp);
                    pan.connect(this.reverbNodes.input);
                    
                    osc.start(time + i * speed);
                    osc.stop(time + i * speed + 0.4);
                });
            }

            playBassPulse(midi, time, duration) {
                const osc = this.ctx.createOscillator();
                if (this.altitudeFactor > 0.7) osc.type = 'sawtooth';
                else if (this.altitudeFactor > 0.4) osc.type = 'square';
                else osc.type = 'triangle';

                osc.frequency.value = mtof(midi - 24); 
                
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                
                const variation = Math.floor(this.cycleCount / 2) % 2;
                const baseCutoff = (variation === 0 ? 80 : 60) + (this.speedFactor * 400); 
                
                filter.frequency.setValueAtTime(baseCutoff, time);
                filter.frequency.exponentialRampToValueAtTime(baseCutoff * 0.5, time + duration * 0.5);

                const gain = this.ctx.createGain();
                const vol = 0.5 + (this.speedFactor * 0.5); 
                
                gain.gain.setValueAtTime(0, time);
                gain.gain.linearRampToValueAtTime(vol, time + 0.02);
                gain.gain.exponentialRampToValueAtTime(0.001, time + duration);

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.bassNodes.gain);
                osc.start(time);
                osc.stop(time + duration + 0.1);
            }
            
            playHighArp(midi, time, duration) {
                const osc = this.ctx.createOscillator();
                osc.type = 'sine';
                osc.frequency.value = mtof(midi + 24); 
                
                const gain = this.ctx.createGain();
                const arpVol = 0.08 * this.synthVolumeMult * (0.5 + 0.5 * this.timeOfDay);
                
                gain.gain.setValueAtTime(0, time);
                gain.gain.linearRampToValueAtTime(arpVol, time + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.001, time + duration);
                
                const panner = this.ctx.createStereoPanner();
                panner.pan.value = Math.sin(time * 2) * 0.5; 
                
                osc.connect(gain);
                gain.connect(panner);
                panner.connect(this.busses.arp);
                panner.connect(this.reverbNodes.input); 
                
                osc.start(time);
                osc.stop(time + duration + 0.1);
            }

            playSpacePluck(time) {
                const scale = this.getScaleNotes(this.currentRoot, this.currentScaleType);
                const noteIndex = Math.floor(time) % 4;
                const midi = scale[noteIndex * 2 % 7] + 36; 
                
                const osc = this.ctx.createOscillator();
                osc.type = 'sine';
                osc.frequency.value = mtof(midi);
                
                const gain = this.ctx.createGain();
                const vol = 0.05 * this.altitudeFactor * this.synthVolumeMult;
                
                gain.gain.setValueAtTime(0, time);
                gain.gain.linearRampToValueAtTime(vol, time + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.001, time + 0.3); 
                
                const pan = this.ctx.createStereoPanner();
                pan.pan.value = Math.cos(time);

                osc.connect(gain);
                gain.connect(pan);
                pan.connect(this.busses.atmos);
                
                osc.start(time);
                osc.stop(time + 0.4);
            }

            playEarthyDrone(time) {
                const scale = this.getScaleNotes(this.currentRoot, this.currentScaleType);
                const noteIndex = (Math.floor(this.barCount) % 2 === 0) ? 0 : 4; 
                const note = scale[noteIndex] - 12;
                
                const osc = this.ctx.createOscillator();
                osc.type = 'triangle';
                osc.frequency.value = mtof(note);

                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 400;

                const gain = this.ctx.createGain();
                const vol = 0.15 * (1.0 - this.altitudeFactor) * this.synthVolumeMult;
                
                gain.gain.setValueAtTime(0, time);
                gain.gain.linearRampToValueAtTime(vol, time + 0.5); 
                gain.gain.exponentialRampToValueAtTime(0.001, time + 3.0); 

                const panner = this.ctx.createStereoPanner();
                panner.pan.value = 0; 

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(panner);
                panner.connect(this.busses.atmos);
                panner.connect(this.reverbNodes.input);

                osc.start(time);
                osc.stop(time + 3.2);
            }

            scheduler() {
                while (this.nextNoteTime < this.ctx.currentTime + this.scheduleAheadTime) {
                    this.scheduleNote(this.current16thNote, this.nextNoteTime);
                    this.nextNote();
                }
                setTimeout(() => this.scheduler(), 25);
            }

            nextNote() {
                const secondsPerBeat = 60.0 / this.tempo;
                this.nextNoteTime += 0.25 * secondsPerBeat; 
                this.current16thNote++;
                if (this.current16thNote === 16) {
                    this.current16thNote = 0;
                    this.barCount++;
                    this.barsInCurrentStage++; 

                    const currentStage = HARMONIC_PROGRESSION[this.progressionIndex];
                    if (this.barsInCurrentStage >= currentStage.bars) {
                        this.advanceHarmony();
                    }
                }
            }

            shouldPlayAtmosphere(beatNumber) {
                const offset = this.cycleCount % 4;
                return (beatNumber % 16) === (offset * 4);
            }

            scheduleNote(beatNumber, time) {
                if (this.speedFactor < 0.05) return;

                const scale = this.getScaleNotes(this.currentRoot, this.currentScaleType);
                const step = 60.0 / this.tempo;
                
                let playBass = false;
                let bassDur = step * 2;
                let note = scale[0];
                
                if (this.currentPadType.includes('ROLL')) note = scale[3];
                else if (this.currentPadType === 'FALL') note = scale[5];

                if (this.speedFactor < 0.5) {
                    if (beatNumber % 8 === 0) playBass = true;
                } else {
                    if (beatNumber % 2 === 0) {
                        playBass = true;
                        bassDur = step / 2;
                        if (this.speedFactor > 0.8 && beatNumber % 4 !== 0) note += 12;
                    }
                }

                if (playBass) this.playBassPulse(note, time, bassDur);

                const arpVariation = this.cycleCount % 3; 
                
                if (beatNumber % 4 === 0) {
                    let arpIndex = 0;
                    if (arpVariation === 0) arpIndex = (beatNumber / 4) % 4; 
                    else if (arpVariation === 1) arpIndex = 3 - ((beatNumber / 4) % 4); 
                    else arpIndex = [0, 2, 1, 3][(beatNumber/4)%4]; 

                    const offsets = [0, 4, 2, 1]; 
                    const arpNote = scale[offsets[arpIndex]];
                    this.playHighArp(arpNote, time, step);
                }

                if (this.shouldPlayAtmosphere(beatNumber)) {
                    if (this.altitudeFactor > 0.6) {
                        this.playSpacePluck(time); 
                    }
                    if (this.altitudeFactor < 0.4) {
                        this.playEarthyDrone(time);
                    }
                }
            }

            resume() {
                if (this.ctx && this.ctx.state === 'suspended') {
                    this.ctx.resume().then(() => this.updateStatus(true));
                } else if (!this.initialized) {
                    this.init();
                }
            }

            update(keys, speed, altitude, density, sunElevation) {
                if (!this.initialized) return;

                const now = this.ctx.currentTime;
                this.speedFactor = THREE.MathUtils.clamp(speed / 4000.0, 0.0, 1.0); 
                this.cloudDensity = density; 
                this.timeOfDay = Math.max(0, Math.sin(THREE.MathUtils.degToRad(sunElevation))); 
                this.altitudeFactor = THREE.MathUtils.clamp(altitude / 20000, 0.0, 1.0); 

                this.updateVolumes();

                const cloudMuffle = 20000 - (this.cloudDensity * 19000); 
                const nightMuffle = 2000 + (this.timeOfDay * 18000); 
                const targetCutoff = Math.min(cloudMuffle, nightMuffle);
                this.masterFilter.frequency.setTargetAtTime(Math.max(200, targetCutoff), now, 0.2);

                const targetReverb = GLOBAL_CONFIG.volReverb + (this.altitudeFactor * 0.4);
                this.reverbNodes.input.gain.setTargetAtTime(targetReverb, now, 0.5);

                this.tempo = 60 + (this.speedFactor * 80); 
                
                this.synthVolumeMult = 1.0 + (this.speedFactor * 0.5);

                const windFreq = (100 + this.speedFactor * 2000);
                this.windNodes.filter.frequency.setTargetAtTime(windFreq, now, 0.1);
                this.windNodes.gain.gain.setTargetAtTime(this.speedFactor * 0.8 * GLOBAL_CONFIG.volWind, now, 0.1);

                const cabinRumbleFreq = 100 + (this.speedFactor * 50);
                this.cabinNodes.filter.frequency.setTargetAtTime(cabinRumbleFreq, now, 0.1);
                this.cabinNodes.gain.gain.setTargetAtTime(GLOBAL_CONFIG.volCabin * (0.5 + 0.5*this.speedFactor), now, 0.1);

                let type = 'IDLE';
                if (keys.yawLeft) type = 'YAW_L';
                else if (keys.yawRight) type = 'YAW_R';
                else if (keys.throttleUp) type = 'THROTTLE_UP';
                else if (keys.throttleDown) type = 'THROTTLE_DOWN';
                else if (keys.pitchUp) type = 'RISE';
                else if (keys.pitchDown) type = 'FALL';
                else if (keys.rollLeft) type = 'ROLL_L';
                else if (keys.rollRight) type = 'ROLL_R';
                
                if (this.speedFactor < 0.05) type = 'IDLE';

                this.transitionPad(type, now);
            }
        }

        const VERTEX_SHADER = `
            precision highp float;
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = vec4(position, 1.0);
            }
        `;

        const CLOUD_FRAGMENT = `
            precision highp float;
            precision highp sampler3D;

            varying vec2 vUv;

            uniform vec3 uCameraPos;
            uniform float uCameraY; 
            uniform mat4 uInverseView;
            uniform mat4 uInverseProj;
            uniform float uTime;
            uniform vec3 uSunDir;
            uniform vec3 uSunColor;
            uniform float uSunIntensity;
            uniform vec3 uWorldOffset;

            uniform vec3 uSkyColorZenith;
            uniform vec3 uSkyColorHorizon;
            uniform vec3 uSkySunsetZenith;
            uniform vec3 uSkySunsetHorizon;
            uniform vec3 uGroundColor;
            
            
            uniform float uCloudAbsorption;
            uniform float uSilverLining;
            uniform float uSilverSpread;
            uniform float uAmbientIntensity;
            uniform float uPowder;
            uniform float uMultiScatter;
            uniform float uRimBoost;
            uniform float uAOIntensity;
            uniform float uLFScale;

            
            uniform float uShadowStrength;
            uniform float uShadowSoftness;
            uniform float uScatteringStrength;
            uniform float uAOStrength;
            // Global dark-edge controls (intensity and falloff)
            uniform float uDarkEdgeIntensity;
            uniform float uDarkEdgeFalloff;
            // Additional scattering control to boost internal scattering behavior
            uniform float uScatteringBoost;
            uniform vec3 uShadowTint;
            uniform float uSunDisk;
            uniform float uSkySaturation;

            uniform float uSteps;
            uniform int uLightSteps;
            uniform bool uDithering;
            uniform float uLodDistance;
            uniform float uMaxDist;
            
            uniform float uRayleigh;
            uniform float uMieCoeff;
            uniform float uMieG;
            uniform float uFogDensity;

            uniform sampler3D uNoiseTexture;

            
            #define MAX_LAYERS 4
            uniform int uLayerCount;
            uniform float uLayerBottom[MAX_LAYERS];
            uniform float uLayerTop[MAX_LAYERS];
            uniform float uLayerDensity[MAX_LAYERS];
            uniform float uLayerCover[MAX_LAYERS];
            uniform vec3 uLayerColorTop[MAX_LAYERS];
            uniform vec3 uLayerColorBottom[MAX_LAYERS];
            
            
            uniform float uLayerScaleMacro[MAX_LAYERS];
            uniform float uLayerScaleMicro[MAX_LAYERS];
            
            
            uniform float uLayerMacroOctaves[MAX_LAYERS];
            uniform float uLayerMicroOctaves[MAX_LAYERS];
            uniform float uLayerTurbulence[MAX_LAYERS];
            uniform float uLayerDetailMix[MAX_LAYERS];
            uniform float uLayerCoverageExp[MAX_LAYERS];
            uniform float uLayerAbsorption[MAX_LAYERS];
            uniform float uLayerSilver[MAX_LAYERS];
            uniform float uLayerDarkEdge[MAX_LAYERS];
            uniform float uLayerScattering[MAX_LAYERS];
            uniform float uLayerMicroContrast[MAX_LAYERS];
            
            uniform float uLayerMacroDensity[MAX_LAYERS];
            uniform float uLayerMacroFalloff[MAX_LAYERS];
            uniform float uLayerMacroCoreBias[MAX_LAYERS];
            uniform float uLayerMacroEdgeSoftness[MAX_LAYERS];

            uniform float uLayerWindSpeed[MAX_LAYERS];
            uniform vec2 uLayerWindDir[MAX_LAYERS];
            uniform float uLayerErosion[MAX_LAYERS];
            uniform float uLayerType[MAX_LAYERS];

            float getIGNoise(vec2 uv) {
                vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);
                return fract(magic.z * fract(dot(uv, magic.xy)));
            }

            float hg(float a, float g) {
                float g2 = g*g;
                return (1.0 - g2) / (4.0 * 3.14159 * pow(1.0 + g2 - 2.0 * g * a, 1.5));
            }

            float phase(float a) {
                float forward = hg(a, 0.8 * uSilverSpread);
                float backward = hg(a, -0.3);
                return mix(forward, backward, 1.0 - uSilverLining);
            }

            const int MAX_OCTAVES = 6;
            float sampleNoise(vec3 p, float scale, vec2 windDir, float windSpeed, int octaves, float dist, float turbulence) {
                
                vec3 base = p * 0.0001;
                
                vec3 windWorld = vec3(windDir.x, 0.0, windDir.y) * uTime * windSpeed * 0.05;
                vec3 uv = (base + windWorld) * scale;

                if (turbulence > 0.001) {
                    
                    vec3 turbBase = vec3(
                        sin(base.y * 12.9898 + uTime) * 0.02,
                        cos(base.z * 78.233 + uTime) * 0.02,
                        sin(base.x * 37.719 + uTime) * 0.02
                    ) * turbulence;
                    
                    uv += turbBase * scale;
                }

                float lod = smoothstep(0.0, uLodDistance, dist);
                float total = 0.0;
                float norm = 0.0;
                float freq = 1.0;
                float amp = 0.5;

                for (int i = 0; i < MAX_OCTAVES; i++) {
                    if (i >= octaves) break;
                    if (lod > 0.9 && i >= 3) break;
                    float n = texture(uNoiseTexture, uv * freq + float(i) * 0.123).r;
                    float w = amp * (1.0 - lod * float(i) / float(MAX_OCTAVES));
                    total += n * w;
                    norm += w;
                    freq *= 2.0;
                    amp *= 0.5;
                }
                if (norm > 0.0) return total / norm;
                return texture(uNoiseTexture, uv).r;
            }

            
            float getDensityAndColor(vec3 pAbsolute, float dist, out vec3 outColor, out float outAbsorption, out float outSilver, out float outDarkEdge, out float outScattering, out float outContrast, out vec3 outLFNormal) {
                float totalDensity = 0.0;
                vec3 colorAccum = vec3(0.0);
                float weightAccum = 0.0;
                float absAccum = 0.0;
                float silverAccum = 0.0;
                float darkAccum = 0.0;
                float scatAccum = 0.0;
                
                vec3 lfGradAccum = vec3(0.0);
                float lfWeight = 0.0;
                
                for(int i = 0; i < MAX_LAYERS; i++) {
                    if (i >= uLayerCount) break;
                    
                    float bottom = uLayerBottom[i];
                    float top = uLayerTop[i];
                    
                    
                    if(pAbsolute.y < bottom || pAbsolute.y > top) continue;

                    float thickness = top - bottom;
                    float h = (pAbsolute.y - bottom) / thickness;
                    
                    
                    float type = uLayerType[i]; 
                    float biasedH = pow(h, 0.5 + (1.0 - type));
                    
                    
                    float fadeBot = smoothstep(0.0, 0.15, h);
                    float fadeTop = smoothstep(1.0, 0.85, h);
                    float layerFade = fadeBot * fadeTop;
                    
                    layerFade *= mix(1.0, biasedH, 0.8 + 0.2 * type);
                    
                    if (layerFade < 0.001) continue; 
                    
                    
                    
                    
                    float macro = sampleNoise(pAbsolute, uLayerScaleMacro[i], uLayerWindDir[i], uLayerWindSpeed[i], int(uLayerMacroOctaves[i]), dist, uLayerTurbulence[i]);
                    

                    float cov = uLayerCover[i];
                    
                    float edge = uLayerMacroEdgeSoftness[i] * (1.0 + type * 0.8);
                    float structureMask = smoothstep(1.0 - cov, 1.0 - cov + edge, macro);
                    structureMask = pow(structureMask, uLayerCoverageExp[i]);
                    
                    
                    float sm = pow(structureMask, uLayerMacroFalloff[i]);
                    float core = pow(sm, uLayerMacroCoreBias[i]);

                    
                    if (sm < 0.02) continue;
                    
                    
                    float micro = sampleNoise(pAbsolute, uLayerScaleMicro[i], uLayerWindDir[i], uLayerWindSpeed[i], int(uLayerMicroOctaves[i]), dist, uLayerTurbulence[i]);
                    
                    
                    float dm = uLayerDetailMix[i]; 

                    
                    float microC = pow(micro, max(0.001, uLayerMicroContrast[i]));
                    float microAtten = (dm < 0.0) ? clamp(1.0 + dm, 0.0, 1.0) : 1.0;

                    
                    float macroCenter = pow(structureMask, 2.0 + 2.5 * type);

                    
                    float detailStrength = mix(0.6, 1.4, clamp(dm, 0.0, 1.0));
                    float microDensity = microC * microAtten * detailStrength * uLayerDensity[i];

                    
                    float extra = max(0.0, dm - 1.0);
                    float seed = smoothstep(0.5 - 0.15 * extra, 0.6 + 0.15 * extra, microC) * extra * (1.0 - structureMask);
                    float microMask = clamp(macroCenter * (0.5 + 0.5 * microC) + seed, 0.0, 1.0);

                    
                    float macroContribution = sm * uLayerMacroDensity[i] * (0.3 + 0.7 * core);

                    
                    float pos = clamp(dm / 2.0, 0.0, 1.0);
                    float combined = mix(macroContribution, microDensity * microMask, pos);

                    
                    float neg = clamp(-dm, 0.0, 1.0);
                    combined *= (1.0 - 0.6 * neg);

                    // (dark-edge accumulation moved to after layerD is computed)

                    
                    float erosion = mix(combined, combined * microC, uLayerErosion[i]);
                    
                    
                    float layerD = erosion * layerFade * uLayerDensity[i];
                    
                    if (layerD > 0.001) {
                        
                        float hf = abs(micro - macro);

                        totalDensity += layerD;
                        vec3 layerCol = mix(uLayerColorBottom[i], uLayerColorTop[i], h);
                        colorAccum += layerCol * layerD;
                        weightAccum += layerD;

                        
                        absAccum += uLayerAbsorption[i] * layerD;
                        silverAccum += uLayerSilver[i] * layerD;
                        
                        // dark accumulation is now shaped and globally scaled
                        float darkTerm = pow(uLayerDarkEdge[i] * hf, 1.0 + uDarkEdgeFalloff);
                        darkAccum += darkTerm * layerD * uDarkEdgeIntensity;

                        scatAccum += uLayerScattering[i] * layerD;

                        
                        float delta = max(12.0, (top - bottom) * 0.05);
                        float sx1 = sampleNoise(pAbsolute + vec3(delta,0,0), uLayerScaleMacro[i], uLayerWindDir[i], uLayerWindSpeed[i], int(uLayerMacroOctaves[i]), dist, uLayerTurbulence[i]);
                        float sx2 = sampleNoise(pAbsolute - vec3(delta,0,0), uLayerScaleMacro[i], uLayerWindDir[i], uLayerWindSpeed[i], int(uLayerMacroOctaves[i]), dist, uLayerTurbulence[i]);
                        float sy1 = sampleNoise(pAbsolute + vec3(0,delta,0), uLayerScaleMacro[i], uLayerWindDir[i], uLayerWindSpeed[i], int(uLayerMacroOctaves[i]), dist, uLayerTurbulence[i]);
                        float sy2 = sampleNoise(pAbsolute - vec3(0,delta,0), uLayerScaleMacro[i], uLayerWindDir[i], uLayerWindSpeed[i], int(uLayerMacroOctaves[i]), dist, uLayerTurbulence[i]);
                        float sz1 = sampleNoise(pAbsolute + vec3(0,0,delta), uLayerScaleMacro[i], uLayerWindDir[i], uLayerWindSpeed[i], int(uLayerMacroOctaves[i]), dist, uLayerTurbulence[i]);
                        float sz2 = sampleNoise(pAbsolute - vec3(0,0,delta), uLayerScaleMacro[i], uLayerWindDir[i], uLayerWindSpeed[i], int(uLayerMacroOctaves[i]), dist, uLayerTurbulence[i]);
                        vec3 grad = vec3(sx1 - sx2, sy1 - sy2, sz1 - sz2) / max(1.0, delta * 2.0);
                        lfGradAccum += grad * layerD;
                        lfWeight += layerD;
                    }
                }
                
                if (weightAccum > 0.0) {
                    outColor = colorAccum / weightAccum;
                    outAbsorption = absAccum / weightAccum;
                    outSilver = silverAccum / weightAccum;
                    outDarkEdge = darkAccum / weightAccum;
                    outScattering = scatAccum / weightAccum;
                    outContrast = darkAccum / weightAccum; 
                    if (lfWeight > 0.0) {
                        outLFNormal = normalize(lfGradAccum / lfWeight);
                    } else {
                        outLFNormal = vec3(0.0, 1.0, 0.0);
                    }
                } else {
                    outColor = vec3(1.0);
                    outAbsorption = 0.0;
                    outSilver = 0.0;
                    outDarkEdge = 0.0;
                    outScattering = 0.0;
                    outContrast = 0.0;
                    outLFNormal = vec3(0.0, 1.0, 0.0);
                }
                
                float distFade = 1.0 - smoothstep(uMaxDist * 0.8, uMaxDist, dist);
                return totalDensity * distFade;
            }

            float getLight(vec3 pAbsolute, vec3 sunDir, float ph, float jitter) {
                float step = 25.0;
                float dist = 0.0;
                float accAbsLen = 0.0;
                float accSilver = 0.0;
                float accScat = 0.0;
                float accInScat = 0.0;
                vec3 pos = pAbsolute + sunDir * step * jitter;
                vec3 dummyCol;

                for(int i = 0; i < 16; i++) {
                    if (i >= uLightSteps) break;

                    float sampleAbs, sampleSilver, sampleDark, sampleScat, sampleContrast;
                    vec3 dummyLF;
                    float d = getDensityAndColor(pos, 0.0, dummyCol, sampleAbs, sampleSilver, sampleDark, sampleScat, sampleContrast, dummyLF);
                    dist += d * step;
                    accAbsLen += sampleAbs * d * step;
                    accSilver += sampleSilver * d * step;
                    accScat += sampleScat * d * step;
                    accInScat += sampleScat * d * step * (0.2126 * dummyCol.r + 0.7152 * dummyCol.g + 0.0722 * dummyCol.b);

                    if (dist > 4.0) break;
                    step *= 1.4;
                    pos += sunDir * step;
                }

                float tau = accAbsLen + dist * uCloudAbsorption;
                float T = exp(-tau);

                float inScat = (dist > 0.0) ? (accInScat / (dist)) : 0.0;
                // allow global boost control over internal scattering
                inScat *= uScatteringStrength * uScatteringBoost;

                float powder = 1.0 - exp(-dist * uCloudAbsorption * 2.0);
                float avgSilver = (dist > 0.0) ? accSilver / (dist) : 0.0;
                
                float silverInfluence = clamp(uSilverLining * 1.5 * avgSilver + uPowder * 0.25, 0.0, 1.0);
                float finalPowder = mix(1.0, powder, silverInfluence);

                
                float lighting = T * (0.18 + 0.62 * finalPowder) + inScat * (1.0 - T) * 1.2;
                return lighting * ph;
            }

            vec3 computeSky(vec3 rd, vec3 sunDir) {
                float sunY = sunDir.y;
                float mu = dot(rd, sunDir);
                float sunsetT = smoothstep(0.2, -0.1, sunY);
                vec3 zenColor = mix(uSkyColorZenith, uSkySunsetZenith, sunsetT);
                vec3 horColor = mix(uSkyColorHorizon, uSkySunsetHorizon, sunsetT);
                if (sunY < -0.1) {
                    float nightT = smoothstep(-0.1, -0.4, sunY);
                    vec3 nightColor = vec3(0.02, 0.02, 0.05);
                    zenColor = mix(zenColor, nightColor, nightT);
                    horColor = mix(horColor, nightColor, nightT);
                }
                float gradient = pow(min(1.0, abs(rd.y) + 0.1), 0.5); 
                vec3 sky = mix(horColor, zenColor, gradient);
                float sunScat = 1.0 / (4.0 * 3.14159) * ((1.0 - uMieG*uMieG) / pow(1.0 + uMieG*uMieG - 2.0*uMieG*mu, 1.5));
                float hazeMix = smoothstep(-0.1, 0.1, sunY); 
                vec3 sunHaloColor = mix(vec3(1.0, 0.5, 0.2), uSunColor, hazeMix);
                sky += sunHaloColor * sunScat * uMieCoeff * 10.0;
                float sunDisk = smoothstep(0.9995, 0.9999, mu);
                sky += sunDisk * uSunColor * uSunDisk * uSunIntensity;
                
                float skyGray = dot(sky, vec3(0.3333));
                sky = mix(vec3(skyGray), sky, uSkySaturation); 
                if (rd.y < 0.0) {
                     float groundFog = 1.0 - exp(-20000.0 * uFogDensity); 
                     sky = mix(uGroundColor, sky, groundFog * 0.5); 
                     sky = mix(sky, horColor, smoothstep(-0.2, 0.0, rd.y));
                }
                return sky;
            }

            void main() {
                vec4 ndc = vec4(vUv * 2.0 - 1.0, -1.0, 1.0);
                vec4 view = uInverseProj * ndc;
                view /= view.w;
                vec3 world = (uInverseView * view).xyz;
                vec3 ro = uCameraPos; 
                vec3 rd = normalize(world - ro);
                vec3 col = computeSky(rd, uSunDir);

                float rdy = rd.y;
                if (abs(rdy) < 1e-5) rdy = sign(rdy) * 1e-5;

                
                float globalMinBot = 1000000.0;
                float globalMaxTop = -1000000.0;
                
                for(int i=0; i<MAX_LAYERS; i++) {
                    if(i >= uLayerCount) break;
                    if(uLayerBottom[i] < globalMinBot) globalMinBot = uLayerBottom[i];
                    if(uLayerTop[i] > globalMaxTop) globalMaxTop = uLayerTop[i];
                }
                
                if (uLayerCount == 0) {
                     
                     gl_FragColor = vec4(col, 0.0);
                     return;
                }

                float absCamY = ro.y + uCameraY;
                float tBot = (globalMinBot - absCamY) / rdy;
                float tTop = (globalMaxTop - absCamY) / rdy;
                
                float tNear = min(tBot, tTop);
                float tFar = max(tBot, tTop);

                tNear = max(0.0, tNear);
                tFar = min(tFar, uMaxDist);

                float marchDist = tFar - tNear;
                
                if (marchDist > 0.0) {
                    float baseStep = 200.0; 
                    
                    float dither = 0.0;
                    if (uDithering) dither = getIGNoise(gl_FragCoord.xy);
                    
                    float t = tNear + dither * baseStep;
                    float sunDot = dot(rd, uSunDir);
                    float ph = phase(sunDot);
                    vec4 sum = vec4(0.0);

                    for(int i = 0; i < 512; i++) {
                        if (sum.a >= 0.99) break;
                        if (t > tFar) break;
                        if (float(i) > uSteps) break; 

                        vec3 currP = ro + rd * t;
                        vec3 absP = currP + vec3(uWorldOffset.x, uCameraY, uWorldOffset.z);
                        
                        float currentStep = baseStep * (1.0 + t * 0.0001);
                        
                        
                        if (absP.y >= globalMinBot - 100.0 && absP.y <= globalMaxTop + 100.0) {
                            vec3 cloudColor;
                            float sampleAbs, sampleSilver, sampleDark, sampleScat, sampleContrast;
                            vec3 sampleLF;
                            float d = getDensityAndColor(absP, t, cloudColor, sampleAbs, sampleSilver, sampleDark, sampleScat, sampleContrast, sampleLF);

                            if (d > 0.001) {
                                float lit = getLight(absP, uSunDir, ph, dither);

                                
                                float scatterBoost = clamp(sampleScat, 0.0, 1.0) * uScatteringStrength;
                                float scatterFactor = 1.0 - scatterBoost * 0.6;

                                vec3 ambient = mix(cloudColor, uSunColor * 0.1, 0.2) * uAmbientIntensity;
                                vec3 radiance = uSunColor * lit * 2.5 * scatterFactor + ambient;

                                
                                vec3 n = normalize(sampleLF + vec3(1e-6));

                                
                                float rimN = pow(max(0.0, dot(n, uSunDir)), 1.6);
                                float limb = pow(clamp(1.0 - abs(sunDot), 0.0, 1.0), 0.75);
                                float silverHalo = pow(clamp(sampleSilver * (0.6 + uSilverLining * 0.8), 0.0, 1.0), 0.6) * rimN * limb * uRimBoost;
                                radiance += uSunColor * silverHalo * 6.0 * uSunIntensity;

                                
                                float dirScatter = sampleScat * (0.2 + 0.8 * max(0.0, dot(rd, uSunDir)));
                                radiance += uSunColor * dirScatter * 0.6;

                                
                                float edgeMask = clamp(sampleDark * uDarkEdgeIntensity + sampleContrast * 0.7, 0.0, 1.0);
                                float edgeDark = clamp(edgeMask, 0.0, 1.0);
                                // darken color more aggressively at edges, compute additional absorption and reduce local radiance
                                cloudColor *= (1.0 - edgeDark * (0.65 + 0.45 * uDarkEdgeIntensity));
                                float edgeLocalAbs = edgeMask * 0.6 * uDarkEdgeIntensity;
                                radiance *= (1.0 - edgeMask * 0.4 * uDarkEdgeIntensity);

                                
                                float aoSample = 0.0;
                                aoSample += texture(uNoiseTexture, absP * uLFScale).r;
                                aoSample += texture(uNoiseTexture, (absP + vec3(120.0,0.0,0.0)) * uLFScale).r;
                                aoSample += texture(uNoiseTexture, (absP + vec3(0.0,120.0,0.0)) * uLFScale).r;
                                aoSample += texture(uNoiseTexture, (absP + vec3(0.0,0.0,120.0)) * uLFScale).r;
                                aoSample *= 0.25;
                                float ao = clamp(pow(1.0 - aoSample, max(0.0001, uAOIntensity)), 0.0, 1.0);

                                
                                vec3 lfN = normalize(sampleLF + vec3(1e-6));
                                float nDotSun = clamp(dot(lfN, uSunDir), 0.0, 1.0);

                                
                                float occl = ao * (1.0 - nDotSun) * uAOStrength;
                                float underside = clamp(1.0 - rd.y, 0.0, 1.0);
                                float aoDark = 0.7 * occl * (0.6 + 0.4 * underside);
                                cloudColor *= 1.0 - aoDark;

                                
                                radiance *= 1.0 - 0.5 * occl;

                                
                                float localAbs = uCloudAbsorption + sampleAbs + edgeMask * 0.8 * edgeDark + edgeLocalAbs;
                                float alpha = 1.0 - exp(-d * currentStep * localAbs);

                                
                                radiance += uSunColor * silverHalo * 0.5;

                                sum.rgb += radiance * alpha * (1.0 - sum.a);
                                sum.a += alpha * (1.0 - sum.a);
                            }
                        }
                        t += currentStep;
                    }
                    
                    float ms = 1.0 - exp(-uMultiScatter * sum.a * 2.0);
                    sum.rgb *= (1.0 + ms * 0.6);

                    
                    float shadowMask = clamp(sum.a * uShadowStrength, 0.0, 1.0);
                    
                    float shadowSoft = pow(shadowMask, max(0.01, 1.0 - uShadowSoftness));
                    vec3 tint = uShadowTint;
                    vec3 shadowBlend = mix(vec3(1.0), tint, 0.6 * shadowSoft);
                    vec3 shadowedSky = col * shadowBlend;

                    float fogAmount = 1.0 - exp(-tNear * uFogDensity);
                    vec3 fogColor = computeSky(rd, uSunDir); 
                    sum.rgb = mix(sum.rgb, fogColor, fogAmount);
                    col = mix(shadowedSky, sum.rgb, sum.a);
                }
                gl_FragColor = vec4(col, 1.0);
            }
        `;

        const DENOISE_FRAGMENT = `
            precision highp float;
            varying vec2 vUv;
            uniform sampler2D tDiffuse;
            uniform vec2 uResolution;
            uniform bool uEnable;
            void main() {
                if (!uEnable) { gl_FragColor = texture2D(tDiffuse, vUv); return; }
                vec2 texel = 1.0 / uResolution;
                vec4 center = texture2D(tDiffuse, vUv);
                vec3 sum = center.rgb * 0.25;
                float alphaSum = center.a * 0.25;
                float total = 0.25;
                vec4 n1 = texture2D(tDiffuse, vUv + vec2(1, 0) * texel);
                vec4 n2 = texture2D(tDiffuse, vUv + vec2(-1, 0) * texel);
                vec4 n3 = texture2D(tDiffuse, vUv + vec2(0, 1) * texel);
                vec4 n4 = texture2D(tDiffuse, vUv + vec2(0, -1) * texel);
                sum += (n1.rgb + n2.rgb + n3.rgb + n4.rgb) * 0.125; alphaSum += (n1.a + n2.a + n3.a + n4.a) * 0.125; total += 0.5;
                vec4 d1 = texture2D(tDiffuse, vUv + vec2(1, 1) * texel);
                vec4 d2 = texture2D(tDiffuse, vUv + vec2(-1, 1) * texel);
                vec4 d3 = texture2D(tDiffuse, vUv + vec2(1, -1) * texel);
                vec4 d4 = texture2D(tDiffuse, vUv + vec2(-1, -1) * texel);
                sum += (d1.rgb + d2.rgb + d3.rgb + d4.rgb) * 0.0625; alphaSum += (d1.a + d2.a + d3.a + d4.a) * 0.0625; total += 0.25;
                gl_FragColor = vec4(sum / total, alphaSum / total);
            }
        `; 

        const GODRAY_FRAGMENT = `
            precision highp float;
            varying vec2 vUv;
            uniform sampler2D tDiffuse;
            uniform vec2 uSunPosScreen;
            uniform float uDensity;
            uniform float uDecay;
            uniform float uWeight;
            uniform float uExposure;
            uniform bool uSunVisible;
            uniform int uSamples;
            float getIGNoise(vec2 uv) {
                vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);
                return fract(magic.z * fract(dot(uv, magic.xy)));
            }
            void main() {
                if (!uSunVisible) { gl_FragColor = vec4(0.0); return; }
                vec2 uv = vUv;
                vec2 delta = (uv - uSunPosScreen) * uDensity / float(uSamples);
                float dither = getIGNoise(gl_FragCoord.xy);
                uv -= delta * dither;
                float decay = 1.0;
                vec3 accum = vec3(0.0);
                for(int i=0; i<200; i++) {
                    if (i >= uSamples) break;
                    uv -= delta;
                    if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) break;
                    vec3 s = texture2D(tDiffuse, uv).rgb;
                    float luma = dot(s, vec3(0.2126, 0.7152, 0.0722));
                    float thresh = smoothstep(0.9, 1.2, luma);
                    s *= thresh;
                    accum += s * uWeight * decay;
                    decay *= uDecay;
                }
                gl_FragColor = vec4(accum * uExposure, 1.0);
            }
        `;

        const COMPOSITE_FRAGMENT = `
            precision highp float;
            varying vec2 vUv;
            uniform sampler2D tColor;
            uniform sampler2D tGodRays;
            uniform sampler2D tTerrain;
            uniform float uRayIntensity;
            uniform float uExposure;
            vec3 aces(vec3 x) { return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0); }
            void main() {
                vec3 terrain = texture2D(tTerrain, vUv).rgb;
                vec4 cloudSample = texture2D(tColor, vUv);
                vec3 cloudColor = cloudSample.rgb;
                float cloudAlpha = cloudSample.a;
                vec3 rays = texture2D(tGodRays, vUv).rgb;
                
                vec3 outColor = mix(terrain, cloudColor, cloudAlpha) + rays * uRayIntensity;
                outColor = aces(outColor * uExposure);
                outColor = pow(outColor, vec3(1.0/2.2));
                gl_FragColor = vec4(outColor, 1.0);
            }
        `;

        class FlightControls {
            constructor(camera) {
                this.camera = camera;
                this.worldPos = new THREE.Vector3(0, 3000, 5000);
                this.currentSpeed = 0.0; 
                this.maxSpeed = 3000.0;
                this.throttle = 0.0;
                this.velocity = new THREE.Vector3();
                this.pitchRate = 1.2;
                this.rollRate = 1.5;
                this.yawRate = 0.5;
                this.throttleRate = 0.5;
                this.pitchStability = 0.5;
                this.rollStability = 2.0;
                this.keys = {
                    pitchUp: false, pitchDown: false, rollLeft: false, rollRight: false,
                    yawLeft: false, yawRight: false, throttleUp: false, throttleDown: false
                };
                this._rotQuat = new THREE.Quaternion();
                this._euler = new THREE.Euler();
                this._forward = new THREE.Vector3();
                this.initEvents();
            }

            initEvents() {
                this.onKeyDown = (e) => this.handleKey(e, true);
                this.onKeyUp = (e) => this.handleKey(e, false);
                document.addEventListener('keydown', this.onKeyDown);
                document.addEventListener('keyup', this.onKeyUp);
                
                const startBtn = document.getElementById('start-screen');
                startBtn.addEventListener('click', () => {
                    startBtn.classList.add('fade-out');
                    if (audioManager) audioManager.resume();
                });
            }

            handleKey(e, isDown) {
                const setKeyActive = (id, active) => {
                    const el = document.getElementById(id);
                    if (el) active ? el.classList.add('active') : el.classList.remove('active');
                };

                const keyMap = {
                    KeyW: ['pitchDown','k-w'], KeyS: ['pitchUp','k-s'], KeyA: ['rollLeft','k-a'], KeyD: ['rollRight','k-d'],
                    ArrowLeft: ['yawLeft','k-l'], ArrowRight: ['yawRight','k-r'], ArrowUp: ['throttleUp','k-u'], ArrowDown: ['throttleDown','k-dn']
                };

                if (keyMap[e.code]) {
                    const [prop, id] = keyMap[e.code];
                    this.keys[prop] = isDown;
                    setKeyActive(id, isDown);
                    return;
                }

                if (e.code === 'KeyH' && isDown) {
                    const ui = document.querySelector('.lil-gui');
                    const over = document.getElementById('overlay');
                    if (ui) ui.style.display = ui.style.display === 'none' ? 'block' : 'none';
                    if (over) over.classList.toggle('hidden');
                }
            }

            update(dt) {
                const inputPitch = (this.keys.pitchDown ? 1 : 0) + (this.keys.pitchUp ? -1 : 0);
                const inputRoll = (this.keys.rollRight ? -1 : 0) + (this.keys.rollLeft ? 1 : 0);
                const inputYaw = (this.keys.yawRight ? -1 : 0) + (this.keys.yawLeft ? 1 : 0);
                const inputThrottle = (this.keys.throttleUp ? 1 : 0) + (this.keys.throttleDown ? -1 : 0);

                if (inputThrottle !== 0) {
                    this.throttle += inputThrottle * this.throttleRate * dt;
                    this.throttle = THREE.MathUtils.clamp(this.throttle, 0.0, 1.0);
                }

                let targetSpeed = this.throttle * this.maxSpeed;
                this.currentSpeed = THREE.MathUtils.lerp(this.currentSpeed, targetSpeed, dt * 0.5);

                let pitch = inputPitch * this.pitchRate * dt;
                let roll = inputRoll * this.rollRate * dt;
                let yaw = inputYaw * this.yawRate * dt;

                this._rotQuat.setFromEuler(this._euler.set(pitch, yaw, roll, 'YXZ'));
                this.camera.quaternion.multiply(this._rotQuat);

                this._euler.setFromQuaternion(this.camera.quaternion, 'YXZ');
                this._euler.x = Math.max(-1.5, Math.min(1.5, this._euler.x)); 

                if (inputPitch === 0) {
                    let pitchFactor = 1.0 - Math.exp(-this.pitchStability * dt);
                    this._euler.x = THREE.MathUtils.lerp(this._euler.x, 0, pitchFactor);
                }
                if (inputRoll === 0) {
                    let rollFactor = 1.0 - Math.exp(-this.rollStability * dt);
                    this._euler.z = THREE.MathUtils.lerp(this._euler.z, 0, rollFactor);
                }

                this.camera.quaternion.setFromEuler(this._euler);
                this.camera.quaternion.normalize();

                this._forward.set(0, 0, -1).applyQuaternion(this.camera.quaternion);
                let targetVelocity = this._forward.multiplyScalar(this.currentSpeed);
                this.velocity.lerp(targetVelocity, dt * 1.5);

                this.worldPos.addScaledVector(this.velocity, dt);
                
                document.getElementById('val-alt').innerText = Math.round(this.worldPos.y * 3.28);
                document.getElementById('val-spd').innerText = Math.round(this.currentSpeed * 1.94);
                document.getElementById('val-pos').innerText = `${(this.worldPos.z/1000).toFixed(1)}, ${(this.worldPos.x/1000).toFixed(1)}`;
            }
        }

        function createNoiseTexture() {
            const size = 64;
            const data = new Float32Array(size * size * size);
            const p = new Uint8Array(512), perm = new Uint8Array(256);
            for(let i=0; i<256; i++) perm[i] = i;
            for(let i=255; i>0; i--) { const r = Math.floor(Math.random() * (i+1)); [perm[i], perm[r]] = [perm[r], perm[i]]; }
            for(let i=0; i<512; i++) p[i] = perm[i & 255];
            const fade = t => t*t*t*(t*(t*6-15)+10);
            const lerp = (a, b, t) => a+t*(b-a);
            const grad = (hash, x, y, z) => { const h = hash & 15; const u = h<8?x:y; const v = h<4?y:h==12||h==14?x:z; return ((h&1)==0?u:-u)+((h&2)==0?v:-v); };
            const pnoise = (x, y, z, period) => {
                const X = Math.floor(x)%period, Y = Math.floor(y)%period, Z = Math.floor(z)%period;
                const fx = x-Math.floor(x), fy = y-Math.floor(y), fz = z-Math.floor(z);
                const u = fade(fx), v = fade(fy), w = fade(fz);
                const X1 = (X+1)%period, Y1 = (Y+1)%period, Z1 = (Z+1)%period;
                const g000 = grad(p[p[p[X]+Y]+Z], fx, fy, fz), g100 = grad(p[p[p[X1]+Y]+Z], fx-1, fy, fz);
                const g010 = grad(p[p[p[X]+Y1]+Z], fx, fy-1, fz), g110 = grad(p[p[p[X1]+Y1]+Z], fx-1, fy-1, fz);
                const g001 = grad(p[p[p[X]+Y]+Z1], fx, fy, fz-1), g101 = grad(p[p[p[X1]+Y]+Z1], fx-1, fy, fz-1);
                const g011 = grad(p[p[p[X]+Y1]+Z1], fx, fy-1, fz-1), g111 = grad(p[p[p[X1]+Y1]+Z1], fx-1, fy-1, fz-1);
                return lerp(lerp(lerp(g000, g100, u), lerp(g010, g110, u), v), lerp(lerp(g001, g101, u), lerp(g011, g111, u), v), w);
            };
            let idx = 0; const freq = 8.0; 
            for(let z=0; z<size; z++) {
                for(let y=0; y<size; y++) {
                    for(let x=0; x<size; x++) {
                        const nx = x/size, ny = y/size, nz = z/size;
                        let total = 0.0, amplitude = 0.5, f = freq;
                        for(let k=0; k<3; k++) { total += pnoise(nx*f, ny*f, nz*f, Math.floor(f)) * amplitude; amplitude *= 0.5; f *= 2.0; }
                        data[idx++] = total * 0.5 + 0.5; 
                    }
                }
            }

            const tex = new THREE.Data3DTexture(data, size, size, size);
            tex.format = THREE.RedFormat; tex.type = THREE.HalfFloatType;
            tex.minFilter = THREE.LinearFilter; tex.magFilter = THREE.LinearFilter;
            tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping; tex.wrapR = THREE.RepeatWrapping;
            tex.needsUpdate = true;
            return tex;
        }

        
        function hash2(x, y) {
            const v = Math.sin(x * 127.1 + y * 311.7) * 43758.5453123;
            return v - Math.floor(v);
        }
        function noise2D(x, y) {
            const xi = Math.floor(x), yi = Math.floor(y);
            const xf = x - xi, yf = y - yi;
            const a = hash2(xi, yi), b = hash2(xi + 1, yi), c = hash2(xi, yi + 1), d = hash2(xi + 1, yi + 1);
            const u = xf * xf * (3.0 - 2.0 * xf), v = yf * yf * (3.0 - 2.0 * yf);
            const lerp = (s, t, u) => s + u * (t - s);
            return lerp(lerp(a, b, u), lerp(c, d, u), v);
        }
        function fbm(x, y, octaves = 5) {
            let sum = 0.0, amp = 1.0, freq = 1.0;
            for (let i = 0; i < octaves; i++) {
                sum += noise2D(x * freq, y * freq) * amp;
                freq *= 2.0; amp *= 0.5;
            }
            return sum;
        }

        
        function createTerrainMesh() {
            const size = 200000.0;
            const segments = 128;
            const geom = new THREE.PlaneGeometry(size, size, segments, segments);
            geom.rotateX(-Math.PI * 0.5);
            const pos = geom.attributes.position;
            
            for (let i = 0; i < pos.count; i++) {
                pos.setY(i, 0);
            }
            geom.computeVertexNormals();
            const mat = new THREE.MeshStandardMaterial({ color: new THREE.Color(GLOBAL_CONFIG.groundColor), roughness: 1.0, metalness: 0.0 });
            const mesh = new THREE.Mesh(geom, mat);
            mesh.frustumCulled = false;
            return mesh;
        }

        
        function updateTerrain(offsetX, offsetZ) {
            if (!terrainMesh) return;
            const geom = terrainMesh.geometry;
            const pos = geom.attributes.position;
            
            const scale = 1.0 / 8000.0;
            const heightScale = 3000.0;
            
            const worldOffsetX = offsetX;
            const worldOffsetZ = offsetZ;
            for (let i = 0; i < pos.count; i++) {
                const x = pos.getX(i);
                const z = pos.getZ(i);
                const wx = x + worldOffsetX;
                const wz = z + worldOffsetZ;
                const h = (fbm(wx * scale, wz * scale, 6) - 0.5) * heightScale;
                pos.setY(i, h);
            }
            geom.computeVertexNormals();
            pos.needsUpdate = true;
            geom.attributes.normal.needsUpdate = true;
        }

        function getSunLightColor(elevation) {
            const t = Math.max(0, Math.min(1, (elevation + 5) / 25));
            const r = 1.0, g = 0.3 + 0.7 * t, b = 0.1 + 0.9 * t;
            const intensity = Math.max(0.0, Math.sin(THREE.MathUtils.degToRad(Math.max(0, elevation + 5))));
            return new THREE.Color(r, g, b).multiplyScalar(intensity + 0.1);
        }

        async function init() {
            audioManager = new AtmosphereAudio();

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setPixelRatio(1.0); 
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            const rtParams = { type: THREE.HalfFloatType, format: THREE.RGBAFormat, minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter };
            cloudTarget = new THREE.WebGLRenderTarget(1, 1, rtParams);
            denoiseTarget = new THREE.WebGLRenderTarget(1, 1, rtParams);
            rayTarget = new THREE.WebGLRenderTarget(1, 1, rtParams);
            
            terrainTarget = new THREE.WebGLRenderTarget(1, 1, rtParams);

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 200000);
            
            flightControls = new FlightControls(camera);

            await new Promise(r => setTimeout(r, 50));
            const noiseTex = createNoiseTexture();
            document.getElementById('loading').classList.add('hidden');

            cloudMat = new THREE.ShaderMaterial({
                vertexShader: VERTEX_SHADER,
                fragmentShader: CLOUD_FRAGMENT,
                uniforms: {
                    uTime: { value: 0 },
                    uCameraPos: { value: new THREE.Vector3() },
                    uCameraY: { value: flightControls.worldPos.y },
                    uInverseView: { value: new THREE.Matrix4() },
                    uInverseProj: { value: new THREE.Matrix4() },
                    uSunDir: { value: new THREE.Vector3() },
                    uSunColor: { value: new THREE.Color(1.0, 1.0, 1.0) },
                    uSunIntensity: { value: GLOBAL_CONFIG.sunIntensity },
                    uWorldOffset: { value: new THREE.Vector3() },
                    
                    uSkyColorZenith: { value: new THREE.Color(GLOBAL_CONFIG.skyColorZenith) },
                    uSkyColorHorizon: { value: new THREE.Color(GLOBAL_CONFIG.skyColorHorizon) },
                    uSkySunsetZenith: { value: new THREE.Color(GLOBAL_CONFIG.skySunsetZenith) },
                    uSkySunsetHorizon: { value: new THREE.Color(GLOBAL_CONFIG.skySunsetHorizon) },
                    uGroundColor: { value: new THREE.Color(GLOBAL_CONFIG.groundColor) },
                    
                    uCloudAbsorption: { value: GLOBAL_CONFIG.cloudAbsorption },
                    uSilverLining: { value: GLOBAL_CONFIG.silverLining },
                    uSilverSpread: { value: GLOBAL_CONFIG.silverSpread },
                    uAmbientIntensity: { value: GLOBAL_CONFIG.ambientIntensity },
                    uPowder: { value: GLOBAL_CONFIG.powder },
                    
                    uMultiScatter: { value: 0.8 },
                    uRimBoost: { value: 1.0 },
                    uAOIntensity: { value: 0.6 },
                    uLFScale: { value: 0.00005 },

                    
                    uShadowStrength: { value: 0.6 },
                    uShadowSoftness: { value: 0.25 },
                    uScatteringStrength: { value: 0.9 },
                    uScatteringBoost: { value: 1.0 },
                    uAOStrength: { value: 1.0 },
                    uDarkEdgeIntensity: { value: 1.0 },
                    uDarkEdgeFalloff: { value: 0.5 },
                    uShadowTint: { value: new THREE.Color(GLOBAL_CONFIG.shadowTint) },
                    uSunDisk: { value: GLOBAL_CONFIG.sunDiskIntensity },
                    uSkySaturation: { value: GLOBAL_CONFIG.skySaturation },

                    uSteps: { value: GLOBAL_CONFIG.steps },
                    uLightSteps: { value: GLOBAL_CONFIG.lightSteps },
                    uDithering: { value: GLOBAL_CONFIG.dithering },
                    uLodDistance: { value: GLOBAL_CONFIG.lodDistance },
                    uMaxDist: { value: GLOBAL_CONFIG.maxDist },
                    
                    uRayleigh: { value: GLOBAL_CONFIG.rayleigh },
                    uMieCoeff: { value: GLOBAL_CONFIG.mieCoefficient },
                    uMieG: { value: GLOBAL_CONFIG.mieDirectionalG },
                    uFogDensity: { value: GLOBAL_CONFIG.fogDensity },
                    
                    
                    uLayerCount: { value: 0 },
                    uLayerBottom: { value: allocFloat(MAX_LAYERS) },
                    uLayerTop: { value: allocFloat(MAX_LAYERS) },
                    uLayerDensity: { value: allocFloat(MAX_LAYERS) },
                    uLayerCover: { value: allocFloat(MAX_LAYERS) },
                    uLayerColorTop: { value: allocVec3Array(MAX_LAYERS) },
                    uLayerColorBottom: { value: allocVec3Array(MAX_LAYERS) },
                    uLayerScaleMacro: { value: allocFloat(MAX_LAYERS) },
                    uLayerScaleMicro: { value: allocFloat(MAX_LAYERS) },
                    uLayerMacroOctaves: { value: allocFloat(MAX_LAYERS) },
                    uLayerMicroOctaves: { value: allocFloat(MAX_LAYERS) },
                    uLayerTurbulence: { value: allocFloat(MAX_LAYERS) },
                    uLayerDetailMix: { value: allocFloat(MAX_LAYERS) },
                    uLayerCoverageExp: { value: allocFloat(MAX_LAYERS) },
                    uLayerAbsorption: { value: allocFloat(MAX_LAYERS) },
                    uLayerSilver: { value: allocFloat(MAX_LAYERS) },
                    uLayerDarkEdge: { value: allocFloat(MAX_LAYERS) },
                    uLayerScattering: { value: allocFloat(MAX_LAYERS) },
                    uLayerMicroContrast: { value: allocFloat(MAX_LAYERS) },
                    
                    uLayerMacroDensity: { value: allocFloat(MAX_LAYERS) },
                    
                    uLayerMacroFalloff: { value: allocFloat(MAX_LAYERS) },
                    uLayerMacroCoreBias: { value: allocFloat(MAX_LAYERS) },
                    uLayerMacroEdgeSoftness: { value: allocFloat(MAX_LAYERS) },
                    uLayerWindSpeed: { value: allocFloat(MAX_LAYERS) },
                    uLayerWindDir: { value: allocVec2Array(MAX_LAYERS) },
                    uLayerErosion: { value: allocFloat(MAX_LAYERS) },
                    uLayerType: { value: allocFloat(MAX_LAYERS) },

                    uNoiseTexture: { value: noiseTex }
                },
                depthWrite: false, depthTest: false
            });

            denoiseMat = new THREE.ShaderMaterial({
                vertexShader: VERTEX_SHADER,
                fragmentShader: DENOISE_FRAGMENT,
                uniforms: { tDiffuse: { value: null }, uResolution: { value: new THREE.Vector2() }, uEnable: { value: GLOBAL_CONFIG.enableDenoise } },
                depthWrite: false, depthTest: false
            });

            
            function updateLayerUniforms() {
                const activeLayers = LAYERS.filter(l => l.active);
                const count = Math.min(activeLayers.length, MAX_LAYERS);
                cloudMat.uniforms.uLayerCount.value = count;
                const tmpColorRef = new THREE.Color();

                const genericMap = [
                    ['bottom','uLayerBottom'], ['top','uLayerTop'], ['density','uLayerDensity'], ['coverage','uLayerCover'],
                    ['scaleMacro','uLayerScaleMacro'], ['scaleMicro','uLayerScaleMicro'], ['macroOctaves','uLayerMacroOctaves'], ['microOctaves','uLayerMicroOctaves'],
                    ['turbulence','uLayerTurbulence'], ['detailMix','uLayerDetailMix'], ['coverageExponent','uLayerCoverageExp'], ['windSpeed','uLayerWindSpeed'],
                    ['erosion','uLayerErosion'], ['type','uLayerType']
                ];

                for (let i = 0; i < MAX_LAYERS; i++) {
                    if (i < count) {
                        const l = activeLayers[i];
                        genericMap.forEach(([prop, u]) => cloudMat.uniforms[u].value[i] = l[prop]);

                        // explicit assignments for uniforms without direct property name mapping
                        cloudMat.uniforms.uLayerAbsorption.value[i] = l.absorption;
                        cloudMat.uniforms.uLayerSilver.value[i] = l.silver;
                        cloudMat.uniforms.uLayerDarkEdge.value[i] = l.darkEdge;
                        cloudMat.uniforms.uLayerScattering.value[i] = l.scattering;
                        cloudMat.uniforms.uLayerMicroContrast.value[i] = l.microContrast;

                        // clamp macro parameters to safe ranges
                        cloudMat.uniforms.uLayerMacroDensity.value[i] = Math.max(0.0, Math.min(1.0, l.macroDensity));
                        cloudMat.uniforms.uLayerMacroFalloff.value[i] = Math.max(0.01, l.macroFalloff);
                        cloudMat.uniforms.uLayerMacroCoreBias.value[i] = Math.max(0.0, l.macroCoreBias);
                        cloudMat.uniforms.uLayerMacroEdgeSoftness.value[i] = Math.max(0.0, l.macroEdgeSoftness);

                        // reuse a temporary color object to avoid allocations per-frame
                        const tmpColor = tmpColorRef || (tmpColorRef = new THREE.Color());
                        tmpColor.set(l.colorTop);
                        cloudMat.uniforms.uLayerColorTop.value[i].set(tmpColor.r, tmpColor.g, tmpColor.b);
                        tmpColor.set(l.colorBottom);
                        cloudMat.uniforms.uLayerColorBottom.value[i].set(tmpColor.r, tmpColor.g, tmpColor.b);

                        cloudMat.uniforms.uLayerWindDir.value[i].set(Math.sin(l.windAngle), Math.cos(l.windAngle));
                    } else {
                        // clear unused slots
                        cloudMat.uniforms.uLayerBottom.value[i] = 0;
                        cloudMat.uniforms.uLayerTop.value[i] = 0;
                        cloudMat.uniforms.uLayerDensity.value[i] = 0;
                        cloudMat.uniforms.uLayerCover.value[i] = 0;
                        cloudMat.uniforms.uLayerScaleMacro.value[i] = 0;
                        cloudMat.uniforms.uLayerScaleMicro.value[i] = 0;
                        cloudMat.uniforms.uLayerMacroDensity.value[i] = 0;
                        cloudMat.uniforms.uLayerMacroFalloff.value[i] = 1.0;
                        cloudMat.uniforms.uLayerMacroCoreBias.value[i] = 1.0;
                        cloudMat.uniforms.uLayerMacroEdgeSoftness.value[i] = 0;
                        cloudMat.uniforms.uLayerTurbulence.value[i] = 0;
                        cloudMat.uniforms.uLayerDetailMix.value[i] = 0;
                        cloudMat.uniforms.uLayerCoverageExp.value[i] = 1.0;
                        cloudMat.uniforms.uLayerAbsorption.value[i] = 0;
                        cloudMat.uniforms.uLayerSilver.value[i] = 0;
                        cloudMat.uniforms.uLayerDarkEdge.value[i] = 0;
                        cloudMat.uniforms.uLayerScattering.value[i] = 0;
                        cloudMat.uniforms.uLayerMicroContrast.value[i] = 1.0;
                        cloudMat.uniforms.uLayerWindSpeed.value[i] = 0;
                        cloudMat.uniforms.uLayerWindDir.value[i].set(0,0);
                        cloudMat.uniforms.uLayerErosion.value[i] = 0;
                        cloudMat.uniforms.uLayerType.value[i] = 0;
                        cloudMat.uniforms.uLayerColorTop.value[i].set(1,1,1);
                        cloudMat.uniforms.uLayerColorBottom.value[i].set(1,1,1);
                    }
                }

                cloudMat.needsUpdate = true;
            }

            rayMat = new THREE.ShaderMaterial({
                vertexShader: VERTEX_SHADER,
                fragmentShader: GODRAY_FRAGMENT,
                uniforms: {
                    tDiffuse: { value: null },
                    uSunPosScreen: { value: new THREE.Vector2() },
                    uSunVisible: { value: true },
                    uDensity: { value: GLOBAL_CONFIG.rayDensity },
                    uDecay: { value: GLOBAL_CONFIG.rayDecay },
                    uWeight: { value: GLOBAL_CONFIG.rayWeight },
                    uExposure: { value: GLOBAL_CONFIG.rayExposure },
                    uSamples: { value: GLOBAL_CONFIG.raySamples }
                },
                depthWrite: false, depthTest: false
            });

            compositeMat = new THREE.ShaderMaterial({
                vertexShader: VERTEX_SHADER,
                fragmentShader: COMPOSITE_FRAGMENT,
                uniforms: { tColor: { value: null }, tGodRays: { value: null }, tTerrain: { value: null }, uRayIntensity: { value: GLOBAL_CONFIG.rayIntensity }, uExposure: { value: GLOBAL_CONFIG.exposure } },
                depthWrite: false, depthTest: false
            });

            const quadGeo = new THREE.PlaneGeometry(2, 2);
            const quad = new THREE.Mesh(quadGeo, cloudMat);
            quad.frustumCulled = false;
            scene.add(quad);

            postScene = new THREE.Scene();
            postQuad = new THREE.Mesh(quadGeo, rayMat);
            postScene.add(postQuad);

            
            worldScene = new THREE.Scene();
            terrainMesh = createTerrainMesh();
            worldScene.add(terrainMesh);
            dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
            worldScene.add(dirLight);
            worldScene.add(new THREE.AmbientLight(0xffffff, 0.3));

            uiGui = new GUI({ title: 'Multi-Layer Engine' });

            const rebuildLayersGUI = () => {
                if (layersFolder) layersFolder.destroy();
                layersFolder = uiGui.addFolder('Cloud Layers');
                
                const controls = {
                    add: () => {
                        if (LAYERS.length >= MAX_LAYERS) { alert("Max layers reached"); return; }
                        LAYERS.push(createDefaultLayer(LAYERS.length));
                        updateLayerUniforms();
                        rebuildLayersGUI();
                    }
                };
                layersFolder.add(controls, 'add').name('+ Add Layer');

                LAYERS.forEach((layer, index) => {
                    const f = layersFolder.addFolder(layer.name);
                    f.add(layer, 'active').name('Active').onChange(updateLayerUniforms);
                    f.add(layer, 'bottom', 0, 20000).name('Alt Bottom').onChange(v => {
                        layer.bottom = Math.max(0, v);
                        if (layer.top < layer.bottom + 50) layer.top = layer.bottom + 50;
                        updateLayerUniforms();
                    });
                    f.add(layer, 'top', 0, 40000).name('Alt Top').onChange(v => {
                        layer.top = Math.max(0, v);
                        if (layer.bottom > layer.top - 50) layer.bottom = Math.max(0, layer.top - 50);
                        updateLayerUniforms();
                    });

                    // densityUI exposes a 0..1 slider that maps cubically to the density (gives more precision near 0)
                    if (typeof layer.densityUI === 'undefined') layer.densityUI = Math.pow(layer.density / 3.0, 1/3);
                    f.add(layer, 'densityUI', 0, 1).name('Density').onChange(v => {
                        layer.density = Math.pow(v, 3) * 3.0;
                        updateLayerUniforms();
                    });
                    f.add(layer, 'coverage', 0, 1).name('Coverage').onChange(updateLayerUniforms);
                    
                    f.add(layer, 'scaleMacro', 0.01, 1.0).name('Structure Scale').onChange(updateLayerUniforms);
                    f.add(layer, 'macroOctaves', 1, 8, 1).name('Macro Octaves').onChange(updateLayerUniforms);
                    f.add(layer, 'scaleMicro', 1.0, 10.0).name('Detail Scale').onChange(updateLayerUniforms);
                    f.add(layer, 'microOctaves', 1, 6, 1).name('Micro Octaves').onChange(updateLayerUniforms);
                    f.add(layer, 'detailMix', -1.0, 2.0).name('Detail Mix').onChange(updateLayerUniforms);
                    f.add(layer, 'turbulence', 0, 1).name('Turbulence').onChange(updateLayerUniforms);
                    f.add(layer, 'microContrast', 0.5, 3.0).name('Detail Contrast').onChange(updateLayerUniforms);
                    f.add(layer, 'coverageExponent', 0.1, 4).name('Coverage Exp').onChange(updateLayerUniforms);

                    const macroF = f.addFolder('Macro'); // Macro controls (density 0..1, bias 0..6)
                    // Macro density now ranges 0..1 for clearer control
                    macroF.add(layer, 'macroDensity', 0.0, 1.0).name('Macro Density').onChange(updateLayerUniforms);
                    macroF.add(layer, 'macroFalloff', 0.1, 6.0).name('Macro Falloff').onChange(updateLayerUniforms);
                    // widen core bias range to allow subtle to very sharp cores
                    macroF.add(layer, 'macroCoreBias', 0.0, 6.0).name('Core Bias').onChange(updateLayerUniforms);
                    macroF.add(layer, 'macroEdgeSoftness', 0.0, 0.5).name('Edge Softness').onChange(updateLayerUniforms);
                    
                    const vis = f.addFolder('Visuals');
                    vis.add(layer, 'absorption', 0.0, 2.0).name('Absorption').onChange(updateLayerUniforms);
                    vis.add(layer, 'silver', 0, 1).name('Silver Lining').onChange(updateLayerUniforms);
                    vis.add(layer, 'darkEdge', 0, 1).name('Dark Edges').onChange(updateLayerUniforms);
                    vis.add(layer, 'scattering', 0, 1).name('Scattering').onChange(updateLayerUniforms);
                    
                    f.add(layer, 'erosion', 0, 1).name('Erosion').onChange(updateLayerUniforms);
                    f.add(layer, 'type', 0, 1).name('Type (Shape)').onChange(updateLayerUniforms);
                    f.addColor(layer, 'colorTop').name('Color Top').onChange(updateLayerUniforms);
                    f.addColor(layer, 'colorBottom').name('Color Bottom').onChange(updateLayerUniforms);
                    f.add(layer, 'windSpeed', 0, 2.0).name('Wind Speed').onChange(updateLayerUniforms);
                    f.add(layer, 'windAngle', 0, Math.PI * 2).name('Wind Angle').onChange(updateLayerUniforms);
                    
                    const ops = { remove: () => {
                        LAYERS.splice(index, 1);
                        updateLayerUniforms();
                        rebuildLayersGUI();
                    }, reset: () => {
                        const def = createDefaultLayer(layer.id);
                        Object.assign(layer, def);
                        updateLayerUniforms();
                        rebuildLayersGUI();
                    }};
                    f.add(ops, 'remove').name('Remove Layer');
                    f.add(ops, 'reset').name('Reset to Default');
                });
            };
            rebuildLayersGUI();
            updateLayerUniforms();

            const globalF = uiGui.addFolder('Global: Sun & Atmosphere');
            globalF.add(GLOBAL_CONFIG, 'sunElevation', -10, 90).name('Sun Elev').onChange(v => updateLayerUniforms());
            globalF.add(GLOBAL_CONFIG, 'sunAzimuth', 0, 360).name('Sun Azi');
            globalF.add(GLOBAL_CONFIG, 'sunIntensity', 0, 10).name('Sun Int').onChange(v => cloudMat.uniforms.uSunIntensity.value = v);
            globalF.addColor(GLOBAL_CONFIG, 'skyColorZenith').onChange(v => cloudMat.uniforms.uSkyColorZenith.value.set(v));
            globalF.addColor(GLOBAL_CONFIG, 'skyColorHorizon').onChange(v => cloudMat.uniforms.uSkyColorHorizon.value.set(v));
            globalF.addColor(GLOBAL_CONFIG, 'skySunsetZenith').onChange(v => cloudMat.uniforms.uSkySunsetZenith.value.set(v));
            globalF.addColor(GLOBAL_CONFIG, 'skySunsetHorizon').onChange(v => cloudMat.uniforms.uSkySunsetHorizon.value.set(v));
            globalF.add(GLOBAL_CONFIG, 'enableClouds').name('Enable Clouds');

            const realismF = uiGui.addFolder('Global: Realism');
            realismF.add(cloudMat.uniforms.uMultiScatter, 'value', 0.0, 2.0).name('Multi-Scatter').onChange(v => cloudMat.uniforms.uMultiScatter.value = v);
            realismF.add(cloudMat.uniforms.uRimBoost, 'value', 0.0, 4.0).name('Rim Boost').onChange(v => cloudMat.uniforms.uRimBoost.value = v);
            realismF.add(cloudMat.uniforms.uAOIntensity, 'value', 0.0, 2.0).name('AO Intensity').onChange(v => cloudMat.uniforms.uAOIntensity.value = v);
            realismF.add(cloudMat.uniforms.uAOStrength, 'value', 0.0, 3.0).name('AO Strength').onChange(v => cloudMat.uniforms.uAOStrength.value = v);

            
            realismF.add(cloudMat.uniforms.uScatteringStrength, 'value', 0.0, 2.0).name('Scattering Strength').onChange(v => cloudMat.uniforms.uScatteringStrength.value = v);
            realismF.add(cloudMat.uniforms.uScatteringBoost, 'value', 0.1, 3.0).name('Scattering Boost').onChange(v => cloudMat.uniforms.uScatteringBoost.value = v);
            realismF.add(cloudMat.uniforms.uDarkEdgeIntensity, 'value', 0.0, 3.0).name('Dark Edge Intensity').onChange(v => cloudMat.uniforms.uDarkEdgeIntensity.value = v);
            realismF.add(cloudMat.uniforms.uDarkEdgeFalloff, 'value', 0.0, 3.0).name('Dark Edge Falloff').onChange(v => cloudMat.uniforms.uDarkEdgeFalloff.value = v);
            realismF.add(GLOBAL_CONFIG, 'silverLining', 0, 1).name('Silver Lining').onChange(v => cloudMat.uniforms.uSilverLining.value = v);
            realismF.add(GLOBAL_CONFIG, 'silverSpread', 0, 1).name('Silver Spread').onChange(v => cloudMat.uniforms.uSilverSpread.value = v);
            realismF.add(cloudMat.uniforms.uShadowSoftness, 'value', 0.0, 1.0).name('Shadow Softness').onChange(v => cloudMat.uniforms.uShadowSoftness.value = v);
            realismF.addColor(GLOBAL_CONFIG, 'shadowTint').name('Shadow Tint').onChange(v => cloudMat.uniforms.uShadowTint.value.set(v));
            realismF.add(compositeMat.uniforms.uExposure, 'value', 0.1, 3.0).name('Exposure').onChange(v => compositeMat.uniforms.uExposure.value = v);

            
            globalF.add(GLOBAL_CONFIG, 'sunDiskIntensity', 0, 200).name('Sun Disk').onChange(v => cloudMat.uniforms.uSunDisk.value = v);
            globalF.add(GLOBAL_CONFIG, 'skySaturation', 0, 2).name('Sky Saturation').onChange(v => cloudMat.uniforms.uSkySaturation.value = v);
            globalF.addColor(GLOBAL_CONFIG, 'skyColorHorizon').onChange(v => cloudMat.uniforms.uSkyColorHorizon.value.set(v));
            globalF.addColor(GLOBAL_CONFIG, 'skySunsetZenith').onChange(v => cloudMat.uniforms.uSkySunsetZenith.value.set(v));
            globalF.addColor(GLOBAL_CONFIG, 'skySunsetHorizon').onChange(v => cloudMat.uniforms.uSkySunsetHorizon.value.set(v));

            
            
            const renderF = uiGui.addFolder('Global: Render Quality');
            const onResChange = () => {
                const w = window.innerWidth, h = window.innerHeight;
                cloudTarget.setSize(w * GLOBAL_CONFIG.resolution, h * GLOBAL_CONFIG.resolution);
                denoiseTarget.setSize(w * GLOBAL_CONFIG.resolution, h * GLOBAL_CONFIG.resolution);
                rayTarget.setSize(w/2, h/2);
                terrainTarget.setSize(w, h);
                denoiseMat.uniforms.uResolution.value.set(w * GLOBAL_CONFIG.resolution, h * GLOBAL_CONFIG.resolution);
            };
            renderF.add(GLOBAL_CONFIG, 'resolution', 0.1, 1.0).name('Resolution').onChange(onResChange);
            renderF.add(GLOBAL_CONFIG, 'steps', 32, 256).name('Ray Steps').onChange(v => cloudMat.uniforms.uSteps.value = v);
            renderF.add(GLOBAL_CONFIG, 'autoQuality').name('Auto Quality');
            renderF.add(GLOBAL_CONFIG, 'minSteps', 8, 64, 1).name('Min Steps');
            
            const rayF = uiGui.addFolder('Global: God Rays');
            rayF.add(GLOBAL_CONFIG, 'rayIntensity', 0, 2).onChange(v => compositeMat.uniforms.uRayIntensity.value = v);
            rayF.add(GLOBAL_CONFIG, 'rayDensity', 0, 4).name('Density').onChange(v => rayMat.uniforms.uDensity.value = v);
            rayF.add(GLOBAL_CONFIG, 'rayDecay', 0.9, 1.0).name('Decay').onChange(v => rayMat.uniforms.uDecay.value = v);
            rayF.add(GLOBAL_CONFIG, 'rayWeight', 0, 1).name('Weight').onChange(v => rayMat.uniforms.uWeight.value = v);
            rayF.add(GLOBAL_CONFIG, 'rayExposure', 0, 2).name('Exposure').onChange(v => rayMat.uniforms.uExposure.value = v);
            rayF.add(GLOBAL_CONFIG, 'raySamples', 4, 200, 1).name('Samples').onChange(v => rayMat.uniforms.uSamples.value = v);

            const audioF = uiGui.addFolder('Global: Audio');
            audioF.add(GLOBAL_CONFIG, 'masterVolume', 0, 1).onChange(() => audioManager.updateVolumes());

            const onResize = () => {
                const w = window.innerWidth, h = window.innerHeight;
                renderer.setSize(w, h);
                cloudTarget.setSize(w * GLOBAL_CONFIG.resolution, h * GLOBAL_CONFIG.resolution);
                denoiseTarget.setSize(w * GLOBAL_CONFIG.resolution, h * GLOBAL_CONFIG.resolution);
                rayTarget.setSize(w/2, h/2);
                terrainTarget.setSize(w, h);
                denoiseMat.uniforms.uResolution.value.set(w * GLOBAL_CONFIG.resolution, h * GLOBAL_CONFIG.resolution);
                camera.aspect = w / h;
                camera.updateProjectionMatrix();
            };
            window.addEventListener('resize', onResize);
            onResize(); 

            const dummyCam = new THREE.Camera();

            function runPostPass(mat, target, uniforms) {
                postQuad.material = mat;
                if (uniforms) {
                    for (const k in uniforms) if (mat.uniforms[k]) mat.uniforms[k].value = uniforms[k];
                }
                renderer.setRenderTarget(target);
                renderer.render(postScene, dummyCam);
            }

            function render() {
                requestAnimationFrame(render);
                
                const dt = clock.getDelta();
                
                cloudMat.uniforms.uTime.value += dt;
                flightControls.update(dt);
                
                
                let currentDensity = 0;
                const camY = flightControls.worldPos.y;
                LAYERS.forEach(l => {
                    if (l.active && camY > l.bottom && camY < l.top) {
                        currentDensity += l.density;
                    }
                });
                currentDensity = Math.min(currentDensity, 2.0); 
                
                document.getElementById('val-dens').innerText = Math.round(currentDensity * 100) + '%';
                
                audioManager.update(
                    flightControls.keys,
                    flightControls.currentSpeed, 
                    flightControls.worldPos.y,
                    currentDensity,
                    GLOBAL_CONFIG.sunElevation
                );

                const WRAP_PERIOD = 200000.0;
                const offsetX = flightControls.worldPos.x % WRAP_PERIOD;
                const offsetZ = flightControls.worldPos.z % WRAP_PERIOD;
                
                cloudMat.uniforms.uWorldOffset.value.set(offsetX, 0, offsetZ);
                cloudMat.uniforms.uCameraY.value = flightControls.worldPos.y;

                const phi = THREE.MathUtils.degToRad(90 - GLOBAL_CONFIG.sunElevation);
                const theta = THREE.MathUtils.degToRad(GLOBAL_CONFIG.sunAzimuth);
                const sunDir = new THREE.Vector3(
                    Math.sin(phi) * Math.cos(theta),
                    Math.cos(phi),
                    Math.sin(phi) * Math.sin(theta)
                ).normalize();
                
                const sunLightColor = getSunLightColor(GLOBAL_CONFIG.sunElevation);
                
                cloudMat.uniforms.uSunDir.value.copy(sunDir);
                cloudMat.uniforms.uSunColor.value.copy(sunLightColor);
                cloudMat.uniforms.uCameraPos.value.copy(camera.position);
                cloudMat.uniforms.uInverseView.value.copy(camera.matrixWorld);
                cloudMat.uniforms.uInverseProj.value.copy(camera.projectionMatrixInverse);

                // auto-adjust marching steps for performance based on altitude
                if (GLOBAL_CONFIG.autoQuality) {
                    const altFactor = THREE.MathUtils.clamp(flightControls.worldPos.y / 15000, 0.0, 1.0);
                    const steps = Math.round(THREE.MathUtils.lerp(GLOBAL_CONFIG.minSteps, GLOBAL_CONFIG.steps, 1.0 - altFactor));
                    cloudMat.uniforms.uSteps.value = steps;
                } else {
                    cloudMat.uniforms.uSteps.value = GLOBAL_CONFIG.steps;
                }

                const camDir = new THREE.Vector3();
                camera.getWorldDirection(camDir);
                const isSunVisible = camDir.dot(sunDir) > 0.0;

                if (isSunVisible) {
                    const sunWorld = camera.position.clone().add(sunDir.clone().multiplyScalar(10000));
                    sunWorld.project(camera);
                    const sx = sunWorld.x * 0.5 + 0.5;
                    const sy = sunWorld.y * 0.5 + 0.5;
                    const sz = sunWorld.z;
                    const visibleOnScreen = sz > 0 && sx >= 0 && sx <= 1 && sy >= 0 && sy <= 1;
                    rayMat.uniforms.uSunVisible.value = visibleOnScreen;
                    if (visibleOnScreen) rayMat.uniforms.uSunPosScreen.value.set(sx, sy);
                } else {
                    rayMat.uniforms.uSunVisible.value = false;
                }

                
                if (terrainMesh) {
                    updateTerrain(flightControls.worldPos.x, flightControls.worldPos.z);
                    dirLight.position.copy(sunDir.clone().multiplyScalar(10000));
                    dirLight.color.copy(sunLightColor);
                    renderer.setRenderTarget(terrainTarget);
                    renderer.render(worldScene, camera);
                    compositeMat.uniforms.tTerrain.value = terrainTarget.texture;
                }

                // if clouds are disabled, render the world scene and skip cloud/post passes
                if (!GLOBAL_CONFIG.enableClouds) {
                    renderer.setRenderTarget(null);
                    renderer.render(worldScene, camera);
                    return;
                }

                // main cloud render
                renderer.setRenderTarget(cloudTarget);
                renderer.render(scene, dummyCam);

                runPostPass(denoiseMat, denoiseTarget, { tDiffuse: cloudTarget.texture });
                runPostPass(rayMat, rayTarget, { tDiffuse: denoiseTarget.texture });
                runPostPass(compositeMat, null, { tColor: denoiseTarget.texture, tGodRays: rayTarget.texture });
            }

            render();
        }

        init();
    </script>
</body>
</html>