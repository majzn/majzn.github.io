<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Precision CFD Editor</title>
<style>
    body { margin: 0; overflow: hidden; background: #1a1a1a; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; color: #ccc; }
    canvas { display: block; position: absolute; top: 0; left: 0; }
    #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
    .panel { position: absolute; background: rgba(30, 30, 30, 0.95); backdrop-filter: blur(5px); padding: 10px; border: 1px solid #444; border-radius: 4px; pointer-events: auto; box-shadow: 0 4px 6px rgba(0,0,0,0.3); }
    #toolbar { top: 10px; left: 10px; width: 220px; display: flex; flex-direction: column; gap: 8px; }
    #sim-controls { top: 10px; right: 10px; width: 260px; max-height: 90vh; overflow-y: auto; }
    #analysis-panel { bottom: 10px; left: 10px; width: 220px; font-family: 'Consolas', monospace; font-size: 11px; }
    
    button { background: #333; border: 1px solid #555; color: #eee; padding: 6px 12px; cursor: pointer; border-radius: 2px; transition: background 0.2s; font-size: 12px; text-align: left; }
    button:hover { background: #444; border-color: #666; }
    button.active { background: #3b82f6; border-color: #2563eb; color: white; }
    
    .control-group { margin-bottom: 10px; }
    .control-group label { display: block; font-size: 11px; color: #888; margin-bottom: 4px; }
    
    input[type="range"] { width: 100%; background: #333; height: 4px; border-radius: 2px; -webkit-appearance: none; }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 12px; height: 12px; background: #bbb; border-radius: 50%; cursor: pointer; }
    input[type="color"] { width: 100%; height: 25px; border: none; background: none; cursor: pointer; }
    input[type="number"] { width: 60px; background: #222; border: 1px solid #555; color: #eee; padding: 2px 5px; }
    
    select { background:#333; color:#eee; border:1px solid #555; width:100%; padding: 4px; border-radius: 2px; }

    .value-display { float: right; color: #3b82f6; font-family: monospace; }
    h3 { margin: 0 0 10px 0; font-size: 14px; color: #fff; border-bottom: 1px solid #444; padding-bottom: 5px; }
    .hint { font-size: 10px; color: #666; margin-top: 5px; font-style: italic; }
    .status-ok { color: #4ade80; font-size:10px; margin-top:5px; }
    .status-err { color: #f87171; font-size:10px; margin-top:5px; }

    /* Selection visuals */
    .selection-rect { position: absolute; border: 1px dashed #3b82f6; background: rgba(59,130,246,0.06); pointer-events:none; }
    .selected-point { background: #f59e0b; }
    #ctx-menu { position: absolute; display: none; background: rgba(25,25,25,0.98); border: 1px solid #333; color: #eee; padding: 6px; border-radius: 4px; z-index: 10000; }
    #ctx-menu button { display:block; width:100%; text-align:left; padding:6px 8px; background:transparent; border:none; color:#eee; }
    #ctx-menu button:hover { background:#333; }

    .data-row { display: flex; justify-content: space-between; margin-bottom: 2px; }
    .data-label { color: #888; }
    .data-val { color: #fff; }

    #gradient-editor { display: none; margin-top: 10px; border-top: 1px solid #444; padding-top: 10px; }
    .grad-stop { display: flex; align-items: center; margin-bottom: 4px; }
    .grad-stop input[type=color] { width: 30px; height: 20px; margin-right: 5px; }
    .grad-stop input[type=range] { flex-grow: 1; }
    
    .dim-inputs { display: flex; gap: 10px; }
    .dim-inputs div { flex: 1; }
    
    #view-controls { display: flex; gap: 5px; margin-bottom: 5px; }
    #view-controls button { flex: 1; text-align: center; }
</style>
</head>
<body>

<canvas id="glcanvas"></canvas>
<canvas id="uicanvas"></canvas>

<div id="ui-layer">
    <div id="toolbar" class="panel">
        <h3>View</h3>
        <div id="view-controls">
            <button id="btn-fit" title="Fit to Screen">Fit View</button>
        </div>
        <div class="hint" style="margin-bottom:10px;">
            Scroll to Zoom<br>Middle-Click Drag to Pan
        </div>

        <h3>Tools</h3>
        <button id="btn-select" class="active">Select / Edit (V)</button>
        <button id="btn-draw-poly">Draw Polygon (P)</button>
        <button id="btn-draw-rect">Draw Rectangle (R)</button>
        <button id="btn-draw-circ">Draw Circle (C)</button>
        <button id="btn-emitter">Place Emitter (E)</button>
        <button id="btn-move">Move Selection (M)</button>
        
        <div class="control-group" style="margin-top: 10px;">
            <label>Snapping (Grid)</label>
            <input type="checkbox" id="chk-snap" checked> <span style="font-size:11px">Enabled</span>
        </div>
        <div class="control-group">
            <button id="btn-clear-sim">Reset Simulation</button>
            <button id="btn-clear-geo" style="background:#522;">Clear All Geometry</button>
        </div>
        <div class="hint">
            Draw Poly: Click points, click start to close.<br>
            Draw Rect/Circ: Drag to create.<br>
            Edit: Drag points, Del to remove obj.
        </div>



        <div id="status-display"></div>
    </div>

    <div id="analysis-panel" class="panel">
        <h3>Probe Analysis</h3>
        <div class="data-row"><span class="data-label">Pos X:</span><span id="data-x" class="data-val">0.00</span></div>
        <div class="data-row"><span class="data-label">Pos Y:</span><span id="data-y" class="data-val">0.00</span></div>
        <div style="border-top:1px solid #444; margin: 5px 0;"></div>
        <div class="data-row"><span class="data-label">Density:</span><span id="data-rho" class="data-val">0.00</span></div>
        <div class="data-row"><span class="data-label">Pressure:</span><span id="data-p" class="data-val">0.00</span></div>
        <div class="data-row"><span class="data-label">Vel X:</span><span id="data-vx" class="data-val">0.00</span></div>
        <div class="data-row"><span class="data-label">Vel Y:</span><span id="data-vy" class="data-val">0.00</span></div>
        <div class="data-row"><span class="data-label">Speed:</span><span id="data-speed" class="data-val">0.00</span></div>
        <div class="data-row"><span class="data-label">Vorticity:</span><span id="data-curl" class="data-val">0.00</span></div>
        <div style="border-top:1px solid #444; margin: 5px 0;"></div>
        <div class="data-row"><span class="data-label">Range Min:</span><span id="data-min" class="data-val">0.00</span></div>
        <div class="data-row"><span class="data-label">Range Max:</span><span id="data-max" class="data-val">0.00</span></div>
    </div>

    <div id="sim-controls" class="panel">
        <h3>Performance & Physics</h3>
        
        <div class="control-group">
            <label>Grid Dimensions (Pixels)</label>
            <div class="dim-inputs">
                <div>
                    <label>Width</label>
                    <input type="number" id="inp-width" value="256" step="32" min="32" max="2048">
                </div>
                <div>
                    <label>Height</label>
                    <input type="number" id="inp-height" value="256" step="32" min="32" max="2048">
                </div>
                <button id="btn-resize" style="margin-top:16px;">Set</button>
            </div>
        </div>

        <div class="control-group">
            <label title="Splits one frame into multiple physics steps">Substeps <span id="val-substeps" class="value-display">5</span></label>
            <input type="range" id="sl-substeps" min="1" max="20" step="1" value="5">
        </div>

        <div class="control-group">
            <label>Time Scale <span id="val-tscale" class="value-display">1.0</span></label>
            <input type="range" id="sl-tscale" min="0.1" max="10.0" step="0.1" value="1.0">
        </div>
        
        <div class="control-group">
            <label>Iterations <span id="val-iter" class="value-display">15</span></label>
            <input type="range" id="sl-iter" min="2" max="50" value="15">
        </div>

        <div class="control-group">
            <label>Viscosity</label>
            <input type="range" id="sl-diss" min="0.9" max="1.0" step="0.001" value="0.998">
        </div>

        <div class="control-group">
            <label>Vorticity</label>
            <input type="range" id="sl-vort" min="0" max="5" step="0.1" value="1.0">
        </div>

        <h3>Inflow</h3>
        <div class="control-group">
            <label>Velocity</label>
            <input type="range" id="sl-inflow" min="0" max="10" step="0.1" value="1.5">
        </div>
        <div class="control-group">
            <label>Dye Color</label>
            <input type="color" id="col-dye" value="#cccccc">
        </div>

        <h3>Visualization</h3>
        <div class="control-group">
            <label>Data Field</label>
            <select id="sel-vis">
                <option value="dye">Dye / Smoke</option>
                <option value="velocity">Velocity Magnitude</option>
                <option value="pressure">Pressure Field</option>
                <option value="curl">Curl / Vorticity</option>
            </select>
        </div>
        <div class="control-group">
            <label>Color Palette</label>
            <select id="sel-pal">
                <option value="0">Inferno (Heat)</option>
                <option value="1">Viridis (Analytical)</option>
                <option value="2">Water (Blue/White)</option>
                <option value="3">Fire (Red/Yellow)</option>
                <option value="4">Ice (Teal/White)</option>
                <option value="5">Grayscale</option>
                <option value="6">Turbo (Rainbow)</option>
                <option value="7">Custom Gradient</option>
            </select>
        </div>

        <div id="gradient-editor">
            <div class="grad-stop"><input type="color" id="g-c1" value="#000000"><input type="range" id="g-p1" min="0" max="100" value="0"></div>
            <div class="grad-stop"><input type="color" id="g-c2" value="#0000ff"><input type="range" id="g-p2" min="0" max="100" value="25"></div>
            <div class="grad-stop"><input type="color" id="g-c3" value="#00ffff"><input type="range" id="g-p3" min="0" max="100" value="50"></div>
            <div class="grad-stop"><input type="color" id="g-c4" value="#ffff00"><input type="range" id="g-p4" min="0" max="100" value="75"></div>
            <div class="grad-stop"><input type="color" id="g-c5" value="#ffffff"><input type="range" id="g-p5" min="0" max="100" value="100"></div>
        </div>
        
        <div class="control-group" style="margin-top:10px;">
            <label style="color:#4ade80;">Auto Scale Range</label>
            <input type="checkbox" id="chk-autoscale" checked> <span style="font-size:11px">Enabled</span>
        </div>

        <div class="control-group">
            <label>Manual Min</label>
            <input type="range" id="sl-min" min="-10.0" max="10.0" step="0.1" value="0.0">
        </div>
        <div class="control-group">
            <label>Manual Max</label>
            <input type="range" id="sl-max" min="-10.0" max="10.0" step="0.1" value="1.0">
        </div>

        <div class="control-group">
            <label>Overlays</label>
            <input type="checkbox" id="chk-vectors"> <span style="font-size:11px">Show Vector Grid</span>
        </div>
    </div>
</div>

<!-- SHADERS -->

<script id="vs" type="x-shader/x-vertex">
    attribute vec2 aPosition;
    varying vec2 vUv;
    void main() {
        vUv = aPosition * 0.5 + 0.5;
        gl_Position = vec4(aPosition, 0.0, 1.0);
    }
</script>

<script id="fs-boundary" type="x-shader/x-fragment">
    precision highp float;
    varying vec2 vUv;
    uniform sampler2D uTexture;
    uniform vec2 uTexelSize;
    void main() {
        if (vUv.x <= uTexelSize.x || vUv.x >= 1.0 - uTexelSize.x ||
            vUv.y <= uTexelSize.y || vUv.y >= 1.0 - uTexelSize.y) {
            gl_FragColor = vec4(0.0);
        } else {
            gl_FragColor = texture2D(uTexture, vUv);
        }
    }
</script>

<script id="fs-advect" type="x-shader/x-fragment">
    precision highp float;
    varying vec2 vUv;
    uniform sampler2D uVelocity;
    uniform sampler2D uSource;
    uniform sampler2D uObstacles;
    uniform vec2 uTexelSize;
    uniform float dt;
    uniform float dissipation;

    void main() {
        float solid = texture2D(uObstacles, vUv).x;
        if(solid > 0.0) {
            gl_FragColor = vec4(0.0);
            return;
        }
        vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * uTexelSize;
        vec4 result = texture2D(uSource, coord);
        gl_FragColor = result * dissipation;
    }
</script>

<script id="fs-jacobi" type="x-shader/x-fragment">
    precision highp float;
    varying vec2 vUv;
    uniform sampler2D uPressure;
    uniform sampler2D uDivergence;
    uniform sampler2D uObstacles;
    uniform vec2 uTexelSize;

    void main() {
        float L = texture2D(uPressure, vUv - vec2(uTexelSize.x, 0.0)).x;
        float R = texture2D(uPressure, vUv + vec2(uTexelSize.x, 0.0)).x;
        float B = texture2D(uPressure, vUv - vec2(0.0, uTexelSize.y)).x;
        float T = texture2D(uPressure, vUv + vec2(0.0, uTexelSize.y)).x;
        float C = texture2D(uPressure, vUv).x;
        float div = texture2D(uDivergence, vUv).x;
        float obsL = texture2D(uObstacles, vUv - vec2(uTexelSize.x, 0.0)).x;
        float obsR = texture2D(uObstacles, vUv + vec2(uTexelSize.x, 0.0)).x;
        float obsB = texture2D(uObstacles, vUv - vec2(0.0, uTexelSize.y)).x;
        float obsT = texture2D(uObstacles, vUv + vec2(0.0, uTexelSize.y)).x;
        if (obsL > 0.0) L = C; if (obsR > 0.0) R = C;
        if (obsB > 0.0) B = C; if (obsT > 0.0) T = C;
        gl_FragColor = vec4((L + R + B + T - div) * 0.25, 0.0, 0.0, 1.0);
    }
</script>

<script id="fs-divergence" type="x-shader/x-fragment">
    precision highp float;
    varying vec2 vUv;
    uniform sampler2D uVelocity;
    uniform sampler2D uObstacles;
    uniform vec2 uTexelSize;

    void main() {
        float L = texture2D(uVelocity, vUv - vec2(uTexelSize.x, 0.0)).x;
        float R = texture2D(uVelocity, vUv + vec2(uTexelSize.x, 0.0)).x;
        float B = texture2D(uVelocity, vUv - vec2(0.0, uTexelSize.y)).y;
        float T = texture2D(uVelocity, vUv + vec2(0.0, uTexelSize.y)).y;
        vec2 C = texture2D(uVelocity, vUv).xy;
        float obsL = texture2D(uObstacles, vUv - vec2(uTexelSize.x, 0.0)).x;
        float obsR = texture2D(uObstacles, vUv + vec2(uTexelSize.x, 0.0)).x;
        float obsB = texture2D(uObstacles, vUv - vec2(0.0, uTexelSize.y)).x;
        float obsT = texture2D(uObstacles, vUv + vec2(0.0, uTexelSize.y)).x;
        if (obsL > 0.0) L = -C.x; if (obsR > 0.0) R = -C.x;
        if (obsB > 0.0) B = -C.y; if (obsT > 0.0) T = -C.y;
        float div = 0.5 * (R - L + T - B);
        gl_FragColor = vec4(div, 0.0, 0.0, 1.0);
    }
</script>

<script id="fs-gradient" type="x-shader/x-fragment">
    precision highp float;
    varying vec2 vUv;
    uniform sampler2D uPressure;
    uniform sampler2D uVelocity;
    uniform sampler2D uObstacles;
    uniform vec2 uTexelSize;

    void main() {
        float L = texture2D(uPressure, vUv - vec2(uTexelSize.x, 0.0)).x;
        float R = texture2D(uPressure, vUv + vec2(uTexelSize.x, 0.0)).x;
        float B = texture2D(uPressure, vUv - vec2(0.0, uTexelSize.y)).x;
        float T = texture2D(uPressure, vUv + vec2(0.0, uTexelSize.y)).x;
        float obsL = texture2D(uObstacles, vUv - vec2(uTexelSize.x, 0.0)).x;
        float obsR = texture2D(uObstacles, vUv + vec2(uTexelSize.x, 0.0)).x;
        float obsB = texture2D(uObstacles, vUv - vec2(0.0, uTexelSize.y)).x;
        float obsT = texture2D(uObstacles, vUv + vec2(0.0, uTexelSize.y)).x;
        float C = texture2D(uPressure, vUv).x;
        if (obsL > 0.0) L = C; if (obsR > 0.0) R = C;
        if (obsB > 0.0) B = C; if (obsT > 0.0) T = C;
        vec2 vel = texture2D(uVelocity, vUv).xy;
        vel.xy -= vec2(R - L, T - B) * 0.5;
        if(texture2D(uObstacles, vUv).x > 0.0) vel = vec2(0.0);
        gl_FragColor = vec4(vel, 0.0, 1.0);
    }
</script>

<script id="fs-splat" type="x-shader/x-fragment">
    precision highp float;
    varying vec2 vUv;
    uniform sampler2D uTarget;
    uniform float aspectRatio;
    uniform vec2 point;
    uniform vec3 color;
    uniform float radius;

    void main() {
        vec2 p = vUv - point.xy;
        p.x *= aspectRatio; // Fix for aspect ratio
        vec3 splat = exp(-dot(p, p) / radius) * color;
        vec3 base = texture2D(uTarget, vUv).xyz;
        gl_FragColor = vec4(base + splat, 1.0);
    }
</script>

<script id="fs-vorticity" type="x-shader/x-fragment">
    precision highp float;
    varying vec2 vUv;
    uniform sampler2D uVelocity;
    uniform vec2 uTexelSize;

    void main() {
        float L = texture2D(uVelocity, vUv - vec2(uTexelSize.x, 0.0)).y;
        float R = texture2D(uVelocity, vUv + vec2(uTexelSize.x, 0.0)).y;
        float B = texture2D(uVelocity, vUv - vec2(0.0, uTexelSize.y)).x;
        float T = texture2D(uVelocity, vUv + vec2(0.0, uTexelSize.y)).x;
        float vor = 0.5 * (R - L - T + B);
        gl_FragColor = vec4(vor, 0.0, 0.0, 1.0);
    }
</script>

<script id="fs-vorticity-force" type="x-shader/x-fragment">
    precision highp float;
    varying vec2 vUv;
    uniform sampler2D uVelocity;
    uniform sampler2D uCurl;
    uniform vec2 uTexelSize;
    uniform float dt;
    uniform float confinement;

    void main() {
        float L = texture2D(uCurl, vUv - vec2(uTexelSize.x, 0.0)).x;
        float R = texture2D(uCurl, vUv + vec2(uTexelSize.x, 0.0)).x;
        float B = texture2D(uCurl, vUv - vec2(0.0, uTexelSize.y)).x;
        float T = texture2D(uCurl, vUv + vec2(0.0, uTexelSize.y)).x;
        float C = texture2D(uCurl, vUv).x;
        vec2 force = vec2(abs(T) - abs(B), abs(R) - abs(L));
        float epsilon = 0.0001;
        float len = length(force);
        if (len > epsilon) {
            force /= len;
            force *= confinement * C * vec2(1.0, -1.0);
        } else {
            force = vec2(0.0);
        }
        vec2 vel = texture2D(uVelocity, vUv).xy;
        gl_FragColor = vec4(vel + force * dt, 0.0, 1.0);
    }
</script>

<!-- Simplified Downsample Shader for Auto-Scale -->
<script id="fs-copy" type="x-shader/x-fragment">
    precision highp float;
    varying vec2 vUv;
    uniform sampler2D uTexture;
    uniform int uMode; // 0:Scalar 1:VectorMag
    void main() {
        if(uMode == 1) {
            vec2 v = texture2D(uTexture, vUv).xy;
            gl_FragColor = vec4(length(v), 0.0, 0.0, 1.0);
        } else {
            vec4 c = texture2D(uTexture, vUv);
            float val = c.x; 
            if(uMode == 2) val = dot(c.xyz, vec3(0.333)); // Dye avg
            gl_FragColor = vec4(val, 0.0, 0.0, 1.0);
        }
    }
</script>

<script id="fs-display" type="x-shader/x-fragment">
    precision highp float;
    varying vec2 vUv;
    uniform sampler2D uDensity;
    uniform sampler2D uVelocity;
    uniform sampler2D uPressure;
    uniform sampler2D uCurl;
    uniform sampler2D uObstacles;
    uniform sampler2D uGradient; // LUT
    uniform int uMode; 
    
    // Normalization Ranges
    uniform float uMin;
    uniform float uMax;

    // View transform
    uniform vec2 uPan;
    uniform float uZoom;
    uniform float uAspect;

    void main() {
        // Map screen UV (0..1) to world coordinates, accounting for aspect
        vec2 screen = vUv;
        vec2 screenWorld = vec2(screen.x * uAspect, screen.y);
        vec2 worldUV = screenWorld / uZoom - uPan;
        // Map world to simulation UV (s = x / aspect, t = y)
        vec2 simUV = vec2(worldUV.x / uAspect, worldUV.y);

        // Outside simulation bounds -> background
        if(simUV.x < 0.0 || simUV.x > 1.0 || simUV.y < 0.0 || simUV.y > 1.0) {
            gl_FragColor = vec4(0.03, 0.03, 0.03, 1.0);
            return;
        }

        vec4 obs = texture2D(uObstacles, simUV);
        if (obs.x > 0.0) {
            float stripe = mod(gl_FragCoord.x + gl_FragCoord.y, 20.0);
            float c = stripe < 10.0 ? 0.3 : 0.4;
            gl_FragColor = vec4(c, c, c, 1.0);
            return;
        }

        float val = 0.0;

        if (uMode == 0) { // Dye
            vec3 d = texture2D(uDensity, simUV).xyz;
            val = length(d); 
        } 
        else if (uMode == 1) { // Velocity
            vec2 vel = texture2D(uVelocity, simUV).xy;
            val = length(vel);
        } 
        else if (uMode == 2) { // Pressure
            val = texture2D(uPressure, simUV).x;
        } 
        else if (uMode == 3) { // Curl
            val = texture2D(uCurl, simUV).x;
        }

        // Normalize
        float range = uMax - uMin;
        if(range < 0.0001) range = 0.0001;
        float norm = (val - uMin) / range;
        norm = clamp(norm, 0.0, 1.0);

        // Lookup Color
        vec3 color = texture2D(uGradient, vec2(norm, 0.5)).rgb;
        gl_FragColor = vec4(color, 1.0);
    }
</script>

<script>
    const CONFIG = {
        simWidth: 256,
        simHeight: 256,
        aspectRatio: 1.0,
        substeps: 5,
        timeScale: 1.0,
        iterations: 15,
        dt: 0.016,
        dissipation: 0.998,
        decay: 0.990,
        curl: 1.0,
        inflow: 1.5,
        visMode: 0,
        palette: 0,
        dyeColor: [0.8, 0.8, 0.8],
        showVectors: false,
        autoScale: true,
        valMin: 0.0,
        valMax: 1.0
    };

    let currentMin = 0.0;
    let currentMax = 1.0;

    const canvas = document.getElementById('glcanvas');
    const uiCanvas = document.getElementById('uicanvas');
    const gl = canvas.getContext('webgl');
    const ctx = uiCanvas.getContext('2d');
    const statusDiv = document.getElementById('status-display');

    // --- Texture Type & Extension Support ---
    function getTextureSupport() {
        let texType = gl.FLOAT;
        let support = { type: 'FLOAT', linear: false };
        let ext = gl.getExtension('OES_texture_float');
        let lin = gl.getExtension('OES_texture_float_linear');
        if (!ext || !lin) {
            let extHalf = gl.getExtension('OES_texture_half_float');
            let linHalf = gl.getExtension('OES_texture_half_float_linear');
            if (extHalf && linHalf) {
                ext = extHalf; lin = linHalf;
                texType = extHalf.HALF_FLOAT_OES;
                support.type = 'HALF_FLOAT'; support.linear = true;
            } else if (ext) {
                support.type = 'FLOAT (Nearest)';
            } else { return null; }
        } else { support.linear = true; }
        return { ext, lin, texType, support };
    }

    const texSupport = getTextureSupport();
    if (!texSupport) {
        alert("Fatal Error: Your device does not support Float or Half-Float WebGL textures.");
    } else {
        if(statusDiv) {
            const status = texSupport.support.linear ? "status-ok" : "status-err";
            statusDiv.innerHTML = `<div class="${status}">Mode: ${texSupport.support.type} ${texSupport.support.linear ? '(Linear)' : '(Nearest)'}</div>`;
        }
    }

    function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) { console.error(gl.getShaderInfoLog(shader)); return null; }
        return shader;
    }
    function createProgram(gl, vsSource, fsSource) {
        const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
        const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
        const program = gl.createProgram();
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);
        return program;
    }

    const vsSource = document.getElementById('vs').innerText;
    const programs = {
        advect: createProgram(gl, vsSource, document.getElementById('fs-advect').innerText),
        divergence: createProgram(gl, vsSource, document.getElementById('fs-divergence').innerText),
        jacobi: createProgram(gl, vsSource, document.getElementById('fs-jacobi').innerText),
        gradient: createProgram(gl, vsSource, document.getElementById('fs-gradient').innerText),
        splat: createProgram(gl, vsSource, document.getElementById('fs-splat').innerText),
        vorticity: createProgram(gl, vsSource, document.getElementById('fs-vorticity').innerText),
        vorticityForce: createProgram(gl, vsSource, document.getElementById('fs-vorticity-force').innerText),
        boundary: createProgram(gl, vsSource, document.getElementById('fs-boundary').innerText),
        display: createProgram(gl, vsSource, document.getElementById('fs-display').innerText),
        copy: createProgram(gl, vsSource, document.getElementById('fs-copy').innerText)
    };

    // Utility helpers
    const $ = (id) => document.getElementById(id);
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const fmt = (v, n = 2) => (typeof v === 'number' ? v.toFixed(n) : v);

    function makeEmitterDefaults(e) {
        return Object.assign({ shape: 'circle', size: 0.05, width: 0.05, height: 0.05, spread: 30, angle: 0, force: CONFIG.inflow, amount: 1.0, pressure: 0.0, enabled: true }, e);
    }
    function createEmitter(e) { const em = makeEmitterDefaults(e); EDITOR.emitters.push(em); return em; }

    // Cache frequently used uniform locations for faster rendering
    programs.splat.locs = {
        uTarget: gl.getUniformLocation(programs.splat, 'uTarget'),
        aspectRatio: gl.getUniformLocation(programs.splat, 'aspectRatio'),
        point: gl.getUniformLocation(programs.splat, 'point'),
        color: gl.getUniformLocation(programs.splat, 'color'),
        radius: gl.getUniformLocation(programs.splat, 'radius')
    };

    programs.display.locs = {
        uPan: gl.getUniformLocation(programs.display, 'uPan'),
        uZoom: gl.getUniformLocation(programs.display, 'uZoom'),
        uAspect: gl.getUniformLocation(programs.display, 'uAspect'),
        uMin: gl.getUniformLocation(programs.display, 'uMin'),
        uMax: gl.getUniformLocation(programs.display, 'uMax'),
        uMode: gl.getUniformLocation(programs.display, 'uMode')
    };

    function createTexture(width, height) {
        const tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texSupport.support.linear ? gl.LINEAR : gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, texSupport.support.linear ? gl.LINEAR : gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, texSupport.texType, null);
        return tex;
    }

    function createFBO(width, height) {
        const tex = createTexture(width, height);
        const fbo = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
        return { texture: tex, fbo: fbo, width, height };
    }

    function createDoubleFBO(width, height) {
        return {
            read: createFBO(width, height),
            write: createFBO(width, height),
            swap: function() { let temp = this.read; this.read = this.write; this.write = temp; }
        };
    }

    // Initialize Global Sim Variables (placeholders)
    let density, velocity, pressure, divergence, curl;
    let sampleFBO = createFBO(32, 32);
    
    let obstacleCanvas = document.createElement('canvas');
    let obsCtx = obstacleCanvas.getContext('2d');
    let obstacleTexture = gl.createTexture();
    let gradientTexture = gl.createTexture();
    
    function updateGradient() {
        const w = 256; const h = 1;
        const gradCanvas = document.createElement('canvas');
        gradCanvas.width = w; gradCanvas.height = h;
        const gctx = gradCanvas.getContext('2d');
        const grd = gctx.createLinearGradient(0, 0, w, 0);
        
        if (CONFIG.palette === 7) { 
            for(let i=1; i<=5; i++) {
                let c = document.getElementById(`g-c${i}`).value;
                let p = document.getElementById(`g-p${i}`).value / 100;
                grd.addColorStop(p, c);
            }
        } else {
            if (CONFIG.palette === 0) { grd.addColorStop(0, '#000000'); grd.addColorStop(0.2, '#550088'); grd.addColorStop(0.5, '#dd3355'); grd.addColorStop(0.8, '#ffcc00'); grd.addColorStop(1, '#ffffff'); }
            else if (CONFIG.palette === 1) { grd.addColorStop(0, '#440154'); grd.addColorStop(0.25, '#3b528b'); grd.addColorStop(0.5, '#21918c'); grd.addColorStop(0.75, '#5ec962'); grd.addColorStop(1, '#fde725'); }
            else if (CONFIG.palette === 2) { grd.addColorStop(0, '#000000'); grd.addColorStop(0.3, '#003366'); grd.addColorStop(0.6, '#0088bb'); grd.addColorStop(1, '#ffffff'); }
            else if (CONFIG.palette === 3) { grd.addColorStop(0, '#000000'); grd.addColorStop(0.3, '#880000'); grd.addColorStop(0.6, '#ff8800'); grd.addColorStop(1, '#ffffaa'); }
            else if (CONFIG.palette === 4) { grd.addColorStop(0, '#000000'); grd.addColorStop(0.3, '#004444'); grd.addColorStop(0.6, '#00cccc'); grd.addColorStop(1, '#ffffff'); }
            else if (CONFIG.palette === 5) { grd.addColorStop(0, '#000000'); grd.addColorStop(1, '#ffffff'); }
            else if (CONFIG.palette === 6) { grd.addColorStop(0, '#30123b'); grd.addColorStop(0.2, '#4686fb'); grd.addColorStop(0.4, '#1ae4b6'); grd.addColorStop(0.6, '#f9f871'); grd.addColorStop(0.8, '#ff6e2e'); grd.addColorStop(1, '#7a0403'); }
        }
        gctx.fillStyle = grd; gctx.fillRect(0,0,w,h);
        
        gl.bindTexture(gl.TEXTURE_2D, gradientTexture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, gradCanvas);
    }
    
    function updateObstacles() {
        // Ensure obstacle canvas matches SIM dimensions, NOT window dimensions
        if(obstacleCanvas.width !== CONFIG.simWidth || obstacleCanvas.height !== CONFIG.simHeight) {
            obstacleCanvas.width = CONFIG.simWidth;
            obstacleCanvas.height = CONFIG.simHeight;
        }
        
        // Clear with Black (Empty)
        obsCtx.fillStyle = 'black';
        obsCtx.fillRect(0, 0, CONFIG.simWidth, CONFIG.simHeight);
        
        // Draw Border
        obsCtx.fillStyle = 'white';
        obsCtx.fillRect(0, 0, CONFIG.simWidth, 1);
        obsCtx.fillRect(0, CONFIG.simHeight-1, CONFIG.simWidth, 1);
        obsCtx.fillRect(0, 0, 1, CONFIG.simHeight);
        obsCtx.fillRect(CONFIG.simWidth-1, 0, 1, CONFIG.simHeight);

        // Shapes
        obsCtx.strokeStyle = 'white'; obsCtx.lineWidth = 2;
        EDITOR.shapes.forEach(shape => {
            if(shape.points.length < 2) return;
            obsCtx.beginPath();
            
            // Coordinate Mapping Logic:
            // 1. World Space is 0..1 (Normalized)
            // 2. Canvas Space is Top-Left (0,0)
            // 3. WebGL Texture Space is Bottom-Left (0,0) IF flipY is false.
            // 4. We want visual Top to correspond to Physics Top.
            // 5. Solution: Invert Y when drawing to canvas (1-y).
            //    Then upload with flipY=true so Canvas Top becomes Texture Top.
            
            let x0 = (shape.points[0].x / CONFIG.aspectRatio) * CONFIG.simWidth;
            let y0 = (1.0 - shape.points[0].y) * CONFIG.simHeight;
            
            obsCtx.moveTo(x0, y0);
            
            for(let i=1; i<shape.points.length; i++) {
                let xi = (shape.points[i].x / CONFIG.aspectRatio) * CONFIG.simWidth;
                let yi = (1.0 - shape.points[i].y) * CONFIG.simHeight;
                obsCtx.lineTo(xi, yi);
            }
            if(shape.closed) { obsCtx.closePath(); obsCtx.fill(); } else { obsCtx.stroke(); }
        });

        gl.bindTexture(gl.TEXTURE_2D, obstacleTexture);
        
        // CRITICAL FIX: Enable FlipY so Canvas Top aligns with Texture Top
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true); 
        
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, obstacleCanvas);
        
        // Reset state
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false); 
    }

    const blitParams = {
        position: gl.getAttribLocation(programs.advect, 'aPosition'),
        quadBuffer: gl.createBuffer()
    };
    gl.bindBuffer(gl.ARRAY_BUFFER, blitParams.quadBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);

    function blit(destFBO) {
        gl.bindFramebuffer(gl.FRAMEBUFFER, destFBO ? destFBO.fbo : null);
        gl.viewport(0, 0, destFBO ? destFBO.width : canvas.width, destFBO ? destFBO.height : canvas.height);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }

    const EDITOR = {
        mode: 'select',
        shapes: [], emitters: [],
        currentShape: null, hoverPoint: null, selectedShape: null,
        // Multi-selection
        selectedPoints: [], // {shape, index}
        selectedEmitters: [], // indices
        snapping: true, gridSize: 0.02,
        
        // View transform state
        zoom: 1.0,
        pan: { x: 0, y: 0 },
        isPanning: false,
        isBoxSelecting: false,
        boxStart: null,
        draggingSelection: false,
        draggingEmitters: false,
        movingSelection: false, // new: move whole selected shapes / objects
        dragLast: null,
        lastMouse: { x: 0, y: 0 },
        
        screenToWorld: (x, y) => {
            const rect = canvas.getBoundingClientRect();
            // 1. Normalize screen coordinates to 0..1 (Y inverted for standard Cartesian)
            let nx = (x - rect.left) / rect.width;
            let ny = 1.0 - (y - rect.top) / rect.height;
            
            // 2. Apply aspect ratio to X
            nx *= CONFIG.aspectRatio;
            
            // 3. Apply Zoom and Pan
            let wx = (nx / EDITOR.zoom) - EDITOR.pan.x;
            let wy = (ny / EDITOR.zoom) - EDITOR.pan.y;
            
            return { x: wx, y: wy };
        },
        
        snap: (val) => { return EDITOR.snapping ? Math.round(val / EDITOR.gridSize) * EDITOR.gridSize : val; },
        getHover: (m) => {
            const dist = 0.02 / EDITOR.zoom;
            // Emitters first
            for(let i=0;i<EDITOR.emitters.length;i++){
                let e = EDITOR.emitters[i];
                let dx = e.x - m.x; let dy = e.y - m.y;
                if(Math.sqrt(dx*dx + dy*dy) < Math.max(0.02, e.size || e.radius)/EDITOR.zoom) return { type:'emitter', index:i, emitter:e };
            }
            for(let s of EDITOR.shapes) {
                for(let i=0; i<s.points.length; i++) {
                    let p = s.points[i];
                    let dx = p.x - m.x; let dy = p.y - m.y;
                    if(Math.sqrt(dx*dx + dy*dy) < dist) return { shape: s, index: i, type: 'point' };
                }
            }
            return null;
        },

        isPointSelected: (shape, idx) => { return EDITOR.selectedPoints.some(sp => sp.shape === shape && sp.index === idx); },
        togglePointSelection: (shape, idx) => {
            let found = EDITOR.selectedPoints.findIndex(sp => sp.shape === shape && sp.index === idx);
            if(found >= 0) EDITOR.selectedPoints.splice(found,1);
            else EDITOR.selectedPoints.push({shape, index: idx});
        },

        clearSelection: () => { EDITOR.selectedPoints = []; EDITOR.selectedEmitters = []; EDITOR.selectedShape = null; EDITOR.selectedPointIndex = -1; },

        boxSelectPoints: (a,b, add=false) => {
            if(!add) EDITOR.selectedPoints = [];
            if(!add) EDITOR.selectedEmitters = [];
            const x0 = Math.min(a.x,b.x), x1 = Math.max(a.x,b.x), y0 = Math.min(a.y,b.y), y1 = Math.max(a.y,b.y);
            for(const s of EDITOR.shapes){
                for(let i=0;i<s.points.length;i++){
                    let p = s.points[i];
                    if(p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1){
                        if(!EDITOR.selectedPoints.some(sp => sp.shape===s && sp.index===i)) EDITOR.selectedPoints.push({shape:s,index:i});
                    }
                }
            }
            for(let i=0;i<EDITOR.emitters.length;i++){
                let e = EDITOR.emitters[i];
                if(e.x >= x0 && e.x <= x1 && e.y >= y0 && e.y <= y1){
                    if(!EDITOR.selectedEmitters.includes(i)) EDITOR.selectedEmitters.push(i);
                }
            }
        },

        getSelectedEmitter: () => { if(EDITOR.selectedEmitters.length === 1) return EDITOR.emitters[EDITOR.selectedEmitters[0]]; return null; }
    };

    let mouse = { x: 0, y: 0, down: false };

    // --- Interaction Event Handlers ---

    // Emitter popup helper (moved here so it's available before handlers)
    function showEmitterPopup(screenX, screenY) {
        const popup = document.getElementById('emitter-popup');
        if(!popup) return;
        popup.style.left = Math.min(window.innerWidth - popup.offsetWidth - 10, Math.max(10, screenX + 10)) + 'px';
        popup.style.top = Math.min(window.innerHeight - popup.offsetHeight - 10, Math.max(10, screenY + 10)) + 'px';
        popup.style.display = 'block';
        // populate
        const idx = EDITOR.selectedEmitters && EDITOR.selectedEmitters.length === 1 ? EDITOR.selectedEmitters[0] : null;
        if(idx === null) return;
        popup.dataset.emIndex = idx;
        const em = EDITOR.emitters[idx];
        document.getElementById('em-shape').value = em.shape || 'circle';
        document.getElementById('sl-em-size').value = em.size || em.radius || 0.05; document.getElementById('val-em-size').innerText = (em.size||em.radius||0.05).toFixed(3);
        document.getElementById('em-rect-w').value = em.width || em.size || 0.05; document.getElementById('em-rect-h').value = em.height || em.size || 0.05;
        document.getElementById('sl-em-spread').value = em.spread || 30; document.getElementById('val-em-spread').innerText = (em.spread||30) + '°';
        document.getElementById('sl-em-angle-popup').value = em.angle || 0; document.getElementById('val-em-angle-popup').innerText = (em.angle||0).toFixed(0) + '°';
        document.getElementById('sl-em-force-popup').value = em.force || em.speed || 0; document.getElementById('val-em-force-popup').innerText = (em.force||em.speed||0).toFixed(2);
        document.getElementById('sl-em-amount-popup').value = em.amount || em.rate || 1.0; document.getElementById('val-em-amount-popup').innerText = (em.amount||em.rate||1.0).toFixed(2);
        document.getElementById('sl-em-pressure-popup').value = em.pressure || 0.0; document.getElementById('val-em-pressure-popup').innerText = (em.pressure||0.0).toFixed(2);
        const shape = em.shape || 'circle';
        document.getElementById('em-rect-dims').style.display = (shape === 'rect') ? 'block' : 'none';
        document.getElementById('em-cone').style.display = (shape === 'cone') ? 'block' : 'none';
        // hide sidebar controls if any
        const toolbar = document.getElementById('emitter-controls-toolbar'); if(toolbar) toolbar.style.display = 'none';
    }
    function hideEmitterPopup() { const popup = document.getElementById('emitter-popup'); if(!popup) return; popup.style.display = 'none'; popup.dataset.emIndex = ''; const toolbar = document.getElementById('emitter-controls-toolbar'); if(toolbar) toolbar.style.display = 'block'; }

    // 1. Zoom
    uiCanvas.addEventListener('wheel', e => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const mouseNx = (e.clientX - rect.left) / rect.width;
        const mouseNy = 1.0 - (e.clientY - rect.top) / rect.height;
        const nx = mouseNx * CONFIG.aspectRatio;
        const ny = mouseNy;

        const oldZoom = EDITOR.zoom;
        const zoomFactor = 1 - Math.sign(e.deltaY) * 0.1; // 10% per wheel tick
        const newZoom = Math.max(0.1, Math.min(10.0, oldZoom * zoomFactor));

        // World coordinate under cursor before zoom
        const worldX = nx / oldZoom - EDITOR.pan.x;
        const worldY = ny / oldZoom - EDITOR.pan.y;

        // Update zoom and pan so the point under cursor stays fixed
        EDITOR.zoom = newZoom;
        EDITOR.pan.x = nx / newZoom - worldX;
        EDITOR.pan.y = ny / newZoom - worldY;

        drawUI();
    }, { passive: false });

    uiCanvas.addEventListener('mousedown', e => {
        // Panning check (Middle mouse or Alt+Left)
        if(e.button === 1 || (e.button === 0 && e.altKey)) {
            EDITOR.isPanning = true;
            EDITOR.lastMouse = { x: e.clientX, y: e.clientY };
            return;
        }

        // Right-click: context menu and selection toggles
        if(e.button === 2) {
            e.preventDefault();
            const w = EDITOR.screenToWorld(e.clientX, e.clientY);
            const hit = EDITOR.getHover(w);
            if(hit) {
                if(hit.type === 'emitter') {
                    if(!e.shiftKey && !e.ctrlKey) { EDITOR.selectedEmitters = [hit.index]; EDITOR.selectedPoints = []; EDITOR.selectedShape = null; }
                    else {
                        const idx = EDITOR.selectedEmitters.indexOf(hit.index);
                        if(idx >= 0) EDITOR.selectedEmitters.splice(idx,1); else EDITOR.selectedEmitters.push(hit.index);
                    }
                } else if(hit.type === 'point') {
                    if(!e.shiftKey && !e.ctrlKey) { EDITOR.selectedPoints = [{shape:hit.shape, index:hit.index}]; EDITOR.selectedEmitters = []; }
                    else { EDITOR.togglePointSelection(hit.shape, hit.index); }
                }
            } else {
                if(!e.shiftKey && !e.ctrlKey) EDITOR.clearSelection();
            }
            showCtxMenu(e.clientX, e.clientY);
            drawUI();
            return;
        }

        mouse.down = true;
        let w = EDITOR.screenToWorld(e.clientX, e.clientY);
        let snapped = { x: EDITOR.snap(w.x), y: EDITOR.snap(w.y) };
        
        if (EDITOR.mode === 'poly') {
            if (!EDITOR.currentShape) { EDITOR.currentShape = { points: [snapped], closed: false }; EDITOR.shapes.push(EDITOR.currentShape); }
            else {
                let start = EDITOR.currentShape.points[0];
                let dx = snapped.x - start.x; let dy = snapped.y - start.y;
                let closeThreshold = (EDITOR.snapping ? 0.001 : 0.02) / EDITOR.zoom;
                if (Math.sqrt(dx*dx + dy*dy) < closeThreshold && EDITOR.currentShape.points.length >= 2) { EDITOR.currentShape.closed = true; EDITOR.currentShape = null; }
                else { EDITOR.currentShape.points.push(snapped); }
            }
        } else if (EDITOR.mode === 'rect') {
            EDITOR.currentShape = { points: [snapped, snapped, snapped, snapped], closed: true }; EDITOR.shapes.push(EDITOR.currentShape);
        } else if (EDITOR.mode === 'circle') {
            EDITOR.currentShape = { center: snapped, radius: 0, points: [], closed: true, type: 'circle' }; EDITOR.shapes.push(EDITOR.currentShape);
        } else if (EDITOR.mode === 'move') {
            // Move whole selection or shape
            const hit = EDITOR.getHover(w);
            // If clicked on an emitter, start dragging emitters
            if(hit && hit.type === 'emitter') {
                EDITOR.selectedEmitters = [hit.index]; EDITOR.draggingEmitters = true; EDITOR.dragLast = w; EDITOR.movingSelection = false;
            }
            // If clicked on a point, but user wants to move entire shape, select shape
            else {
                // If no explicit selection, try to find a shape containing the point
                if(EDITOR.selectedPoints.length === 0 && EDITOR.selectedEmitters.length === 0) {
                    for(let s of EDITOR.shapes) {
                        if(pointInPolygon(w, s.points)) { EDITOR.selectedShape = s; break; }
                    }
                }
                // Start moving either selected points or entire selected shape
                EDITOR.movingSelection = true; EDITOR.dragLast = w;
            }
        } else if (EDITOR.mode === 'select') {
            const hit = EDITOR.getHover(w);
            // Click on emitter
            if(hit && hit.type === 'emitter') {
                if(e.shiftKey || e.ctrlKey) {
                    const idx = EDITOR.selectedEmitters.indexOf(hit.index);
                    if(idx >= 0) EDITOR.selectedEmitters.splice(idx,1); else EDITOR.selectedEmitters.push(hit.index);
                } else {
                    EDITOR.selectedEmitters = [hit.index]; EDITOR.selectedPoints = []; EDITOR.selectedShape = null; EDITOR.selectedPointIndex = -1;
                    EDITOR.draggingEmitters = true; EDITOR.dragLast = w;
                }
            }
            // Click on point
            else if(hit && hit.type === 'point') {
                if(e.shiftKey || e.ctrlKey) { EDITOR.togglePointSelection(hit.shape, hit.index); }
                else { EDITOR.selectedPoints = [{shape:hit.shape, index:hit.index}]; EDITOR.selectedEmitters = []; EDITOR.selectedShape = hit.shape; EDITOR.selectedPointIndex = hit.index; EDITOR.draggingSelection = true; EDITOR.dragLast = w; }
            }
            // Empty space => start box select
            else {
                if(!e.shiftKey && !e.ctrlKey) EDITOR.clearSelection();
                EDITOR.isBoxSelecting = true; EDITOR.boxStart = w;
            }
        } else if (EDITOR.mode === 'emitter') {
            const newEm = makeEmitterDefaults({ x: snapped.x, y: snapped.y });
            createEmitter(newEm);
            EDITOR.selectedEmitters = [EDITOR.emitters.length - 1];
            const sp = worldToScreen(EDITOR.emitters[EDITOR.emitters.length - 1]);
            showEmitterPopup(sp.x, sp.y);
        }
        updateObstacles();
        drawUI();
    });

    uiCanvas.addEventListener('mousemove', e => {
        // Panning Logic
        if(EDITOR.isPanning) {
            let dx = e.clientX - EDITOR.lastMouse.x;
            let dy = e.clientY - EDITOR.lastMouse.y; // Screen Y goes down
            
            let dNx = (dx / uiCanvas.width) * CONFIG.aspectRatio;
            let dNy = -(dy / uiCanvas.height); // Invert Y
            
            EDITOR.pan.x += dNx / EDITOR.zoom;
            EDITOR.pan.y += dNy / EDITOR.zoom;
            
            EDITOR.lastMouse = { x: e.clientX, y: e.clientY };
            drawUI();
            return;
        }

        let raw = EDITOR.screenToWorld(e.clientX, e.clientY);
        mouse.x = raw.x; mouse.y = raw.y;
        let w = { x: EDITOR.snap(raw.x), y: EDITOR.snap(raw.y) };

        if (EDITOR.isBoxSelecting && mouse.down) {
            // Just update UI rectangle
            drawUI();
            return;
        }

        if (mouse.down) {
            // Move whole selection (shapes and/or emitters)
            if (EDITOR.movingSelection) {
                let dx = raw.x - EDITOR.dragLast.x; let dy = raw.y - EDITOR.dragLast.y;
                // Move selected points if any
                if (EDITOR.selectedPoints.length > 0) {
                    EDITOR.selectedPoints.forEach(sp => {
                        sp.shape.points[sp.index].x = EDITOR.snap(sp.shape.points[sp.index].x + dx);
                        sp.shape.points[sp.index].y = EDITOR.snap(sp.shape.points[sp.index].y + dy);
                    });
                }
                // Move entire selected shape if set and no individual points
                else if (EDITOR.selectedShape) {
                    EDITOR.selectedShape.points.forEach(p => {
                        p.x = EDITOR.snap(p.x + dx);
                        p.y = EDITOR.snap(p.y + dy);
                    });
                }
                // Move any selected emitters
                if (EDITOR.selectedEmitters.length > 0) {
                    EDITOR.selectedEmitters.forEach(i => {
                        EDITOR.emitters[i].x = EDITOR.snap(EDITOR.emitters[i].x + dx);
                        EDITOR.emitters[i].y = EDITOR.snap(EDITOR.emitters[i].y + dy);
                    });
                }
                EDITOR.dragLast = raw; updateObstacles(); drawUI();
                return;
            }

            else if (EDITOR.draggingSelection && EDITOR.selectedPoints.length > 0) {
                let dx = raw.x - EDITOR.dragLast.x; let dy = raw.y - EDITOR.dragLast.y;
                EDITOR.selectedPoints.forEach(sp => {
                    sp.shape.points[sp.index].x = EDITOR.snap(sp.shape.points[sp.index].x + dx);
                    sp.shape.points[sp.index].y = EDITOR.snap(sp.shape.points[sp.index].y + dy);
                });
                EDITOR.dragLast = raw; updateObstacles();
            }
            else if (EDITOR.draggingEmitters && EDITOR.selectedEmitters.length > 0) {
                let dx = raw.x - EDITOR.dragLast.x; let dy = raw.y - EDITOR.dragLast.y;
                EDITOR.selectedEmitters.forEach(i => {
                    EDITOR.emitters[i].x = EDITOR.snap(EDITOR.emitters[i].x + dx);
                    EDITOR.emitters[i].y = EDITOR.snap(EDITOR.emitters[i].y + dy);
                });
                EDITOR.dragLast = raw; drawUI(); updateObstacles();
            }
            else if (EDITOR.mode === 'rect' && EDITOR.currentShape) {
                let p0 = EDITOR.currentShape.points[0];
                EDITOR.currentShape.points[1] = { x: p0.x, y: w.y };
                EDITOR.currentShape.points[2] = { x: w.x, y: w.y };
                EDITOR.currentShape.points[3] = { x: w.x, y: p0.y };
                updateObstacles();
            }
            else if (EDITOR.mode === 'circle' && EDITOR.currentShape) {
                let center = EDITOR.currentShape.center;
                let dx = w.x - center.x;
                let dy = w.y - center.y;
                let r = Math.sqrt(dx*dx + dy*dy);
                EDITOR.currentShape.radius = r;
                let segments = 32; EDITOR.currentShape.points = [];
                for(let i=0; i<segments; i++) {
                    let theta = (i / segments) * Math.PI * 2;
                    EDITOR.currentShape.points.push({ x: center.x + Math.cos(theta) * r, y: center.y + Math.sin(theta) * r });
                }
                updateObstacles();
            }
        }
        EDITOR.hoverPoint = EDITOR.getHover(raw);
        updateProbe(raw.x, raw.y);
        drawUI();
    });

    uiCanvas.addEventListener('mouseup', () => { 
        mouse.down = false; 
        EDITOR.isPanning = false;
        // Finish drag moves
        EDITOR.draggingSelection = false; EDITOR.draggingEmitters = false; EDITOR.movingSelection = false; EDITOR.dragLast = null;
        if (EDITOR.isBoxSelecting) {
            let a = EDITOR.boxStart; let b = { x: mouse.x, y: mouse.y };
            EDITOR.boxSelectPoints(a,b, false);
            EDITOR.isBoxSelecting = false; EDITOR.boxStart = null;
        }
        EDITOR.selectedPointIndex = -1;
        if(EDITOR.mode === 'rect' || EDITOR.mode === 'circle') { EDITOR.currentShape = null; }
        // If exactly one emitter selected, show popup near it
        if(EDITOR.selectedEmitters.length === 1) {
            const idx = EDITOR.selectedEmitters[0];
            const sp = worldToScreen(EDITOR.emitters[idx]);
            showEmitterPopup(sp.x, sp.y);
        } else {
            hideEmitterPopup();
        }
        drawUI();
    });

    window.addEventListener('keydown', e => {
        if (e.key === 'Enter' && EDITOR.mode === 'poly' && EDITOR.currentShape) {
            EDITOR.currentShape.closed = true; EDITOR.currentShape = null; updateObstacles();
        }
        if (e.key === 'Delete' && EDITOR.selectedShape) {
            EDITOR.shapes = EDITOR.shapes.filter(s => s !== EDITOR.selectedShape);
            EDITOR.selectedShape = null; updateObstacles();
        }
        if(e.key === 'v') setMode('select');
        if(e.key === 'p') setMode('poly');
        if(e.key === 'r') setMode('rect'); 
        if(e.key === 'c') setMode('circle'); 
        if(e.key === 'e') setMode('emitter');
        if(e.key === 'm') setMode('move');
    });

    function setMode(m) {
        EDITOR.mode = m;
        document.querySelectorAll('#toolbar button').forEach(b => b.classList.remove('active'));
        if(m === 'select') document.getElementById('btn-select').classList.add('active');
        if(m === 'poly') document.getElementById('btn-draw-poly').classList.add('active');
        if(m === 'rect') document.getElementById('btn-draw-rect').classList.add('active');
        if(m === 'circle') document.getElementById('btn-draw-circ').classList.add('active');
        if(m === 'emitter') document.getElementById('btn-emitter').classList.add('active');
        if(m === 'move') document.getElementById('btn-move').classList.add('active');
    }

    function worldToScreen(p) {
        // Inverse of screenToWorld
        // wx = (nx / zoom) - pan.x  => nx = (wx + pan.x) * zoom
        // wy = (ny / zoom) - pan.y  => ny = (wy + pan.y) * zoom
        
        let nx = (p.x + EDITOR.pan.x) * EDITOR.zoom;
        let ny = (p.y + EDITOR.pan.y) * EDITOR.zoom;
        
        // Remove aspect ratio from X, Invert Y
        // nx = (x - left)/width * aspect => x = (nx / aspect) * width + left
        let x = (nx / CONFIG.aspectRatio) * uiCanvas.width;
        let y = (1.0 - ny) * uiCanvas.height;
        
        return { x: x, y: y }; 
    }

    function drawUI() {
        ctx.clearRect(0,0,uiCanvas.width, uiCanvas.height);
        
        if(EDITOR.snapping) {
            ctx.strokeStyle = 'rgba(255,255,255,0.05)'; ctx.lineWidth = 1;
            let pMin = EDITOR.screenToWorld(0, uiCanvas.height); // Bottom-Left
            let pMax = EDITOR.screenToWorld(uiCanvas.width, 0); // Top-Right
            let startX = Math.floor(pMin.x / EDITOR.gridSize) * EDITOR.gridSize;
            let startY = Math.floor(pMin.y / EDITOR.gridSize) * EDITOR.gridSize;
            ctx.beginPath();
            for(let x = startX; x < pMax.x; x += EDITOR.gridSize) {
                let p1 = worldToScreen({x: x, y: pMin.y});
                let p2 = worldToScreen({x: x, y: pMax.y});
                ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
            }
            for(let y = startY; y < pMax.y; y += EDITOR.gridSize) {
                let p1 = worldToScreen({x: pMin.x, y: y});
                let p2 = worldToScreen({x: pMax.x, y: y});
                ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
            }
            ctx.stroke();
        }
        
        if(CONFIG.showVectors) drawVectors();

        // Draw shapes and points
        EDITOR.shapes.forEach(s => {
            ctx.beginPath();
            if(s.points.length > 0) {
                let p0 = worldToScreen(s.points[0]); ctx.moveTo(p0.x, p0.y);
                for(let i=1; i<s.points.length; i++) { let p = worldToScreen(s.points[i]); ctx.lineTo(p.x, p.y); }
                if(s.closed) ctx.closePath();
            }
            ctx.strokeStyle = (s === EDITOR.selectedShape) ? '#3b82f6' : 'rgba(255,255,255,0.5)';
            ctx.lineWidth = 2; ctx.stroke();
            if(s.closed) { ctx.fillStyle = 'rgba(255,255,255,0.1)'; ctx.fill(); }
            
            s.points.forEach((p, idx) => {
                let sp = worldToScreen(p);
                let sel = EDITOR.isPointSelected(s, idx);
                ctx.fillStyle = sel ? '#f59e0b' : ((s === EDITOR.selectedShape) ? '#3b82f6' : '#888');
                ctx.fillRect(sp.x-3, sp.y-3, 6, 6);
            });
        });

        // Draw emitters with shapes
        EDITOR.emitters.forEach((e, i) => {
            const sp = worldToScreen(e);
            const sel = EDITOR.selectedEmitters.includes(i);
            ctx.save();
            ctx.translate(sp.x, sp.y);
            const ang = ((e.angle || 0) * Math.PI / 180.0);
            ctx.rotate(-ang); // invert Y for canvas coordinate
            if(e.shape === 'rect') {
                const w = (e.width || e.size || 0.05);
                const h = (e.height || e.size || 0.05);
                const edgeP = worldToScreen({x:e.x + w, y:e.y});
                const pixelW = Math.abs(edgeP.x - sp.x);
                const pixelH = Math.abs(worldToScreen({x:e.x, y:e.y + h}).y - sp.y);
                ctx.fillStyle = sel ? 'rgba(245,158,11,0.75)' : 'rgba(0,255,0,0.5)';
                ctx.fillRect(-pixelW, -pixelH, pixelW*2, pixelH*2);
                ctx.strokeStyle = sel ? '#f59e0b' : '#000';
                ctx.lineWidth = 2; ctx.strokeRect(-pixelW, -pixelH, pixelW*2, pixelH*2);
            } else if(e.shape === 'cone') {
                const length = e.size || e.radius || 0.05;
                const spread = (e.spread || 30) * Math.PI / 180.0;
                const pxLen = Math.abs(worldToScreen({x:e.x + Math.cos(ang)*length, y:e.y + Math.sin(ang)*length}).x - sp.x);
                ctx.beginPath(); ctx.moveTo(0,0); ctx.arc(0,0, pxLen, -spread/2, spread/2); ctx.closePath();
                ctx.fillStyle = sel ? 'rgba(245,158,11,0.4)' : 'rgba(0,255,0,0.2)'; ctx.fill();
                ctx.strokeStyle = sel ? '#f59e0b' : '#000'; ctx.lineWidth = 2; ctx.stroke();
            } else {
                const edge = worldToScreen({x: e.x + (e.size || e.radius || 0.05), y: e.y});
                const rp = Math.abs(edge.x - sp.x);
                ctx.beginPath(); ctx.fillStyle = sel ? '#f59e0b' : '#0f0'; ctx.arc(0,0, Math.max(4, rp), 0, Math.PI*2); ctx.fill();

                // rotation indicator arrow scaled by force
                const arrowLen = Math.max(8, rp * 1.2 * (e.force || 1.0));
                ctx.strokeStyle = sel ? '#f59e0b' : '#000'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(arrowLen,0); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(arrowLen,0); ctx.lineTo(arrowLen-6,-4); ctx.lineTo(arrowLen-6,4); ctx.closePath(); ctx.fillStyle = sel ? '#f59e0b' : '#000'; ctx.fill();

                if(sel) { ctx.lineWidth = 2; ctx.strokeStyle = '#f59e0b'; ctx.beginPath(); ctx.arc(0,0, Math.max(4, rp)+2, 0, Math.PI*2); ctx.stroke(); }
            }
            ctx.restore();
        });

        // Box selection
        if(EDITOR.isBoxSelecting && EDITOR.boxStart) {
            let a = worldToScreen(EDITOR.boxStart);
            let b = worldToScreen({x: mouse.x, y: mouse.y});
            let x = Math.min(a.x, b.x), y = Math.min(a.y, b.y);
            let w = Math.abs(a.x - b.x), h = Math.abs(a.y - b.y);
            ctx.strokeStyle = '#3b82f6'; ctx.fillStyle = 'rgba(59,130,246,0.06)'; ctx.lineWidth = 1; ctx.strokeRect(x,y,w,h); ctx.fillRect(x,y,w,h);
        }

        if (EDITOR.mode === 'poly' && EDITOR.currentShape) {
            let s = EDITOR.currentShape; 
            ctx.beginPath();
            let p0 = worldToScreen(s.points[0]); ctx.moveTo(p0.x, p0.y);
            for(let i=1; i<s.points.length; i++) { let p = worldToScreen(s.points[i]); ctx.lineTo(p.x, p.y); }
            let nextP = { x: EDITOR.snap(mouse.x), y: EDITOR.snap(mouse.y) };
            let start = s.points[0];
            let dx = nextP.x - start.x; let dy = nextP.y - start.y;
            let closeThreshold = (EDITOR.snapping ? 0.001 : 0.02) / EDITOR.zoom;
            let isClosing = Math.sqrt(dx*dx + dy*dy) < closeThreshold && s.points.length >= 2;
            let target = isClosing ? start : nextP;
            let sTarget = worldToScreen(target);
            ctx.lineTo(sTarget.x, sTarget.y);
            ctx.strokeStyle = '#ffff00'; ctx.stroke();
            if(isClosing) { ctx.fillStyle = 'rgba(255, 255, 0, 0.2)'; ctx.fill(); ctx.beginPath(); ctx.arc(sTarget.x, sTarget.y, 6, 0, Math.PI*2); ctx.fillStyle='#ffff00'; ctx.fill(); }
        }
        
        let cursor = worldToScreen({x: EDITOR.snap(mouse.x), y: EDITOR.snap(mouse.y)});
        ctx.strokeStyle = 'white'; ctx.strokeRect(cursor.x-5, cursor.y-5, 10, 10);
    }

    const pixelBuf = new Float32Array(4); 
    function readTextureValue(fbo, x, y) {
        // x in 0..aspect, y in 0..1 (World)
        let u = x / CONFIG.aspectRatio;
        let v = y; // Match world Y to texture V (bottom-left origin)
        if(u < 0 || u > 1 || v < 0 || v > 1) return [0,0,0,0];
        
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.fbo);
        const ix = Math.floor(u * CONFIG.simWidth);
        const iy = Math.floor(v * CONFIG.simHeight);
        gl.readPixels(ix, iy, 1, 1, gl.RGBA, gl.FLOAT, pixelBuf);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        return pixelBuf;
    }

    function showCtxMenu(x,y) {
        const el = document.getElementById('ctx-menu');
        el.style.left = x + 'px'; el.style.top = y + 'px'; el.style.display = 'block';
    }
    function hideCtxMenu() { const el = document.getElementById('ctx-menu'); if(el) el.style.display = 'none'; }

    function deleteSelectedItems() {
        // Delete points
        if(EDITOR.selectedPoints.length > 0) {
            // Group deletions by shape
            const groups = new Map();
            EDITOR.selectedPoints.forEach(sp => {
                if(!groups.has(sp.shape)) groups.set(sp.shape, []);
                groups.get(sp.shape).push(sp.index);
            });
            groups.forEach((indices, shape) => {
                indices.sort((a,b)=>b-a); // delete descending
                indices.forEach(idx => { shape.points.splice(idx,1); });
            });
            // Remove empty shapes
            EDITOR.shapes = EDITOR.shapes.filter(s => s.points.length >= 2);
            EDITOR.selectedPoints = [];
            updateObstacles();
        }
        // Delete emitters
        if(EDITOR.selectedEmitters.length > 0) {
            EDITOR.selectedEmitters.sort((a,b)=>b-a);
            EDITOR.selectedEmitters.forEach(i => { EDITOR.emitters.splice(i,1); });
            EDITOR.selectedEmitters = [];
            updateObstacles();
            hideEmitterPopup();
        }
        drawUI();
    }

    function updateEmitterUI() {
        // Open popup when a single emitter is selected, otherwise hide popup
        if(EDITOR.selectedEmitters.length === 1) {
            const idx = EDITOR.selectedEmitters[0];
            const sp = worldToScreen(EDITOR.emitters[idx]);
            showEmitterPopup(sp.x, sp.y);
        } else {
            hideEmitterPopup();
        }
    }

    document.addEventListener('click', hideCtxMenu);
    
    function updateProbe(wx, wy) {
        document.getElementById('data-x').innerText = wx.toFixed(2);
        document.getElementById('data-y').innerText = (1.0-wy).toFixed(2);
        let d = readTextureValue(density.read, wx, wy);
        let v = readTextureValue(velocity.read, wx, wy);
        let p = readTextureValue(pressure.read, wx, wy);
        let c = readTextureValue(curl, wx, wy); 
        document.getElementById('data-rho').innerText = d[0].toFixed(2);
        document.getElementById('data-p').innerText = p[0].toFixed(2);
        document.getElementById('data-vx').innerText = v[0].toFixed(2);
        document.getElementById('data-vy').innerText = v[1].toFixed(2);
        document.getElementById('data-speed').innerText = Math.sqrt(v[0]*v[0] + v[1]*v[1]).toFixed(2);
        document.getElementById('data-curl').innerText = c[0].toFixed(2);
        document.getElementById('data-min').innerText = currentMin.toFixed(2);
        document.getElementById('data-max').innerText = currentMax.toFixed(2);
    }
    
    function drawVectors() {
        // Uniform grid density
        const spacing = 20; // px
        const gridX = Math.floor(uiCanvas.width / spacing);
        const gridY = Math.floor(uiCanvas.height / spacing);
        const arrowLen = 12;
        const headLen = 3;
        
        ctx.lineWidth = 1;
        gl.bindFramebuffer(gl.FRAMEBUFFER, velocity.read.fbo);
        const w = CONFIG.simWidth;
        const h = CONFIG.simHeight;
        const fullBuf = new Float32Array(w * h * 4);
        gl.readPixels(0, 0, w, h, gl.RGBA, gl.FLOAT, fullBuf);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        
        for(let y=0; y<gridY; y++) {
            for(let x=0; x<gridX; x++) {
                // Screen coords
                let sx = (x + 0.5) * spacing;
                let sy = (y + 0.5) * spacing;
                
                // Get World coords for this screen pixel to lookup in simulation
                // Use screenToWorld logic
                let wPos = EDITOR.screenToWorld(sx, sy);
                
                // Then to UV
                let u = wPos.x / CONFIG.aspectRatio;
                let v = wPos.y; 
                
                if (u < 0 || u > 1 || v < 0 || v > 1) continue;

                const ix = Math.floor(u * w);
                const iy = Math.floor(v * h);
                const idx = (iy * w + ix) * 4;
                
                const vx = fullBuf[idx];
                const vy = fullBuf[idx+1];
                const speed = Math.sqrt(vx*vx + vy*vy);
                
                if(speed > 0.01) {
                    const nx = vx / speed;
                    const ny = vy / speed;
                    const ex = sx + nx * arrowLen;
                    const ey = sy - ny * arrowLen; // Flip Y for canvas
                    
                    const t = Math.min(speed / 2.0, 1.0);
                    const hue = (1.0 - t) * 240; 
                    const color = `hsl(${hue}, 100%, 50%)`;
                    
                    ctx.strokeStyle = color;
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.moveTo(sx, sy);
                    ctx.lineTo(ex, ey);
                    ctx.stroke();
                    
                    const angle = Math.atan2(-ny, nx);
                    ctx.beginPath();
                    ctx.moveTo(ex, ey);
                    ctx.lineTo(ex - headLen * Math.cos(angle - Math.PI/6), ey - headLen * Math.sin(angle - Math.PI/6));
                    ctx.lineTo(ex - headLen * Math.cos(angle + Math.PI/6), ey - headLen * Math.sin(angle + Math.PI/6));
                    ctx.lineTo(ex, ey);
                    ctx.fill();
                }
            }
        }
    }

    const sampleBuf = new Float32Array(32 * 32 * 4);
    function updateAutoExposure() {
        if(!CONFIG.autoScale) {
            currentMin += (CONFIG.valMin - currentMin) * 0.1;
            currentMax += (CONFIG.valMax - currentMax) * 0.1;
            return;
        }
        let p = programs.copy;
        gl.useProgram(p);
        gl.viewport(0,0,32,32);
        
        let targetTex;
        let mode = 0; 
        if (CONFIG.visMode === 0) { targetTex = density.read.texture; mode = 2; }
        else if (CONFIG.visMode === 1) { targetTex = velocity.read.texture; mode = 1; }
        else if (CONFIG.visMode === 2) { targetTex = pressure.read.texture; mode = 0; }
        else { targetTex = curl.texture; mode = 0; }

        gl.uniform1i(gl.getUniformLocation(p, "uTexture"), 0);
        gl.uniform1i(gl.getUniformLocation(p, "uMode"), mode);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, targetTex);
        blit(sampleFBO);

        gl.bindFramebuffer(gl.FRAMEBUFFER, sampleFBO.fbo);
        gl.readPixels(0, 0, 32, 32, gl.RGBA, gl.FLOAT, sampleBuf);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        let min = Infinity; let max = -Infinity;
        for(let i=0; i<1024; i++) {
            let val = sampleBuf[i*4];
            if(val < min) min = val;
            if(val > max) max = val;
        }
        if(min === Infinity) { min = 0; max = 1; }
        if(max - min < 0.001) max = min + 0.001; 
        currentMin += (min - currentMin) * 0.05;
        currentMax += (max - currentMax) * 0.05;
    }

    function step(dt) {
        gl.disable(gl.BLEND);
        gl.viewport(0, 0, CONFIG.simWidth, CONFIG.simHeight);
        let effectiveDt = (dt * CONFIG.timeScale) / CONFIG.substeps;
        
        for(let step=0; step<CONFIG.substeps; step++) {
            let p = programs.vorticity; gl.useProgram(p);
            gl.bindBuffer(gl.ARRAY_BUFFER, blitParams.quadBuffer);
            gl.vertexAttribPointer(blitParams.position, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(blitParams.position);
            gl.uniform2f(gl.getUniformLocation(p, "uTexelSize"), 1.0/CONFIG.simWidth, 1.0/CONFIG.simHeight);
            gl.uniform1i(gl.getUniformLocation(p, "uVelocity"), 0);
            gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
            blit(curl);

            p = programs.vorticityForce; gl.useProgram(p);
            gl.uniform2f(gl.getUniformLocation(p, "uTexelSize"), 1.0/CONFIG.simWidth, 1.0/CONFIG.simHeight);
            gl.uniform1i(gl.getUniformLocation(p, "uVelocity"), 0); gl.uniform1i(gl.getUniformLocation(p, "uCurl"), 1);
            gl.uniform1f(gl.getUniformLocation(p, "confinement"), CONFIG.curl);
            gl.uniform1f(gl.getUniformLocation(p, "dt"), effectiveDt);
            gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
            gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, curl.texture);
            blit(velocity.write); velocity.swap();

            p = programs.advect; gl.useProgram(p);
            gl.uniform2f(gl.getUniformLocation(p, "uTexelSize"), 1.0/CONFIG.simWidth, 1.0/CONFIG.simHeight);
            gl.uniform1i(gl.getUniformLocation(p, "uVelocity"), 0); gl.uniform1i(gl.getUniformLocation(p, "uSource"), 0);
            gl.uniform1i(gl.getUniformLocation(p, "uObstacles"), 1);
            gl.uniform1f(gl.getUniformLocation(p, "dt"), effectiveDt);
            gl.uniform1f(gl.getUniformLocation(p, "dissipation"), CONFIG.dissipation);
            gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
            gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, obstacleTexture);
            blit(velocity.write); velocity.swap();

            p = programs.boundary; gl.useProgram(p);
            gl.uniform2f(gl.getUniformLocation(p, "uTexelSize"), 1.0/CONFIG.simWidth, 1.0/CONFIG.simHeight);
            gl.uniform1i(gl.getUniformLocation(p, "uTexture"), 0);
            gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
            blit(velocity.write); velocity.swap();

            p = programs.advect; gl.useProgram(p);
            gl.uniform1i(gl.getUniformLocation(p, "uVelocity"), 0); gl.uniform1i(gl.getUniformLocation(p, "uSource"), 1);
            gl.uniform1i(gl.getUniformLocation(p, "uObstacles"), 2);
            gl.uniform1f(gl.getUniformLocation(p, "dissipation"), CONFIG.decay); 
            gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
            gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, density.read.texture);
            gl.activeTexture(gl.TEXTURE2); gl.bindTexture(gl.TEXTURE_2D, obstacleTexture);
            blit(density.write); density.swap();

            p = programs.splat; gl.useProgram(p);
            const L = p.locs;
            gl.uniform1i(L.uTarget, 0);
            gl.uniform1f(L.aspectRatio, CONFIG.aspectRatio);

            EDITOR.emitters.forEach(e => {
                if(!e.enabled) return;
                const angle = (e.angle || 0) * Math.PI / 180.0;
                const dirx = Math.cos(angle);
                const diry = Math.sin(angle);
                const vx = dirx * (e.force || e.speed || 0);
                const vy = diry * (e.force || e.speed || 0);

                if(e.shape === 'rect') {
                    const w = e.width || e.size || 0.05;
                    const h = e.height || e.size || 0.05;
                    const nx = 3, ny = 2;
                    for(let iy=0; iy<ny; iy++){
                        for(let ix=0; ix<nx; ix++){
                            const fx = (ix/(nx-1)-0.5)*w;
                            const fy = (iy/(ny-1)-0.5)*h;
                            const px = e.x + fx * Math.cos(angle) - fy * Math.sin(angle);
                            const py = e.y + fx * Math.sin(angle) + fy * Math.cos(angle);
                            const rad = Math.max((w+h)/8, 0.001);

                            gl.uniform2f(L.point, px / CONFIG.aspectRatio, py);
                            gl.uniform3f(L.color, vx * (e.force || 1.0), vy * (e.force || 1.0), 0.0);
                            gl.uniform1f(L.radius, rad);
                            gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
                            blit(velocity.write); velocity.swap();

                            gl.uniform3f(L.color, CONFIG.dyeColor[0] * (e.amount || 1.0), CONFIG.dyeColor[1] * (e.amount || 1.0), CONFIG.dyeColor[2] * (e.amount || 1.0));
                            gl.uniform1f(L.radius, rad);
                            gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, density.read.texture);
                            blit(density.write); density.swap();

                            if(Math.abs(e.pressure || 0) > 0.0001) {
                                gl.uniform3f(L.color, (e.pressure||0), 0.0, 0.0);
                                gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, pressure.read.texture);
                                gl.uniform1f(L.radius, rad * 0.5);
                                blit(pressure.write); pressure.swap();
                            }
                        }
                    }
                } else if(e.shape === 'cone') {
                    const length = e.size || e.radius || 0.05;
                    const spread = (e.spread || 30) * Math.PI / 180.0;
                    const steps = 6;
                    for(let sIdx=0; sIdx<steps; sIdx++){
                        const t = (sIdx+1)/steps;
                        const ang = angle + ((((sIdx%2)===0)?1:-1) * (spread * (sIdx/(steps-1))/2));
                        const px = e.x + Math.cos(ang) * length * t;
                        const py = e.y + Math.sin(ang) * length * t;
                        const rad = length * 0.15;

                        gl.uniform2f(L.point, px / CONFIG.aspectRatio, py);
                        gl.uniform3f(L.color, vx * (e.force || 1.0), vy * (e.force || 1.0), 0.0);
                        gl.uniform1f(L.radius, rad);
                        gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
                        blit(velocity.write); velocity.swap();

                        gl.uniform3f(L.color, CONFIG.dyeColor[0] * (e.amount || 1.0), CONFIG.dyeColor[1] * (e.amount || 1.0), CONFIG.dyeColor[2] * (e.amount || 1.0));
                        gl.uniform1f(L.radius, rad);
                        gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, density.read.texture);
                        blit(density.write); density.swap();

                        if(Math.abs(e.pressure || 0) > 0.0001) {
                            gl.uniform3f(L.color, (e.pressure||0), 0.0, 0.0);
                            gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, pressure.read.texture);
                            gl.uniform1f(L.radius, rad * 0.5);
                            blit(pressure.write); pressure.swap();
                        }
                    }
                } else {
                    const rad = e.size || e.radius || 0.005;
                    gl.uniform2f(L.point, e.x / CONFIG.aspectRatio, e.y);
                    gl.uniform3f(L.color, vx * (e.force || 1.0), vy * (e.force || 1.0), 0.0);
                    gl.uniform1f(L.radius, rad);
                    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
                    blit(velocity.write); velocity.swap();

                    gl.uniform3f(L.color, CONFIG.dyeColor[0] * (e.amount || 1.0), CONFIG.dyeColor[1] * (e.amount || 1.0), CONFIG.dyeColor[2] * (e.amount || 1.0));
                    gl.uniform1f(L.radius, rad);
                    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, density.read.texture);
                    blit(density.write); density.swap();

                    if(Math.abs(e.pressure || 0) > 0.0001) {
                        gl.uniform3f(L.color, (e.pressure||0), 0.0, 0.0);
                        gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, pressure.read.texture);
                        gl.uniform1f(L.radius, rad * 0.5);
                        blit(pressure.write); pressure.swap();
                    }
                }
            });

            p = programs.divergence; gl.useProgram(p);
            gl.uniform2f(gl.getUniformLocation(p, "uTexelSize"), 1.0/CONFIG.simWidth, 1.0/CONFIG.simHeight);
            gl.uniform1i(gl.getUniformLocation(p, "uVelocity"), 0); gl.uniform1i(gl.getUniformLocation(p, "uObstacles"), 1);
            gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
            gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, obstacleTexture);
            blit(divergence);

            p = programs.jacobi; gl.useProgram(p);
            gl.uniform2f(gl.getUniformLocation(p, "uTexelSize"), 1.0/CONFIG.simWidth, 1.0/CONFIG.simHeight);
            gl.uniform1i(gl.getUniformLocation(p, "uDivergence"), 0); gl.uniform1i(gl.getUniformLocation(p, "uObstacles"), 2);
            gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, divergence.texture);
            gl.activeTexture(gl.TEXTURE2); gl.bindTexture(gl.TEXTURE_2D, obstacleTexture);
            for(let i=0; i<CONFIG.iterations; i++) {
                gl.uniform1i(gl.getUniformLocation(p, "uPressure"), 1);
                gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, pressure.read.texture);
                blit(pressure.write); pressure.swap();
            }

            p = programs.gradient; gl.useProgram(p);
            gl.uniform2f(gl.getUniformLocation(p, "uTexelSize"), 1.0/CONFIG.simWidth, 1.0/CONFIG.simHeight);
            gl.uniform1i(gl.getUniformLocation(p, "uPressure"), 0);
            gl.uniform1i(gl.getUniformLocation(p, "uVelocity"), 1);
            gl.uniform1i(gl.getUniformLocation(p, "uObstacles"), 2);
            gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, pressure.read.texture);
            gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
            gl.activeTexture(gl.TEXTURE2); gl.bindTexture(gl.TEXTURE_2D, obstacleTexture);
            blit(velocity.write); velocity.swap();

            p = programs.boundary; gl.useProgram(p);
            gl.uniform2f(gl.getUniformLocation(p, "uTexelSize"), 1.0/CONFIG.simWidth, 1.0/CONFIG.simHeight);
            gl.uniform1i(gl.getUniformLocation(p, "uTexture"), 0);
            gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
            blit(velocity.write); velocity.swap();
        }

        updateAutoExposure();

        let p = programs.display; gl.useProgram(p);
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.uniform1i(gl.getUniformLocation(p, "uDensity"), 0);
        gl.uniform1i(gl.getUniformLocation(p, "uVelocity"), 1);
        gl.uniform1i(gl.getUniformLocation(p, "uPressure"), 2);
        gl.uniform1i(gl.getUniformLocation(p, "uCurl"), 3);
        gl.uniform1i(gl.getUniformLocation(p, "uObstacles"), 4);
        gl.uniform1i(gl.getUniformLocation(p, "uGradient"), 5);
        gl.uniform1i(gl.getUniformLocation(p, "uMode"), CONFIG.visMode);
        
        // Transform uniforms for display shader (Pan/Zoom) - use cached locs
        gl.uniform2f(programs.display.locs.uPan, EDITOR.pan.x, EDITOR.pan.y);
        gl.uniform1f(programs.display.locs.uZoom, EDITOR.zoom);
        gl.uniform1f(programs.display.locs.uAspect, CONFIG.aspectRatio);

        gl.uniform1f(programs.display.locs.uMin, currentMin);
        gl.uniform1f(programs.display.locs.uMax, currentMax);
        gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, density.read.texture);
        gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
        gl.activeTexture(gl.TEXTURE2); gl.bindTexture(gl.TEXTURE_2D, pressure.read.texture);
        gl.activeTexture(gl.TEXTURE3); gl.bindTexture(gl.TEXTURE_2D, curl.texture);
        gl.activeTexture(gl.TEXTURE4); gl.bindTexture(gl.TEXTURE_2D, obstacleTexture);
        gl.activeTexture(gl.TEXTURE5); gl.bindTexture(gl.TEXTURE_2D, gradientTexture);
        blit(null);
    }

    function loop() {
        requestAnimationFrame(loop);
        if (canvas.width !== window.innerWidth || canvas.height !== window.innerHeight) {
            canvas.width = window.innerWidth; canvas.height = window.innerHeight;
            uiCanvas.width = window.innerWidth; uiCanvas.height = window.innerHeight;
            // Update aspect ratio for display scaling, but don't reset grid resolution
            CONFIG.aspectRatio = canvas.width / canvas.height;
        }
        step(CONFIG.dt);
        drawUI();
    }

    function initScene() {
        EDITOR.shapes.push({points:[{x:0,y:0},{x:1,y:0},{x:1,y:0.2},{x:0,y:0.2}], closed:true});
        EDITOR.shapes.push({points:[{x:0,y:1},{x:1,y:1},{x:1,y:0.8},{x:0,y:0.8}], closed:true});
        EDITOR.shapes.push({points:[{x:0.4,y:0.4},{x:0.5,y:0.5},{x:0.4,y:0.6}], closed:true});
        createEmitter({x:0.1, y:0.5, shape:'circle', size:0.05, force: CONFIG.inflow, amount:1.0, pressure:0.0, spread:30, angle:0, enabled:true});
        updateObstacles();
        updateGradient();
    }
    
    function resizeSimulation() {
        density = createDoubleFBO(CONFIG.simWidth, CONFIG.simHeight);
        velocity = createDoubleFBO(CONFIG.simWidth, CONFIG.simHeight);
        pressure = createDoubleFBO(CONFIG.simWidth, CONFIG.simHeight);
        divergence = createFBO(CONFIG.simWidth, CONFIG.simHeight);
        curl = createFBO(CONFIG.simWidth, CONFIG.simHeight);
        
        // Recreate texture object for obstacles
        obstacleTexture = gl.createTexture();
        updateObstacles();
    }

    window.addEventListener('load', () => {
        const bind = (id, event, callback) => {
            const el = document.getElementById(id);
            if(el) el[event] = callback;
        };

        bind('btn-select', 'onclick', () => setMode('select'));
        bind('btn-draw-poly', 'onclick', () => setMode('poly'));
        bind('btn-draw-rect', 'onclick', () => setMode('rect')); 
        bind('btn-draw-circ', 'onclick', () => setMode('circle')); 
        bind('btn-emitter', 'onclick', () => setMode('emitter'));
        bind('btn-move', 'onclick', () => setMode('move'));
        bind('btn-fit', 'onclick', () => { EDITOR.zoom = 1.0; EDITOR.pan = {x:0, y:0}; });
        
        bind('chk-snap', 'onchange', (e) => EDITOR.snapping = e.target.checked);
        bind('sl-iter', 'oninput', (e) => { CONFIG.iterations = parseInt(e.target.value); document.getElementById('val-iter').innerText = CONFIG.iterations; });
        bind('sl-diss', 'oninput', (e) => { CONFIG.dissipation = parseFloat(e.target.value); });
        bind('sl-decay', 'oninput', (e) => { CONFIG.decay = parseFloat(e.target.value); });
        bind('sl-vort', 'oninput', (e) => { CONFIG.curl = parseFloat(e.target.value); });
        bind('sl-inflow', 'oninput', (e) => { CONFIG.inflow = parseFloat(e.target.value); });
        bind('col-dye', 'oninput', (e) => {
            let hex = e.target.value;
            let r = parseInt(hex.substr(1,2),16)/255;
            let g = parseInt(hex.substr(3,2),16)/255;
            let b = parseInt(hex.substr(5,2),16)/255;
            CONFIG.dyeColor = [r,g,b];
        });
        bind('sel-vis', 'onchange', (e) => { 
            const map = { 'dye':0, 'velocity':1, 'pressure':2, 'curl':3 };
            CONFIG.visMode = map[e.target.value];
        });
        bind('sel-pal', 'onchange', (e) => { 
            CONFIG.palette = parseInt(e.target.value);
            document.getElementById('gradient-editor').style.display = (CONFIG.palette === 7) ? 'block' : 'none';
            updateGradient();
        });
        bind('chk-vectors', 'onchange', (e) => { CONFIG.showVectors = e.target.checked; });
        bind('chk-autoscale', 'onchange', (e) => { CONFIG.autoScale = e.target.checked; });
        bind('sl-min', 'oninput', (e) => { CONFIG.valMin = parseFloat(e.target.value); if(!CONFIG.autoScale) currentMin = CONFIG.valMin; });
        bind('sl-max', 'oninput', (e) => { CONFIG.valMax = parseFloat(e.target.value); if(!CONFIG.autoScale) currentMax = CONFIG.valMax; });
        bind('sl-substeps', 'oninput', (e) => { CONFIG.substeps = parseInt(e.target.value); document.getElementById('val-substeps').innerText = CONFIG.substeps; });
        bind('sl-tscale', 'oninput', (e) => { CONFIG.timeScale = parseFloat(e.target.value); document.getElementById('val-tscale').innerText = CONFIG.timeScale; });
        
        bind('btn-resize', 'onclick', () => {
            CONFIG.simWidth = parseInt(document.getElementById('inp-width').value);
            CONFIG.simHeight = parseInt(document.getElementById('inp-height').value);
            resizeSimulation();
        });

        for(let i=1; i<=5; i++) {
            bind(`g-c${i}`, 'oninput', updateGradient);
            bind(`g-p${i}`, 'oninput', updateGradient);
        }
        bind('btn-clear-geo', 'onclick', () => { EDITOR.shapes = []; EDITOR.emitters = []; updateObstacles(); });
        bind('btn-clear-sim', 'onclick', () => {
            let dummy = new Float32Array(CONFIG.simWidth * CONFIG.simHeight * 4);
            [density, velocity, pressure].forEach(d => {
                gl.bindTexture(gl.TEXTURE_2D, d.read.texture); gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, CONFIG.simWidth, CONFIG.simHeight, 0, gl.RGBA, texSupport.texType, dummy);
                gl.bindTexture(gl.TEXTURE_2D, d.write.texture); gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, CONFIG.simWidth, CONFIG.simHeight, 0, gl.RGBA, texSupport.texType, dummy);
            });
        });

        // Emitter controls moved to popup. Keep only delete/clear bindings
        bind('btn-delete-selected', 'onclick', () => { deleteSelectedItems(); });
        bind('btn-clear-emitters', 'onclick', () => { EDITOR.emitters = []; updateObstacles(); drawUI(); hideEmitterPopup(); });

        // Disable default browser context menu for the UI canvas
        uiCanvas.addEventListener('contextmenu', (e) => { e.preventDefault(); return false; });

        // Simple Point-in-Polygon test used by move tool
        function pointInPolygon(pt, poly) {
            if(!poly || poly.length < 3) return false;
            let x = pt.x, y = pt.y;
            let inside = false;
            for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
                let xi = poly[i].x, yi = poly[i].y;
                let xj = poly[j].x, yj = poly[j].y;

                let intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi + 0.0) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        // Hook up ctx menu delete
        document.getElementById('ctx-delete').onclick = () => { deleteSelectedItems(); hideCtxMenu(); };

        // Hide ctx menu on outside click already wired above

        // popup drag
        (function(){
            const popup = document.getElementById('emitter-popup'); const header = document.getElementById('emitter-popup-header');
            let dragging=false, offX=0, offY=0;
            header.addEventListener('mousedown', (ev)=>{ dragging=true; offX = ev.clientX - popup.offsetLeft; offY = ev.clientY - popup.offsetTop; ev.preventDefault(); ev.stopPropagation(); });
            document.addEventListener('mousemove', (ev)=>{ if(dragging){ popup.style.left = Math.min(window.innerWidth - popup.offsetWidth - 10, Math.max(10, ev.clientX - offX)) + 'px'; popup.style.top = Math.min(window.innerHeight - popup.offsetHeight - 10, Math.max(10, ev.clientY - offY)) + 'px'; } });
            document.addEventListener('mouseup', ()=>{ dragging=false; });
        })();

        // popup input handlers (safer parsing and clamping)
        const popupEl = $('emitter-popup');
        const setPopupIdx = () => popupEl ? popupEl.dataset.emIndex : null;

        $('em-shape').addEventListener('change', (e) => {
            const idx = setPopupIdx(); if(idx == null) return; const em = EDITOR.emitters[idx]; em.shape = e.target.value; $('em-rect-dims').style.display = (em.shape === 'rect') ? 'block' : 'none'; $('em-cone').style.display = (em.shape === 'cone') ? 'block' : 'none'; drawUI();
        });

        $('sl-em-size').addEventListener('input', (e) => {
            const idx = setPopupIdx(); if(idx == null) return; const v = clamp(parseFloat(e.target.value), 0.001, 1.0); EDITOR.emitters[idx].size = v; $('val-em-size').innerText = v.toFixed(3); drawUI();
        });

        $('em-rect-w').addEventListener('input', (e) => { const idx = setPopupIdx(); if(idx == null) return; EDITOR.emitters[idx].width = clamp(parseFloat(e.target.value), 0.001, 1.0); drawUI(); });
        $('em-rect-h').addEventListener('input', (e) => { const idx = setPopupIdx(); if(idx == null) return; EDITOR.emitters[idx].height = clamp(parseFloat(e.target.value), 0.001, 1.0); drawUI(); });

        $('sl-em-spread').addEventListener('input', (e)=>{ const idx = setPopupIdx(); if(idx == null) return; const v = clamp(parseFloat(e.target.value), 0, 180); EDITOR.emitters[idx].spread = v; $('val-em-spread').innerText = v.toFixed(0) + '°'; drawUI(); });
        $('sl-em-angle-popup').addEventListener('input', (e)=>{ const idx = setPopupIdx(); if(idx == null) return; const v = ((parseFloat(e.target.value) % 360) + 360) % 360; EDITOR.emitters[idx].angle = v; $('val-em-angle-popup').innerText = v.toFixed(0) + '°'; drawUI(); });

        $('sl-em-force-popup').addEventListener('input', (e)=>{ const idx = setPopupIdx(); if(idx == null) return; const v = clamp(parseFloat(e.target.value), 0, 100); EDITOR.emitters[idx].force = v; $('val-em-force-popup').innerText = v.toFixed(2); drawUI(); });
        $('sl-em-amount-popup').addEventListener('input', (e)=>{ const idx = setPopupIdx(); if(idx == null) return; const v = clamp(parseFloat(e.target.value), 0, 100); EDITOR.emitters[idx].amount = v; $('val-em-amount-popup').innerText = v.toFixed(2); drawUI(); });
        $('sl-em-pressure-popup').addEventListener('input', (e)=>{ const idx = setPopupIdx(); if(idx == null) return; const v = clamp(parseFloat(e.target.value), -100, 100); EDITOR.emitters[idx].pressure = v; $('val-em-pressure-popup').innerText = v.toFixed(2); drawUI(); });

        $('btn-em-close').addEventListener('click', ()=>{ hideEmitterPopup(); });
        $('btn-em-apply').addEventListener('click', ()=>{ hideEmitterPopup(); updateObstacles(); });

        // Hide ctx menu on outside click already wired above

        // Delete key handler for selected elements
        window.addEventListener('keydown', e => {
            if (e.key === 'Enter' && EDITOR.mode === 'poly' && EDITOR.currentShape) {
                EDITOR.currentShape.closed = true; EDITOR.currentShape = null; updateObstacles();
            }
            if (e.key === 'Delete') {
                deleteSelectedItems();
            }
            if(e.key === 'v') setMode('select');
            if(e.key === 'p') setMode('poly');
            if(e.key === 'r') setMode('rect'); 
            if(e.key === 'c') setMode('circle'); 
            if(e.key === 'e') setMode('emitter');
        });

        // Update emitter UI when clicking selection
        uiCanvas.addEventListener('mouseup', () => { updateEmitterUI(); });

        // ensure ctx menu hides on ESC
        window.addEventListener('keydown', (e) => { if(e.key === 'Escape') hideCtxMenu(); });

        // Setup Initial State
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        uiCanvas.width = window.innerWidth;
        uiCanvas.height = window.innerHeight;
        CONFIG.aspectRatio = canvas.width / canvas.height;
        
        resizeSimulation(); // Create FBOs with default 256x256
        initScene();
        loop();
    });

</script>

    <div id="emitter-popup" class="panel" style="position:absolute; display:none; width:240px; z-index:10001; cursor:default;">
        <div id="emitter-popup-header" style="cursor:move; font-weight:600; margin-bottom:6px;">Emitter Settings <span style="float:right; font-weight:400; font-size:12px; opacity:0.8;">Drag to move</span></div>
        <div id="emitter-popup-body">
            <div class="control-group"><label>Shape</label><select id="em-shape"><option value="circle">Circle</option><option value="rect">Rectangle</option><option value="cone">Cone</option></select></div>
            <div class="control-group" id="em-size-group"><label>Size <span id="val-em-size" class="value-display">0.05</span></label><input id="sl-em-size" type="range" min="0.001" max="0.5" step="0.001" value="0.05"></div>
            <div class="control-group" id="em-rect-dims" style="display:none;"><label>Rect W / H</label><div style="display:flex; gap:6px;"><input id="em-rect-w" type="number" step="0.001" value="0.05" style="width:80px;"><input id="em-rect-h" type="number" step="0.001" value="0.05" style="width:80px;"></div></div>
            <div class="control-group" id="em-cone" style="display:none;"><label>Spread <span id="val-em-spread" class="value-display">30°</span></label><input id="sl-em-spread" type="range" min="0" max="90" value="30"></div>
            <div class="control-group"><label>Angle <span id="val-em-angle-popup" class="value-display">0°</span></label><input id="sl-em-angle-popup" type="range" min="0" max="360" step="1" value="0"></div>
            <div class="control-group"><label>Force <span id="val-em-force-popup" class="value-display">1.5</span></label><input id="sl-em-force-popup" type="range" min="0" max="10" step="0.1" value="1.5"></div>
            <div class="control-group"><label>Amount <span id="val-em-amount-popup" class="value-display">1.0</span></label><input id="sl-em-amount-popup" type="range" min="0" max="10" step="0.1" value="1.0"></div>
            <div class="control-group"><label>Pressure <span id="val-em-pressure-popup" class="value-display">0.00</span></label><input id="sl-em-pressure-popup" type="range" min="-5" max="5" step="0.1" value="0"></div>
            <div style="display:flex;gap:6px; margin-top:8px;"><button id="btn-em-close">Close</button><button id="btn-em-apply" style="background:#3b82f6; color:#fff;">Apply</button></div>
        </div>
    </div>

    <div id="ctx-menu">
        <button id="ctx-delete">Delete</button>
    </div> 
</body>
</html>