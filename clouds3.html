<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Volumetric Clouds - Infinite Flight v8 (Definitive)</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; user-select: none; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        #start-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); backdrop-filter: blur(10px); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; transition: opacity 0.5s; cursor: pointer; pointer-events: auto; }
        #start-screen.fade-out { opacity: 0; pointer-events: none; }
        #start-btn { padding: 20px 40px; border: 2px solid white; color: white; font-size: 1.5rem; font-family: monospace; letter-spacing: 4px; background: transparent; transition: all 0.2s; }
        #start-btn:hover { background: white; color: black; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: rgba(255, 255, 255, 0.9); font-family: monospace; font-size: 1.2rem; letter-spacing: 2px; transition: opacity 0.5s ease-out; text-align: center; background: rgba(0,0,0,0.5); padding: 20px; border-radius: 8px; backdrop-filter: blur(5px); display: flex; flex-direction: column; gap: 15px; align-items: center; }
        #progress-bar { width: 300px; height: 4px; background: rgba(255,255,255,0.2); border-radius: 2px; overflow: hidden; }
        #progress-fill { width: 0%; height: 100%; background: #00ff88; transition: width 0.1s linear; }
        #overlay { position: absolute; bottom: 20px; left: 20px; color: white; font-family: 'Segoe UI', sans-serif; text-align: left; pointer-events: auto; background: rgba(0, 0, 0, 0.6); padding: 20px; border-radius: 8px; backdrop-filter: blur(5px); border: 1px solid rgba(255,255,255,0.1); transition: opacity 0.3s; }
        #telemetry { position: absolute; top: 20px; right: 20px; text-align: right; color: rgba(255, 255, 255, 0.9); font-family: monospace; font-size: 0.9rem; text-shadow: 0 1px 2px rgba(0,0,0,0.8); pointer-events: none; }
        #audio-status { color: #888; font-weight: bold; margin-top: 8px; font-size: 0.8em; letter-spacing: 1px; }
        #audio-status.active { color: #00ff88; }
        #chord-display { color: #aaa; font-size: 0.8em; margin-top: 5px; font-family: monospace; }
        h1 { margin: 0 0 10px 0; font-weight: 300; font-size: 1.2rem; letter-spacing: 2px; }
        .control-row { margin: 4px 0; display: flex; align-items: center; }
        .key { display: inline-block; padding: 2px 6px; background: rgba(255,255,255,0.1); border-radius: 4px; font-family: monospace; color: #fff; margin: 0 2px; border: 1px solid rgba(255,255,255,0.2); font-size: 0.9rem; transition: background 0.1s, border-color 0.1s; }
        .key.active { background: #fff; color: #000; border-color: #fff; box-shadow: 0 0 10px white; }
        .hidden { opacity: 0 !important; pointer-events: none !important; }
        .lil-gui { --width: 320px; }
    </style>
</head>
<body>
    <div id="start-screen">
        <div id="start-btn">CLICK TO ENGAGE SYSTEMS</div>
        <div style="margin-top: 20px; color: #aaa; font-family: monospace;">Generative Audio Engine Ready</div>
    </div>
    <div id="loading">
        <div id="loading-text">GENERATING 3D NOISE ASSETS...</div>
        <div id="progress-bar"><div id="progress-fill"></div></div>
    </div>
    <div id="ui-layer">
        <div id="telemetry">
            ALT: <span id="val-alt">0</span> ft<br>
            SPD: <span id="val-spd">0</span> kts<br>
            POS: <span id="val-pos">0, 0</span><br>
            DENS: <span id="val-dens">0%</span>
        </div>
        <div id="overlay">
            <h1>AIRCRAFT CONTROLS</h1>
            <div style="line-height: 1.6; font-size: 0.9rem;">
                <div class="control-row"><span class="key" id="k-w">W</span><span class="key" id="k-s">S</span> Dive / Climb</div>
                <div class="control-row"><span class="key" id="k-a">A</span><span class="key" id="k-d">D</span> Roll Left / Right</div>
                <div class="control-row"><span class="key" id="k-l">←</span><span class="key" id="k-r">→</span> Yaw Left / Right</div>
                <div class="control-row"><span class="key" id="k-u">↑</span><span class="key" id="k-dn">↓</span> Throttle +/-</div>
                <div class="control-row"><span class="key">H</span> Toggle UI</div>
                <div id="audio-status">AUDIO STANDBY</div>
                <div id="chord-display">Scale: Initializing...</div>
            </div>
        </div>
    </div>
    <script type="importmap">
        { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/" } }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        let renderer, scene, camera, flightControls, audioManager;
        let cloudTarget, denoiseTarget, rayTarget, historyTarget, taaTarget;
        let cloudMat, denoiseMat, rayMat, compositeMat, taaMat;
        let postScene, postQuad;
        let clock = new THREE.Clock();
        let uiGui;
        let globalNoiseData = null; 
        let noiseWorker = null;
        let rainSystem;
        let stormIntensity = 0.0;
        let lightningIntensity = 0.0;
        let spatialSoundSystem = null;
        
        const NOISE_WORKER_CODE = `
            self.onmessage = function(e) {
                const size = e.data.size || 128;
                const seed = e.data.seed || Date.now();
                const totalPixels = size * size * size;
                const data = new Float32Array(totalPixels);
                const p = new Uint8Array(512);
                const perm = new Uint8Array(256);
                let seedVal = seed;
                const random = () => { seedVal = (seedVal * 9301 + 49297) % 233280; return seedVal / 233280; };
                for(let i=0; i<256; i++) perm[i] = i;
                for(let i=255; i>0; i--) { const r = Math.floor(random() * (i+1)); [perm[i], perm[r]] = [perm[r], perm[i]]; }
                for(let i=0; i<512; i++) p[i] = perm[i & 255];
                const fade = t => t*t*t*(t*(t*6-15)+10);
                const lerp = (a, b, t) => a+t*(b-a);
                const grad = (hash, x, y, z) => { const h = hash & 15; const u = h<8?x:y; const v = h<4?y:h==12||h==14?x:z; return ((h&1)==0?u:-u)+((h&2)==0?v:-v); };
                const pnoise = (x, y, z, period) => {
                    const X = Math.floor(x)%period, Y = Math.floor(y)%period, Z = Math.floor(z)%period;
                    const fx = x-Math.floor(x), fy = y-Math.floor(y), fz = z-Math.floor(z);
                    const u = fade(fx), v = fade(fy), w = fade(fz);
                    const X1 = (X+1)%period, Y1 = (Y+1)%period, Z1 = (Z+1)%period;
                    const g000 = grad(p[p[p[X]+Y]+Z], fx, fy, fz), g100 = grad(p[p[p[X1]+Y]+Z], fx-1, fy, fz);
                    const g010 = grad(p[p[p[X]+Y1]+Z], fx, fy-1, fz), g110 = grad(p[p[p[X1]+Y1]+Z], fx-1, fy-1, fz);
                    const g001 = grad(p[p[p[X]+Y]+Z1], fx, fy, fz-1), g101 = grad(p[p[p[X1]+Y]+Z1], fx-1, fy, fz-1);
                    const g011 = grad(p[p[p[X]+Y1]+Z1], fx, fy-1, fz-1), g111 = grad(p[p[p[X1]+Y1]+Z1], fx-1, fy-1, fz-1);
                    return lerp(lerp(lerp(g000, g100, u), lerp(g010, g110, u), v), lerp(lerp(g001, g101, u), lerp(g011, g111, u), v), w);
                };
                let idx = 0; const freq = 8.0; 
                for(let z=0; z<size; z++) {
                    if (z % 4 === 0) self.postMessage({progress: z/size});
                    for(let y=0; y<size; y++) {
                        for(let x=0; x<size; x++) {
                            const nx = x/size, ny = y/size, nz = z/size;
                            let total = 0.0, amplitude = 0.5, f = freq;
                            for(let k=0; k<4; k++) { total += pnoise(nx*f, ny*f, nz*f, Math.floor(f)) * amplitude; amplitude *= 0.5; f *= 2.0; }
                            data[idx++] = total * 0.5 + 0.5;
                        }
                    }
                }
                self.postMessage({done: true, data: data, size: size});
            };
        `;
        
        const DEFAULT_CONFIG = {
            autoSun: false, autoWeather: false, timeScale: 1.0, sunElevation: 12, sunAzimuth: 180, sunIntensity: 1.0,
            cloudColorTop: '#ffffff', cloudColorBottom: '#5c6e8c', skyColorZenith: '#3a76c4', skyColorHorizon: '#e8f4f8',
            skySunsetZenith: '#2a3b55', skySunsetHorizon: '#ff8800', groundColor: '#050508',
            cloudCover: 0.6, cloudDensity: 1.0, cloudAbsorption: 1.2, cloudBottom: 1500, cloudTop: 4500,
            noiseScale: 2.2, erosion: 0.5, densityProfile: 0.6, fadeBottom: 0.15, fadeTop: 0.15,
            macroScale1: 4.0, macroScale2: 10.0, macroStrength2: 0.5, macroScale3: 20.0, macroStrength3: 0.25,
            macroCoverage: 0.3, macroDensity: 0.5, windSpeed: 0.15, windAngle: 0.0,
            silverLining: 0.7, silverSpread: 0.5, ambientIntensity: 0.2, powder: 1.0,
            resolution: 0.5, steps: 96, lightSteps: 12, noiseOctaves: 3, dithering: true,
            lodDistance: 20000.0, maxDist: 100000.0, enableDenoise: true, enableTAA: true, taaBlend: 0.9,
            rayleigh: 1.2, mieCoefficient: 0.005, mieDirectionalG: 0.8, fogDensity: 0.000015,
            godRays: true, rayIntensity: 1.0, rayDensity: 1.2, rayWeight: 0.58, rayDecay: 0.985, rayExposure: 0.55, raySamples: 60,
            masterVolume: 0.5, volSynths: 0.6, volBass: 0.7, volWind: 0.4, volReverb: 0.7, volCabin: 0.4, volArp: 0.5, volAtmos: 0.5, volSFX: 0.6, volDrums: 0.6,
            textureSize: 128
        };
        const CONFIG = { ...DEFAULT_CONFIG };
        const AUTOMATION = {
            sun: { enabled: false, speed: 0.1, minElev: -5, maxElev: 45 },
            weather: { enabled: false, speed: 0.05, minCover: 0.3, maxCover: 0.8 },
            density: { enabled: false, speed: 0.03, minDensity: 0.5, maxDensity: 2.0 },
            erosion: { enabled: false, speed: 0.1, minErosion: 0.2, maxErosion: 0.8 },
            wind: { enabled: false, speed: 0.05, minSpeed: 0.0, maxSpeed: 2.0 },
            detail: { enabled: false, speed: 0.05, minScale: 1.5, maxScale: 4.0 }
        };

        const NOTES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        const SCALES = { AEOLIAN: [0, 2, 3, 5, 7, 8, 10], DORIAN: [0, 2, 3, 5, 7, 9, 10], PHRYGIAN:[0, 1, 3, 5, 7, 8, 10], LYDIAN: [0, 2, 4, 6, 7, 9, 11] };
        const mtof = (note) => 440 * Math.pow(2, (note - 69) / 12);

        class RainSystem {
            constructor(scene) {
                this.count = 20000;
                this.geometry = new THREE.BufferGeometry();
                const pos = new Float32Array(this.count * 3);
                const vel = new Float32Array(this.count);
                for(let i=0; i<this.count; i++) {
                    pos[i*3] = (Math.random()-0.5) * 1000;
                    pos[i*3+1] = (Math.random()-0.5) * 500;
                    pos[i*3+2] = (Math.random()-0.5) * 1000;
                    vel[i] = 1.0 + Math.random();
                }
                this.geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
                this.geometry.setAttribute('velocity', new THREE.BufferAttribute(vel, 1));
                this.material = new THREE.ShaderMaterial({
                    uniforms: { uTime: { value: 0 }, uSpeed: { value: 200 }, uOpacity: { value: 0.0 }, uCameraPos: { value: new THREE.Vector3() } },
                    transparent: true, depthWrite: false, blending: THREE.AdditiveBlending,
                    vertexShader: `
                        uniform float uTime; uniform float uSpeed; uniform vec3 uCameraPos; attribute float velocity; varying float vAlpha;
                        void main() {
                            vec3 pos = position; float yOffset = mod(pos.y - uTime * uSpeed * velocity, 500.0);
                            vec3 worldPos = uCameraPos + vec3(pos.x, 250.0 - yOffset, pos.z);
                            vec3 rel = worldPos - uCameraPos;
                            rel.x = mod(rel.x + 500.0, 1000.0) - 500.0; rel.z = mod(rel.z + 500.0, 1000.0) - 500.0;
                            gl_Position = projectionMatrix * viewMatrix * vec4(uCameraPos + rel, 1.0);
                            gl_PointSize = max(1.0, 5000.0 / length(rel)); vAlpha = min(1.0, 1000.0 / length(rel));
                        }
                    `,
                    fragmentShader: `
                        uniform float uOpacity; varying float vAlpha;
                        void main() { if(uOpacity < 0.01) discard; gl_FragColor = vec4(0.7, 0.8, 1.0, uOpacity * 0.5 * vAlpha); }
                    `
                });
                this.mesh = new THREE.Points(this.geometry, this.material);
                scene.add(this.mesh);
            }
            update(dt, camPos, intensity) {
                this.material.uniforms.uTime.value += dt;
                this.material.uniforms.uCameraPos.value.copy(camPos);
                this.material.uniforms.uOpacity.value = Math.max(0, (intensity - 0.3) * 1.5);
            }
        }

        class SpatialSoundSystem {
            constructor(ctx, destination) {
                this.ctx = ctx; this.destination = destination; this.emitters = [];
            }
            update(dt, playerPos, camQuat) {
                this.emitters = this.emitters.filter(e => e.active);
                this.emitters.forEach(e => e.update(dt, playerPos, camQuat));
            }
            spawnThunder(playerPos, intensity) {
                const angle = Math.random() * Math.PI * 2;
                const dist = 3000 + Math.random() * 8000;
                const pos = new THREE.Vector3(playerPos.x + Math.sin(angle) * dist, playerPos.y + (Math.random() * 2000), playerPos.z + Math.cos(angle) * dist);
                const emitter = new ThunderEmitter(this.ctx, this.destination, pos, intensity);
                this.emitters.push(emitter);
                lightningIntensity = 2.0 + Math.random() * 3.0; 
            }
        }

        class ThunderEmitter {
            constructor(ctx, dest, position, intensity) {
                this.ctx = ctx; this.pos = position; this.active = true; this.life = 5.0;
                this.panner = ctx.createPanner(); this.panner.panningModel = 'HRTF'; this.panner.distanceModel = 'exponential';
                this.panner.refDistance = 2000; this.panner.maxDistance = 60000; this.panner.rolloffFactor = 0.5;
                this.panner.connect(dest);
                const t = ctx.currentTime;
                const noise = ctx.createBufferSource();
                const bSize = Math.floor(ctx.sampleRate * 1.5);
                const buff = ctx.createBuffer(1, bSize, ctx.sampleRate);
                const data = buff.getChannelData(0);
                for(let i=0; i<bSize; i++) data[i] = (Math.random() * 2 - 1) * Math.exp(-i/(ctx.sampleRate*0.2));
                noise.buffer = buff;
                const noiseFilter = ctx.createBiquadFilter(); noiseFilter.type = 'lowpass'; noiseFilter.frequency.setValueAtTime(3000, t); noiseFilter.frequency.exponentialRampToValueAtTime(100, t+1.0);
                const osc = ctx.createOscillator(); osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(50, t); osc.frequency.exponentialRampToValueAtTime(10, t + 2.0);
                const gain = ctx.createGain();
                gain.gain.setValueAtTime(0, t); gain.gain.linearRampToValueAtTime(CONFIG.volSFX * intensity, t + 0.05); gain.gain.exponentialRampToValueAtTime(0.001, t + 3.0);
                osc.connect(gain); noise.connect(noiseFilter); noiseFilter.connect(gain); gain.connect(this.panner);
                osc.start(t); osc.stop(t + 3.0); noise.start(t); noise.stop(t + 3.0);
            }
            update(dt, playerPos, camQuat) {
                this.life -= dt; if (this.life <= 0) { this.active = false; try { this.panner.disconnect(); } catch(e){} return; }
                let relX = this.pos.x - playerPos.x; let relZ = this.pos.z - playerPos.z;
                const WRAP = 200000;
                if (Math.abs(relX) > WRAP/2) relX -= Math.sign(relX) * WRAP;
                if (Math.abs(relZ) > WRAP/2) relZ -= Math.sign(relZ) * WRAP;
                if (!isFinite(relX) || !isFinite(relZ)) return;
                this.panner.positionX.value = relX; this.panner.positionY.value = this.pos.y - playerPos.y; this.panner.positionZ.value = relZ;
                const orient = new THREE.Vector3(0, 0, -1).applyQuaternion(camQuat);
                const up = new THREE.Vector3(0, 1, 0).applyQuaternion(camQuat);
                if (this.ctx.listener.forwardX) {
                    this.ctx.listener.forwardX.value = orient.x; this.ctx.listener.forwardY.value = orient.y; this.ctx.listener.forwardZ.value = orient.z;
                    this.ctx.listener.upX.value = up.x; this.ctx.listener.upY.value = up.y; this.ctx.listener.upZ.value = up.z;
                }
            }
        }

        class AtmosphereAudio {
            constructor() {
                this.ctx = null; this.masterGain = null;
                this.busses = {}; this.reverbNodes = {}; this.delayNodes = {};
                this.activeVoices = {}; 
                this.droneNodes = { osc: [] }; this.windNodes = {}; this.cabinNodes = {}; this.bassNodes = {};
                this.drumBuffers = {}; this.turbineNodes = {}; this.rainNodes = {};
                this.initialized = false;
                this.tempo = 90; this.nextNoteTime = 0; this.scheduleAheadTime = 0.1;
                this.current16thNote = 0; this.barCount = 0; this.cycleCount = 0;
                this.rootNoteBase = 58; 
                this.harmonicProgression = []; 
                this.progressionIndex = 0; this.barsInCurrentStage = 0;
                this.currentScaleType = 'AEOLIAN'; this.currentRoot = 58;
                this.speedFactor = 0.0; this.synthVolumeMult = 1.0; this.cloudDensity = 0.0;
                this.timeOfDay = 1.0; this.altitudeFactor = 0.0; this.masterFilter = null;
                this.drumLevels = { kick: 0, snare: 0, hat: 0 };
                this.gForce = 0.0;
                this.rhythmMode = 'STRAIGHT'; this.changePending = false; this.isStill = false;
                this.generateProgression();
            }
            init() {
                if (this.initialized) return;
                try {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    if (!AudioContext) throw new Error("Web Audio API not supported");
                    this.ctx = new AudioContext();
                    this.masterGain = this.ctx.createGain(); this.masterGain.gain.value = CONFIG.masterVolume;
                    const compressor = this.ctx.createDynamicsCompressor();
                    compressor.threshold.value = -18; compressor.ratio.value = 8;
                    this.masterFilter = this.ctx.createBiquadFilter();
                    this.masterFilter.type = 'lowpass'; this.masterFilter.frequency.value = 20000;
                    this.masterGain.connect(compressor); compressor.connect(this.masterFilter); this.masterFilter.connect(this.ctx.destination);
                    ['synth', 'bass', 'wind', 'cabin', 'arp', 'atmos', 'sfx', 'turbine', 'rain'].forEach(b => { 
                        this.busses[b] = this.ctx.createGain(); this.busses[b].connect(this.masterGain); 
                    });
                    this.busses.drumsMain = this.ctx.createGain(); this.busses.drumsMain.connect(this.masterGain);
                    this.busses.kick = this.ctx.createGain(); 
                    this.busses.kickFilter = this.ctx.createBiquadFilter(); this.busses.kickFilter.type = 'highpass'; this.busses.kickFilter.frequency.value = 0;
                    this.busses.kick.connect(this.busses.kickFilter); this.busses.kickFilter.connect(this.busses.drumsMain);
                    this.busses.snare = this.ctx.createGain(); 
                    this.busses.snareFilter = this.ctx.createBiquadFilter(); this.busses.snareFilter.type = 'lowpass'; this.busses.snareFilter.frequency.value = 20000;
                    this.busses.snare.connect(this.busses.snareFilter); this.busses.snareFilter.connect(this.busses.drumsMain);
                    this.busses.hat = this.ctx.createGain(); this.busses.hat.connect(this.busses.drumsMain);
                    
                    this.setupReverb(); 
                    this.busses.snare.connect(this.reverbNodes.input); this.busses.hat.connect(this.reverbNodes.input);
                    const kickRevGain = this.ctx.createGain(); kickRevGain.gain.value = 0.2;
                    this.busses.kick.connect(kickRevGain); kickRevGain.connect(this.reverbNodes.input);
                    
                    this.setupDelay(); this.setupWind(); this.setupCabin(); this.setupDrone(); this.setupBass(); this.setupTurbine(); this.setupRain();
                    this.createNoiseBuffers(); 
                    spatialSoundSystem = new SpatialSoundSystem(this.ctx, this.busses.sfx);
                    this.initialized = true; this.nextNoteTime = this.ctx.currentTime + 0.1;
                    this.updateStatus(true); this.scheduler();
                } catch (e) { console.warn("Audio Init Failed", e); this.updateStatus(false); }
            }
            createNoiseBuffers() {
                const len = Math.floor(this.ctx.sampleRate * 1.0);
                const buffer = this.ctx.createBuffer(1, len, this.ctx.sampleRate);
                const d = buffer.getChannelData(0);
                for(let i=0; i<len; i++) d[i] = Math.random() * 2 - 1;
                this.drumBuffers.noise = buffer;
            }
            safeSetParam(param, value, time, timeConstant = 0.1) {
                if (param && isFinite(value) && isFinite(time)) try { param.setTargetAtTime(value, time, timeConstant); } catch (e) {}
            }
            updateStatus(success) {
                const el = document.getElementById('audio-status');
                if (success) { el.innerText = "AUDIO ONLINE"; el.classList.add('active'); } else { el.innerText = "AUDIO FAILED"; }
            }
            generateProgression() {
                const possibleOffsets = [0, -5, 5, 7, 2, -2];
                const count = 4 + Math.floor(Math.random() * 3);
                this.harmonicProgression = [];
                for(let i=0; i<count; i++) {
                    const rootOff = possibleOffsets[Math.floor(Math.random() * possibleOffsets.length)];
                    const scaleKeys = Object.keys(SCALES);
                    const scale = scaleKeys[Math.floor(Math.random() * scaleKeys.length)];
                    this.harmonicProgression.push({ scale, rootOff, bars: 4 + (Math.random() > 0.5 ? 4 : 0) });
                }
            }
            changeMusicalContext() {
                const modes = ['STRAIGHT', 'SHUFFLE', 'CHAABI'];
                this.rhythmMode = modes[Math.floor(Math.random() * modes.length)];
                this.rootNoteBase = 48 + Math.floor(Math.random() * 12); 
                this.generateProgression();
                this.progressionIndex = 0;
                this.barsInCurrentStage = 0;
                this.cycleCount++;
                const stage = this.harmonicProgression[0];
                this.currentScaleType = stage.scale; 
                this.currentRoot = this.rootNoteBase + stage.rootOff;
                document.getElementById('chord-display').innerText = `Key: ${this.getKeyName()} | Rhythm: ${this.rhythmMode}`;
            }
            updateVolumes(dt) {
                if(!this.initialized) return;
                const now = this.ctx.currentTime;
                const movementFade = THREE.MathUtils.smoothstep(this.speedFactor, 0.0, 0.15);
                this.safeSetParam(this.masterGain.gain, CONFIG.masterVolume, now, 0.1);
                if (this.rainNodes && this.rainNodes.gain) {
                    this.safeSetParam(this.rainNodes.gain.gain, stormIntensity * 0.8, now, 0.5);
                    this.safeSetParam(this.rainNodes.filter.frequency, 400 + stormIntensity * 800, now, 0.5);
                }
                const droneVol = 0.04 * (0.2 + 0.8 * movementFade);
                if (this.droneNodes.osc) this.droneNodes.osc.forEach(d => this.safeSetParam(d.gain.gain, droneVol, now, 0.5));
                this.safeSetParam(this.busses.synth.gain, CONFIG.volSynths * movementFade, now, 0.1);
                this.safeSetParam(this.busses.bass.gain, CONFIG.volBass * movementFade, now, 0.1);
                this.safeSetParam(this.busses.arp.gain, CONFIG.volArp * movementFade, now, 0.1);
                this.safeSetParam(this.busses.atmos.gain, CONFIG.volAtmos * movementFade, now, 0.1);
                this.safeSetParam(this.busses.cabin.gain, CONFIG.volCabin, now, 0.1);
                this.safeSetParam(this.busses.sfx.gain, CONFIG.volSFX, now, 0.1);
                this.safeSetParam(this.reverbNodes.input.gain, CONFIG.volReverb, now, 0.1);
                this.safeSetParam(this.busses.drumsMain.gain, CONFIG.volDrums, now, 0.1);
                const hatTarget = this.speedFactor > 0.5 ? 0.4 : 0.0;
                const hatRate = (hatTarget > this.drumLevels.hat) ? 0.2 : 0.4;
                this.drumLevels.hat = THREE.MathUtils.lerp(this.drumLevels.hat, hatTarget, dt * hatRate);
                this.safeSetParam(this.busses.hat.gain, this.drumLevels.hat, now, 0.2);
                const kickTarget = this.speedFactor > 0.7 ? 0.8 : 0.0;
                const kickRate = (kickTarget > this.drumLevels.kick) ? 0.2 : 0.4;
                this.drumLevels.kick = THREE.MathUtils.lerp(this.drumLevels.kick, kickTarget, dt * kickRate);
                this.safeSetParam(this.busses.kick.gain, this.drumLevels.kick, now, 0.2);
                const snareTarget = this.speedFactor > 0.85 ? 0.6 : 0.0;
                const snareRate = (snareTarget > this.drumLevels.snare) ? 0.2 : 0.4;
                this.drumLevels.snare = THREE.MathUtils.lerp(this.drumLevels.snare, snareTarget, dt * snareRate);
                this.safeSetParam(this.busses.snare.gain, this.drumLevels.snare, now, 0.2);
                let kickCutoff = THREE.MathUtils.smoothstep(this.altitudeFactor, 0.6, 1.0) * 300;
                this.safeSetParam(this.busses.kickFilter.frequency, kickCutoff, now, 0.5);
                let snareCutoff = 20000 - (this.cloudDensity * 15000);
                this.safeSetParam(this.busses.snareFilter.frequency, snareCutoff, now, 0.5);
                const rumbleVol = THREE.MathUtils.smoothstep(this.speedFactor, 0.8, 1.0) * 0.5;
                if (this.turbineNodes && this.turbineNodes.gain) {
                    this.safeSetParam(this.turbineNodes.gain.gain, rumbleVol, now, 0.2);
                    this.safeSetParam(this.turbineNodes.osc.frequency, 50 + (this.speedFactor * 30) + (Math.random() * 10), now, 0.1); 
                    this.safeSetParam(this.turbineNodes.filter.frequency, 100 + (this.speedFactor * 50), now, 0.1);
                }
            }
            setupReverb() {
                const len = Math.floor(this.ctx.sampleRate * 5.0); 
                const buffer = this.ctx.createBuffer(2, len, this.ctx.sampleRate);
                for (let c=0; c<2; c++) { const d = buffer.getChannelData(c); for (let i=0; i<len; i++) d[i] = (Math.random()*2-1) * Math.pow(1-i/len, 4.0); }
                this.reverbNodes.convolver = this.ctx.createConvolver(); this.reverbNodes.convolver.buffer = buffer;
                this.reverbNodes.input = this.ctx.createGain();
                this.reverbNodes.input.connect(this.reverbNodes.convolver); this.reverbNodes.convolver.connect(this.masterGain);
            }
            setupDelay() {
                this.delayNodes.delay = this.ctx.createDelay(1.0); this.delayNodes.delay.delayTime.value = 0.35;
                this.delayNodes.feedback = this.ctx.createGain(); this.delayNodes.feedback.gain.value = 0.4;
                this.delayNodes.delay.connect(this.delayNodes.feedback); this.delayNodes.feedback.connect(this.delayNodes.delay); this.delayNodes.delay.connect(this.busses.atmos);
            }
            setupWind() {
                const bSize = Math.floor(2*this.ctx.sampleRate); const buff = this.ctx.createBuffer(1, bSize, this.ctx.sampleRate); const data = buff.getChannelData(0);
                let b0=0,b1=0,b2=0,b3=0,b4=0,b5=0,b6=0;
                for(let i=0; i<bSize; i++) {
                    let w = Math.random()*2-1; b0=0.99886*b0+w*0.0555; b1=0.99332*b1+w*0.075; b2=0.969*b2+w*0.15; b3=0.8665*b3+w*0.31; b4=0.55*b4+w*0.53; b5=-0.76*b5-w*0.016;
                    data[i]=(b0+b1+b2+b3+b4+b5+b6+w*0.53)*0.11; b6=w*0.11;
                }
                const src = this.ctx.createBufferSource(); src.buffer = buff; src.loop = true;
                const filter = this.ctx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.value = 200;
                const gain = this.ctx.createGain(); gain.gain.value = 0.0;
                src.connect(filter); filter.connect(gain); gain.connect(this.busses.wind); this.windNodes = { src, filter, gain }; src.start();
            }
            setupCabin() {
                const bSize = Math.floor(2*this.ctx.sampleRate); const buff = this.ctx.createBuffer(1, bSize, this.ctx.sampleRate); const data = buff.getChannelData(0);
                let last=0; for(let i=0; i<bSize; i++) { let w=Math.random()*2-1; data[i]=(last+(0.02*w))/1.02; last=data[i]; data[i]*=3.5; }
                const src = this.ctx.createBufferSource(); src.buffer = buff; src.loop = true;
                const filter = this.ctx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.value = 120;
                const gain = this.ctx.createGain(); gain.gain.value = 0.3;
                src.connect(filter); filter.connect(gain); gain.connect(this.busses.cabin); this.cabinNodes = { src, filter, gain }; src.start();
            }
            setupDrone() {
                this.droneNodes.osc = [];
                [0.5, 1.0, 1.5].forEach(mult => {
                    const osc = this.ctx.createOscillator(); osc.type = 'triangle'; osc.frequency.value = mtof(this.rootNoteBase - 24) * mult;
                    const gain = this.ctx.createGain(); gain.gain.value = 0.04; 
                    const filter = this.ctx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.value = 150; 
                    osc.connect(filter); filter.connect(gain); gain.connect(this.reverbNodes.input); 
                    osc.start(); this.droneNodes.osc.push({osc, gain, filter, mult});
                });
            }
            setupBass() {
                this.bassNodes.gain = this.ctx.createGain(); this.bassNodes.gain.gain.value = 1.0; 
                this.bassNodes.filter = this.ctx.createBiquadFilter(); this.bassNodes.filter.type = 'lowpass'; this.bassNodes.filter.frequency.value = 200;
                this.bassNodes.gain.connect(this.bassNodes.filter); this.bassNodes.filter.connect(this.busses.bass);
            }
            setupTurbine() {
                const osc = this.ctx.createOscillator(); osc.type = 'sawtooth'; osc.frequency.value = 60;
                const filter = this.ctx.createBiquadFilter(); filter.type = 'lowpass'; filter.Q.value = 5.0; filter.frequency.value = 100;
                const gain = this.ctx.createGain(); gain.gain.value = 0.0;
                osc.connect(filter); filter.connect(gain); gain.connect(this.busses.turbine);
                osc.start(); this.turbineNodes = { osc, filter, gain };
            }
            setupRain() {
                const bSize = Math.floor(2*this.ctx.sampleRate);
                const buff = this.ctx.createBuffer(1, bSize, this.ctx.sampleRate);
                const data = buff.getChannelData(0);
                let b0=0,b1=0,b2=0,b3=0,b4=0,b5=0,b6=0;
                for(let i=0; i<bSize; i++) {
                    let w = Math.random()*2-1; b0=0.99886*b0+w*0.0555; b1=0.99332*b1+w*0.075; b2=0.969*b2+w*0.15; b3=0.8665*b3+w*0.31; b4=0.55*b4+w*0.53; b5=-0.76*b5-w*0.016;
                    data[i]=(b0+b1+b2+b3+b4+b5+b6+w*0.53)*0.11; b6=w*0.11;
                }
                const src = this.ctx.createBufferSource(); src.buffer = buff; src.loop = true;
                const filter = this.ctx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.value = 800;
                const gain = this.ctx.createGain(); gain.gain.value = 0.0;
                src.connect(filter); filter.connect(gain); gain.connect(this.busses.rain); 
                src.start(); this.rainNodes = { src, filter, gain };
            }
            triggerKick(time) {
                const osc = this.ctx.createOscillator(); osc.frequency.setValueAtTime(120, time); osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.5);
                const gain = this.ctx.createGain(); gain.gain.setValueAtTime(1.0, time); gain.gain.exponentialRampToValueAtTime(0.001, time + 0.5);
                osc.connect(gain); gain.connect(this.busses.kick);
                osc.start(time); osc.stop(time + 0.5);
            }
            triggerSnare(time) {
                const noise = this.ctx.createBufferSource(); noise.buffer = this.drumBuffers.noise;
                const noiseFilter = this.ctx.createBiquadFilter(); noiseFilter.type = 'highpass'; noiseFilter.frequency.value = 800;
                const noiseGain = this.ctx.createGain(); noiseGain.gain.setValueAtTime(1.0, time); noiseGain.gain.exponentialRampToValueAtTime(0.01, time + 0.3);
                noise.connect(noiseFilter); noiseFilter.connect(noiseGain); noiseGain.connect(this.busses.snare);
                const osc = this.ctx.createOscillator(); osc.type = 'triangle'; osc.frequency.setValueAtTime(180, time); osc.frequency.exponentialRampToValueAtTime(120, time + 0.1);
                const oscGain = this.ctx.createGain(); oscGain.gain.setValueAtTime(0.5, time); oscGain.gain.exponentialRampToValueAtTime(0.01, time + 0.15);
                osc.connect(oscGain); oscGain.connect(this.busses.snare);
                noise.start(time); noise.stop(time+0.3); osc.start(time); osc.stop(time+0.2);
            }
            triggerHat(time, isOpen) {
                const src = this.ctx.createBufferSource(); src.buffer = this.drumBuffers.noise;
                const filter = this.ctx.createBiquadFilter(); filter.type = 'highpass'; filter.frequency.value = 6000;
                const gain = this.ctx.createGain(); gain.gain.setValueAtTime(0.4, time); gain.gain.exponentialRampToValueAtTime(0.01, time + (isOpen ? 0.3 : 0.05));
                src.connect(filter); filter.connect(gain); gain.connect(this.busses.hat);
                src.start(time); src.stop(time + 0.4);
            }
            getScaleNotes(root, type) { return SCALES[type].map(interval => root + interval); }
            getKeyName() { return `${NOTES[this.currentRoot % 12]} ${this.currentScaleType}`; }
            advanceHarmony() {
                this.progressionIndex++; 
                if (this.progressionIndex >= this.harmonicProgression.length) { 
                    this.progressionIndex = 0; 
                    this.cycleCount++; 
                }
                const stage = this.harmonicProgression[this.progressionIndex];
                if (!this.changePending) { 
                    this.currentScaleType = stage.scale; 
                    this.currentRoot = this.rootNoteBase + stage.rootOff;
                }
                this.barsInCurrentStage = 0; 
                while(this.currentRoot > 65) this.currentRoot -= 12; 
                while(this.currentRoot < 45) this.currentRoot += 12;
                const now = this.ctx.currentTime;
                this.droneNodes.osc.forEach(node => {
                    this.safeSetParam(node.osc.frequency, mtof(this.currentRoot - 24) * node.mult, now, 4.0);
                    this.safeSetParam(node.filter.frequency, 100 + (this.timeOfDay * 200), now, 2.0);
                });
                document.getElementById('chord-display').innerText = `Key: ${this.getKeyName()} | Rhythm: ${this.rhythmMode}`;
            }
            manageVoice(layer, type, time) {
                if (!type) { if (this.activeVoices[layer]) { this.releaseVoice(layer, time); } return; }
                if (this.activeVoices[layer]) {
                    if (this.activeVoices[layer].type !== type) { this.releaseVoice(layer, time); this.triggerVoice(layer, type, time); }
                } else { this.triggerVoice(layer, type, time); }
            }
            triggerVoice(layer, type, time) {
                if (type === 'IDLE') return;
                const notes = this.getNotesForType(type);
                const config = this.getConfigForType(type);
                const oscs = [];
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0, time);
                gain.gain.linearRampToValueAtTime(config.vol * this.synthVolumeMult, time + 0.8);
                const panner = this.ctx.createStereoPanner();
                panner.pan.value = config.pan;
                gain.connect(panner); panner.connect(this.busses.synth); panner.connect(this.reverbNodes.input);
                notes.forEach((midi, i) => {
                    const osc = this.ctx.createOscillator(); osc.type = 'sawtooth';
                    const freq = mtof(midi);
                    if (config.glide !== 0) {
                        osc.frequency.setValueAtTime(mtof(midi - config.glide), time);
                        osc.frequency.exponentialRampToValueAtTime(freq, time + 0.5);
                    } else osc.frequency.value = freq;
                    const filter = this.ctx.createBiquadFilter(); filter.type = 'lowpass';
                    filter.frequency.value = 200 + (this.timeOfDay * 400) + (this.speedFactor * 800);
                    osc.detune.value = (i % 2 === 0 ? 6 : -6);
                    osc.connect(filter); filter.connect(gain); osc.start(time); oscs.push(osc);
                });
                this.activeVoices[layer] = { oscs, gain, type, panner };
                if (this.speedFactor > 0.1) this.triggerInputArp(type, time);
            }
            releaseVoice(layer, time) {
                const v = this.activeVoices[layer]; if (!v) return;
                try {
                    v.gain.gain.cancelScheduledValues(time); v.gain.gain.setValueAtTime(v.gain.gain.value, time);
                    v.gain.gain.setTargetAtTime(0, time, 0.3);
                    v.oscs.forEach(o => o.stop(time + 2.0));
                } catch(e) {}
                delete this.activeVoices[layer];
            }
            getNotesForType(type) {
                const s = this.getScaleNotes(this.currentRoot, this.currentScaleType);
                if (type === 'RISE') return [s[0], s[4], s[0]+12, s[2]+12];
                if (type === 'FALL') return [s[0], s[2], s[4], s[0]-12]; 
                if (type === 'ROLL_L') return [s[3]-12, s[3], s[5], s[0]+12]; 
                if (type === 'ROLL_R') return [s[4]-12, s[4], s[6], s[1]+12]; 
                if (type === 'YAW_L') return [s[1]-12, s[1], s[3], s[5]];
                if (type === 'YAW_R') return [s[5]-12, s[5], s[0]+12, s[2]+12]; 
                return [s[0], s[4]];
            }
            getConfigForType(type) {
                if (type.includes('YAW')) return { pan: type.includes('L') ? -0.4 : 0.4, glide: type.includes('L') ? -1 : 1, vol: 0.35 };
                if (type.includes('ROLL')) return { pan: type.includes('L') ? -0.7 : 0.7, glide: 0, vol: 0.4 };
                if (type.includes('RISE') || type.includes('FALL')) return { pan: 0, glide: 0, vol: 0.45 };
                return { pan: 0, glide: 0, vol: 0.35 };
            }
            triggerInputArp(type, time) {
                const notes = this.getNotesForType(type).slice(0, 4); 
                let speed = 0.06;
                if (Math.floor(time) % 2 === 1) notes.reverse();
                notes.forEach((midi, i) => {
                    const osc = this.ctx.createOscillator();
                    osc.type = this.altitudeFactor > 0.6 ? 'sine' : 'triangle';
                    osc.frequency.value = mtof(midi + 24); 
                    const gain = this.ctx.createGain();
                    gain.gain.setValueAtTime(0, time + i * speed);
                    gain.gain.linearRampToValueAtTime(0.08, time + i * speed + 0.01);
                    gain.gain.exponentialRampToValueAtTime(0.001, time + i * speed + 0.3);
                    const pan = this.ctx.createStereoPanner(); pan.pan.value = (Math.sin(time) * 0.5);
                    osc.connect(gain); gain.connect(pan); pan.connect(this.busses.arp); pan.connect(this.reverbNodes.input);
                    osc.start(time + i * speed); osc.stop(time + i * speed + 0.4);
                });
            }
            playBassPulse(midi, time, duration) {
                const osc = this.ctx.createOscillator();
                osc.type = this.altitudeFactor > 0.7 ? 'sawtooth' : (this.altitudeFactor > 0.4 ? 'square' : 'triangle');
                osc.frequency.value = mtof(midi - 24); 
                const filter = this.ctx.createBiquadFilter(); filter.type = 'lowpass';
                const baseCutoff = (Math.floor(this.cycleCount / 2) % 2 === 0 ? 80 : 60) + (this.speedFactor * 400); 
                filter.frequency.setValueAtTime(baseCutoff, time); filter.frequency.exponentialRampToValueAtTime(baseCutoff * 0.5, time + duration * 0.5);
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0, time); gain.gain.linearRampToValueAtTime(0.5 + (this.speedFactor * 0.5), time + 0.02); gain.gain.exponentialRampToValueAtTime(0.001, time + duration);
                osc.connect(filter); filter.connect(gain); gain.connect(this.bassNodes.gain);
                osc.start(time); osc.stop(time + duration + 0.1);
            }
            playHighArp(midi, time, duration) {
                const osc = this.ctx.createOscillator(); osc.type = 'sine'; osc.frequency.value = mtof(midi + 24); 
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0, time); gain.gain.linearRampToValueAtTime(0.08 * this.synthVolumeMult * (0.5 + 0.5 * this.timeOfDay), time + 0.01); gain.gain.exponentialRampToValueAtTime(0.001, time + duration);
                const panner = this.ctx.createStereoPanner(); panner.pan.value = Math.sin(time * 2) * 0.5;
                osc.connect(gain); gain.connect(panner); panner.connect(this.busses.arp); panner.connect(this.reverbNodes.input); 
                osc.start(time); osc.stop(time + duration + 0.1);
            }
            playSpacePluck(time) {
                const scale = this.getScaleNotes(this.currentRoot, this.currentScaleType);
                const midi = scale[(Math.floor(time) % 4) * 2 % 7] + 36; 
                const osc = this.ctx.createOscillator(); osc.type = 'sine'; osc.frequency.value = mtof(midi);
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0, time); gain.gain.linearRampToValueAtTime(0.05 * this.altitudeFactor * this.synthVolumeMult, time + 0.01); gain.gain.exponentialRampToValueAtTime(0.001, time + 0.3); 
                const pan = this.ctx.createStereoPanner(); pan.pan.value = Math.cos(time);
                osc.connect(gain); gain.connect(pan); pan.connect(this.busses.atmos);
                osc.start(time); osc.stop(time + 0.4);
            }
            playEarthyDrone(time) {
                const scale = this.getScaleNotes(this.currentRoot, this.currentScaleType);
                const note = scale[(Math.floor(this.barCount) % 2 === 0) ? 0 : 4] - 12;
                const osc = this.ctx.createOscillator(); osc.type = 'triangle'; osc.frequency.value = mtof(note);
                const filter = this.ctx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.value = 400;
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0, time); gain.gain.linearRampToValueAtTime(0.15 * (1.0 - this.altitudeFactor) * this.synthVolumeMult, time + 0.5); gain.gain.exponentialRampToValueAtTime(0.001, time + 3.0);
                const panner = this.ctx.createStereoPanner(); panner.pan.value = 0; 
                osc.connect(filter); filter.connect(gain); gain.connect(panner); panner.connect(this.busses.atmos); panner.connect(this.reverbNodes.input);
                osc.start(time); osc.stop(time + 3.2);
            }
            scheduler() {
                while (this.nextNoteTime < this.ctx.currentTime + this.scheduleAheadTime) {
                    this.scheduleNote(this.current16thNote, this.nextNoteTime);
                    this.nextNote();
                }
                setTimeout(() => this.scheduler(), 25);
            }
            nextNote() {
                const secondsPerBeat = 60.0 / this.tempo;
                let stepDuration = 0.25; 
                if (this.rhythmMode === 'SHUFFLE') {
                    // Swing: long-short
                    stepDuration = (this.current16thNote % 2 === 0) ? 0.32 : 0.18;
                } else if (this.rhythmMode === 'CHAABI') {
                    // Chaabi: Driving triplet-like feel, heavier swing
                    stepDuration = (this.current16thNote % 2 === 0) ? 0.35 : 0.15;
                }
                this.nextNoteTime += stepDuration * secondsPerBeat;
                this.current16thNote++;
                if (this.current16thNote === 16) {
                    this.current16thNote = 0; this.barCount++; this.barsInCurrentStage++; 
                    const stage = this.harmonicProgression[this.progressionIndex];
                    if (stage && this.barsInCurrentStage >= stage.bars) this.advanceHarmony();
                }
            }
            shouldPlayAtmosphere(beatNumber) { return (beatNumber % 16) === ((this.cycleCount % 4) * 4); }
            scheduleNote(beatNumber, time) {
                if (this.speedFactor < 0.05) return;
                const scale = this.getScaleNotes(this.currentRoot, this.currentScaleType);
                const step = 60.0 / this.tempo;
                let playBass = false; let bassDur = step * 2; let note = scale[0];
                if (this.speedFactor < 0.5) { if (beatNumber % 8 === 0) playBass = true; } 
                else { if (beatNumber % 2 === 0) { playBass = true; bassDur = step / 2; if (this.speedFactor > 0.8 && beatNumber % 4 !== 0) note += 12; } }
                if (playBass) this.playBassPulse(note, time, bassDur);
                const arpVariation = this.cycleCount % 3; 
                if (beatNumber % 4 === 0) {
                    let arpIndex = 0;
                    if (arpVariation === 0) arpIndex = (beatNumber / 4) % 4; 
                    else if (arpVariation === 1) arpIndex = 3 - ((beatNumber / 4) % 4); 
                    else arpIndex = [0, 2, 1, 3][(beatNumber/4)%4]; 
                    const offsets = [0, 4, 2, 1]; 
                    this.playHighArp(scale[offsets[arpIndex]], time, step);
                }
                if (this.shouldPlayAtmosphere(beatNumber)) {
                    if (this.altitudeFactor > 0.6) this.playSpacePluck(time);
                    if (this.altitudeFactor < 0.4) this.playEarthyDrone(time);
                }
                if (this.drumLevels.kick > 0.01) {
                    let kickTrig = false;
                    if (this.rhythmMode === 'STRAIGHT' || this.rhythmMode === 'SHUFFLE') {
                        if (beatNumber % 4 === 0) kickTrig = true; 
                    } else if (this.rhythmMode === 'CHAABI') {
                        // Chaabi Kick: Driving 12/8 feel (approximated on 16th grid with swing)
                        // Kick on 1, 3, 4 (and), 6... 
                        // Simplified syncopated gallop: 0, 3, 6, 10
                        if (beatNumber === 0 || beatNumber === 6 || beatNumber === 10) kickTrig = true; 
                    }
                    if (this.barCount % 4 === 3 && beatNumber > 12) kickTrig = true;
                    if (kickTrig) this.triggerKick(time);
                }
                if (this.drumLevels.snare > 0.01) {
                    let snareTrig = false;
                    if (this.rhythmMode === 'STRAIGHT' || this.rhythmMode === 'SHUFFLE') {
                        if (beatNumber % 8 === 4) snareTrig = true; 
                    } else if (this.rhythmMode === 'CHAABI') {
                        // Chaabi Tak: 4, 8, 12, 14
                        if (beatNumber === 4 || beatNumber === 8 || beatNumber === 12 || beatNumber === 14) snareTrig = true;
                    }
                    if (this.barCount % 8 === 7 && beatNumber > 10 && beatNumber % 2 === 0) snareTrig = true;
                    if (snareTrig) this.triggerSnare(time);
                }
                if (this.drumLevels.hat > 0.01) {
                    let playHat = false;
                    let isOpen = (beatNumber % 8 === 2);
                    if (this.speedFactor > 0.7) playHat = true;
                    else if (beatNumber % 2 === 0) playHat = true;
                    if (playHat) this.triggerHat(time, isOpen);
                }
            }
            resume() { if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume().then(() => this.updateStatus(true)); else if (!this.initialized) this.init(); }
            update(keys, speed, altitude, density, sunElevation, pos, quat, dt) {
                if (!this.initialized) return;
                const now = this.ctx.currentTime;
                this.speedFactor = THREE.MathUtils.clamp(speed / 4000.0, 0.0, 1.0); 
                
                if (this.speedFactor < 0.05) {
                    this.isStill = true; this.changePending = true;
                } else if (this.isStill && this.changePending && this.speedFactor > 0.1) {
                    this.changeMusicalContext(); this.isStill = false; this.changePending = false;
                }

                this.cloudDensity = isFinite(density) ? density : 0.0; 
                this.timeOfDay = Math.max(0, Math.sin(THREE.MathUtils.degToRad(sunElevation))); 
                this.altitudeFactor = THREE.MathUtils.clamp(altitude / 20000, 0.0, 1.0); 
                const pitchDelta = (keys.pitchUp ? -1 : 0) + (keys.pitchDown ? 1 : 0);
                const rollDelta = (keys.rollLeft ? -1 : 0) + (keys.rollRight ? 1 : 0);
                const currentG = Math.abs(pitchDelta) + Math.abs(rollDelta);
                this.gForce = THREE.MathUtils.lerp(this.gForce, currentG, dt);
                this.updateVolumes(dt);
                const targetCutoff = Math.min(20000 - (this.cloudDensity * 19000), 2000 + (this.timeOfDay * 18000));
                this.safeSetParam(this.masterFilter.frequency, Math.max(200, targetCutoff), now, 0.2);
                this.safeSetParam(this.reverbNodes.input.gain, CONFIG.volReverb + (this.altitudeFactor * 0.4), now, 0.5);
                this.tempo = 60 + (this.speedFactor * 80); 
                this.synthVolumeMult = 1.0 + (this.speedFactor * 0.5);
                this.safeSetParam(this.windNodes.filter.frequency, 100 + this.speedFactor * 2000, now, 0.1);
                this.safeSetParam(this.windNodes.gain.gain, this.speedFactor * 0.8 * CONFIG.volWind, now, 0.1);
                this.safeSetParam(this.cabinNodes.filter.frequency, 100 + (this.speedFactor * 50), now, 0.1);
                this.safeSetParam(this.cabinNodes.gain.gain, CONFIG.volCabin * (0.5 + 0.5*this.speedFactor), now, 0.1);
                let rollType = null;
                if (keys.rollLeft) rollType = 'ROLL_L'; else if (keys.rollRight) rollType = 'ROLL_R';
                this.manageVoice('roll', rollType, now);
                let pitchType = null;
                if (keys.pitchUp) pitchType = 'RISE'; else if (keys.pitchDown) pitchType = 'FALL';
                this.manageVoice('pitch', pitchType, now);
                let yawType = null;
                if (keys.yawLeft) yawType = 'YAW_L'; else if (keys.yawRight) yawType = 'YAW_R';
                this.manageVoice('yaw', yawType, now);
                if (spatialSoundSystem) spatialSoundSystem.update(0.016, pos, quat);
            }
        }

        const VERTEX_SHADER = `precision highp float; varying vec2 vUv; void main() { vUv = uv; gl_Position = vec4(position, 1.0); }`;

        const CLOUD_FRAGMENT = `
            precision highp float; precision highp sampler3D;
            varying vec2 vUv;
            uniform vec3 uCameraPos; uniform float uCameraY; uniform mat4 uInverseView; uniform mat4 uInverseProj;
            uniform float uTime; uniform vec3 uSunDir; uniform vec3 uSunColor; uniform float uSunIntensity; uniform vec3 uWorldOffset;
            uniform vec3 uCloudColorTop; uniform vec3 uCloudColorBottom; uniform vec3 uSkyColorZenith; uniform vec3 uSkyColorHorizon;
            uniform vec3 uSkySunsetZenith; uniform vec3 uSkySunsetHorizon; uniform vec3 uGroundColor;
            uniform float uCloudCover; uniform float uCloudDensity; uniform float uCloudAbsorption;
            uniform float uCloudBottom; uniform float uCloudTop; uniform float uDetailScale;
            uniform float uWindSpeed; uniform vec2 uWindDir; uniform float uErosion; uniform float uFadeBottom; uniform float uFadeTop; uniform float uDensityProfile;
            uniform float uMacroScale1; uniform float uMacroScale2; uniform float uMacroStrength2; uniform float uMacroScale3; uniform float uMacroStrength3;
            uniform float uMacroCoverage; uniform float uMacroDensity;
            uniform float uSilverLining; uniform float uSilverSpread; uniform float uAmbientIntensity; uniform float uPowder;
            uniform float uSteps; uniform int uLightSteps; uniform int uNoiseOctaves; uniform bool uDithering;
            uniform float uLodDistance; uniform float uMaxDist;
            uniform float uRayleigh; uniform float uMieCoeff; uniform float uMieG; uniform float uFogDensity;
            uniform sampler3D uNoiseTexture;
            uniform float uLightningIntensity;
            float getIGNoise(vec2 uv) { vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189); return fract(magic.z * fract(dot(uv, magic.xy))); }
            float hg(float a, float g) { float g2 = g*g; return (1.0 - g2) / (4.0 * 3.14159 * pow(1.0 + g2 - 2.0 * g * a, 1.5)); }
            float phase(float a) { float forward = hg(a, 0.8 * uSilverSpread); float backward = hg(a, -0.3); return mix(forward, backward, 1.0 - uSilverLining); }
            float sampleDetailNoise(vec3 pAbsolute, int octaves, float dist) {
                vec3 wind = vec3(uWindDir.x, 0.0, uWindDir.y) * uTime * uWindSpeed * 0.05;
                vec3 uv = (pAbsolute * 0.0001 * uDetailScale) + wind;
                float lod = smoothstep(0.0, uLodDistance, dist);
                float n = texture(uNoiseTexture, uv).r;
                float total = n * 0.5; float norm = 0.5;
                if (octaves > 1 && lod < 0.9) { float n2 = texture(uNoiseTexture, uv * 2.03 + 0.1).r; float w2 = 0.35 * (1.0 - lod * 0.5); total += n2 * w2; norm += w2; }
                if (octaves > 2 && lod < 0.5) { float n3 = texture(uNoiseTexture, uv * 4.01 + 0.2).r; float w3 = 0.15 * (1.0 - lod * 2.0); total += n3 * w3; norm += w3; }
                return total / norm;
            }
            float getDensity(vec3 pAbsolute, int octaves, float dist) {
                float thickness = uCloudTop - uCloudBottom; float h = (pAbsolute.y - uCloudBottom) / thickness; 
                if (h < 0.0 || h > 1.0) return 0.0;
                vec3 wind = vec3(uWindDir.x, 0.0, uWindDir.y) * uTime * uWindSpeed * 0.01;
                vec3 uv1 = (pAbsolute * 0.00001 * uMacroScale1) + wind;
                float m1 = texture(uNoiseTexture, uv1).r; float macro = m1;
                float macroLod = smoothstep(uLodDistance * 0.5, uLodDistance * 2.0, dist);
                if (macroLod < 0.9) { vec3 uv2 = (pAbsolute * 0.00001 * uMacroScale2) + wind * 0.5 + vec3(0.4); float m2 = texture(uNoiseTexture, uv2).r; macro = mix(macro, m2, uMacroStrength2 * (1.0 - macroLod)); }
                if (macroLod < 0.5) { vec3 uv3 = (pAbsolute * 0.00001 * uMacroScale3) + wind * 0.25 + vec3(0.8); float m3 = texture(uNoiseTexture, uv3).r; macro = mix(macro, m3, uMacroStrength3 * (1.0 - macroLod * 2.0)); }
                float biasedH = pow(h, 0.5 + (1.0 - uDensityProfile)); 
                float botLimit = (1.0 - macro) * uFadeBottom * 0.8; float gradBot = smoothstep(botLimit, uFadeBottom + 0.01, biasedH);
                float topLimit = (1.0 - macro) * uFadeTop * 0.8; float gradTop = 1.0 - smoothstep(1.0 - uFadeTop - 0.01, 1.0 - topLimit, biasedH);
                float grad = gradBot * gradTop;
                if (grad < 0.001) return 0.0;
                float localCover = clamp(uCloudCover + (macro - 0.5) * uMacroCoverage, 0.0, 1.0);
                float densityMult = max(0.0, 1.0 + (macro - 0.5) * uMacroDensity);
                float noise = sampleDetailNoise(pAbsolute, octaves, dist);
                float erosion = mix(noise, pow(noise, 2.5), uErosion);
                float d = smoothstep(1.0 - localCover, 1.0, erosion);
                return d * grad * uCloudDensity * densityMult * (1.0 - smoothstep(uMaxDist * 0.8, uMaxDist, dist));
            }
            float getLight(vec3 pAbsolute, vec3 sunDir, float ph, float jitter) {
                float step = 25.0; float dist = 0.0;
                vec3 pos = pAbsolute + sunDir * step * jitter;
                for(int i = 0; i < 24; i++) { 
                    if (i >= uLightSteps) break; if(pos.y > uCloudTop || pos.y < uCloudBottom) break;
                    float d = getDensity(pos, 2, 10000.0);
                    dist += d * step; if (dist > 8.0) break; step *= 1.4; pos += sunDir * step;
                }
                float T = exp(-dist * uCloudAbsorption);
                float powder = 1.0 - exp(-dist * uCloudAbsorption * 2.0);
                return T * (0.3 + 0.7 * mix(1.0, powder, uPowder)) * ph;
            }
            vec3 computeSky(vec3 rd, vec3 sunDir) {
                float sunY = sunDir.y; float mu = dot(rd, sunDir);
                float sunsetT = smoothstep(0.2, -0.1, sunY);
                vec3 zenColor = mix(uSkyColorZenith, uSkySunsetZenith, sunsetT);
                vec3 horColor = mix(uSkyColorHorizon, uSkySunsetHorizon, sunsetT);
                if (sunY < -0.1) {
                    float nightT = smoothstep(-0.1, -0.4, sunY);
                    vec3 nightColor = vec3(0.02, 0.02, 0.05);
                    zenColor = mix(zenColor, nightColor, nightT); horColor = mix(horColor, nightColor, nightT);
                }
                vec3 sky = mix(horColor, zenColor, pow(min(1.0, abs(rd.y) + 0.1), 0.5));
                sky += vec3(0.8, 0.85, 1.0) * uLightningIntensity * 0.2; 
                float sunScat = 1.0 / (4.0 * 3.14159) * ((1.0 - uMieG*uMieG) / pow(1.0 + uMieG*uMieG - 2.0*uMieG*mu, 1.5));
                float hazeMix = smoothstep(-0.1, 0.1, sunY); 
                sky += mix(vec3(1.0, 0.5, 0.2), uSunColor, hazeMix) * sunScat * uMieCoeff * 10.0;
                sky += smoothstep(0.9995, 0.9999, mu) * uSunColor * 50.0 * uSunIntensity; 
                if (rd.y < 0.0) {
                     float groundFog = 1.0 - exp(-20000.0 * uFogDensity); 
                     sky = mix(uGroundColor, sky, groundFog * 0.5); 
                     sky = mix(sky, horColor, smoothstep(-0.2, 0.0, rd.y));
                }
                return sky;
            }
            void main() {
                vec4 ndc = vec4(vUv * 2.0 - 1.0, -1.0, 1.0);
                vec4 view = uInverseProj * ndc; view /= view.w;
                vec3 world = (uInverseView * view).xyz;
                vec3 ro = uCameraPos; vec3 rd = normalize(world - ro);
                vec3 col = computeSky(rd, uSunDir);
                float rdy = rd.y; if (abs(rdy) < 1e-5) rdy = sign(rdy) * 1e-5;
                float absCamY = ro.y + uCameraY;
                float tBot = (uCloudBottom - absCamY) / rdy; float tTop = (uCloudTop - absCamY) / rdy;
                float tNear = max(0.0, min(tBot, tTop)); float tFar = min(max(tBot, tTop), uMaxDist);
                float marchDist = tFar - tNear;
                if (marchDist > 0.0) {
                    float baseStep = 150.0; float layerThickness = uCloudTop - uCloudBottom; float maxStepAllowed = layerThickness * 0.25; 
                    float dither = uDithering ? getIGNoise(gl_FragCoord.xy) : 0.0;
                    float t = tNear + dither * baseStep;
                    float sunDot = dot(rd, uSunDir); float ph = phase(sunDot);
                    vec4 sum = vec4(0.0);
                    for(int i = 0; i < 512; i++) {
                        if (sum.a >= 0.99 || t > tFar || float(i) > uSteps * 1.5) break; 
                        vec3 currP = ro + rd * t;
                        vec3 absP = currP + vec3(uWorldOffset.x, uCameraY, uWorldOffset.z);
                        float currentStep = min(baseStep * (1.0 + t * 0.0001), maxStepAllowed);
                        if (absP.y >= uCloudBottom - 100.0 && absP.y <= uCloudTop + 100.0) {
                            float d = getDensity(absP, uNoiseOctaves, t);
                            if (d > 0.001) {
                                float lit = getLight(absP, uSunDir, ph, dither);
                                lit += uLightningIntensity * 2.0 * exp(-d * 500.0);
                                float relH = clamp((absP.y - uCloudBottom) / layerThickness, 0.0, 1.0);
                                vec3 ambient = mix(uCloudColorBottom, uCloudColorTop, relH) * uAmbientIntensity;
                                vec3 radiance = uSunColor * lit * 2.5 + ambient;
                                float alpha = 1.0 - exp(-d * currentStep * uCloudAbsorption);
                                sum.rgb += radiance * alpha * (1.0 - sum.a); sum.a += alpha * (1.0 - sum.a);
                            }
                        }
                        t += currentStep;
                    }
                    float fogAmount = 1.0 - exp(-tNear * uFogDensity);
                    sum.rgb = mix(sum.rgb, computeSky(rd, uSunDir), fogAmount);
                    col = mix(col, sum.rgb, sum.a);
                }
                gl_FragColor = vec4(col, 1.0);
            }
        `;

        const DENOISE_FRAGMENT = `
            precision highp float; varying vec2 vUv; uniform sampler2D tDiffuse; uniform vec2 uResolution; uniform bool uEnable;
            void main() {
                if (!uEnable) { gl_FragColor = texture2D(tDiffuse, vUv); return; }
                vec2 texel = 1.0 / uResolution;
                vec3 center = texture2D(tDiffuse, vUv).rgb;
                vec3 sum = center * 0.25; float total = 0.25;
                sum += (texture2D(tDiffuse, vUv + vec2(1, 0) * texel).rgb + texture2D(tDiffuse, vUv + vec2(-1, 0) * texel).rgb + texture2D(tDiffuse, vUv + vec2(0, 1) * texel).rgb + texture2D(tDiffuse, vUv + vec2(0, -1) * texel).rgb) * 0.125; total += 0.5;
                sum += (texture2D(tDiffuse, vUv + vec2(1, 1) * texel).rgb + texture2D(tDiffuse, vUv + vec2(-1, 1) * texel).rgb + texture2D(tDiffuse, vUv + vec2(1, -1) * texel).rgb + texture2D(tDiffuse, vUv + vec2(-1, -1) * texel).rgb) * 0.0625; total += 0.25;
                gl_FragColor = vec4(sum / total, 1.0);
            }
        `;

        const TAA_FRAGMENT = `
            precision highp float; varying vec2 vUv; uniform sampler2D tCurrent; uniform sampler2D tHistory; uniform mat4 uInvViewProj; uniform mat4 uPrevViewProj; uniform float uBlend; uniform bool uEnable; uniform vec2 uResolution;
            void main() {
                if (!uEnable) { gl_FragColor = texture2D(tCurrent, vUv); return; }
                vec4 clip = vec4(vUv * 2.0 - 1.0, 1.0, 1.0); vec4 world = uInvViewProj * clip; world /= world.w; vec4 prevClip = uPrevViewProj * world; prevClip /= prevClip.w; vec2 prevUv = prevClip.xy * 0.5 + 0.5;
                vec4 curr = texture2D(tCurrent, vUv);
                if (prevUv.x < 0.0 || prevUv.x > 1.0 || prevUv.y < 0.0 || prevUv.y > 1.0) { gl_FragColor = curr; return; }
                vec4 hist = texture2D(tHistory, prevUv);
                vec2 texel = 1.0 / uResolution;
                vec3 n1 = texture2D(tCurrent, vUv + vec2(1,0)*texel).rgb; vec3 n2 = texture2D(tCurrent, vUv - vec2(1,0)*texel).rgb; vec3 n3 = texture2D(tCurrent, vUv + vec2(0,1)*texel).rgb; vec3 n4 = texture2D(tCurrent, vUv - vec2(0,1)*texel).rgb;
                vec3 minC = min(curr.rgb, min(min(n1, n2), min(n3, n4))); vec3 maxC = max(curr.rgb, max(max(n1, n2), max(n3, n4)));
                hist.rgb = clamp(hist.rgb, minC, maxC);
                gl_FragColor = mix(curr, hist, uBlend);
            }
        `;

        const GODRAY_FRAGMENT = `
            precision highp float; varying vec2 vUv; uniform sampler2D tDiffuse; uniform vec2 uSunPosScreen; uniform float uDensity; uniform float uDecay; uniform float uWeight; uniform float uExposure; uniform bool uSunVisible; uniform int uSamples;
            float getIGNoise(vec2 uv) { vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189); return fract(magic.z * fract(dot(uv, magic.xy))); }
            void main() {
                if (!uSunVisible) { gl_FragColor = vec4(0.0); return; }
                vec2 uv = vUv; vec2 delta = (uv - uSunPosScreen) * uDensity / float(uSamples);
                float dither = getIGNoise(gl_FragCoord.xy); uv -= delta * dither;
                vec3 accum = vec3(0.0); float decay = 1.0;
                for(int i=0; i<200; i++) {
                    if (i >= uSamples) break; uv -= delta; if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) break;
                    vec3 s = texture2D(tDiffuse, uv).rgb; float luma = dot(s, vec3(0.2126, 0.7152, 0.0722));
                    accum += s * smoothstep(0.9, 1.2, luma) * uWeight * decay; decay *= uDecay;
                }
                gl_FragColor = vec4(accum * uExposure, 1.0);
            }
        `;

        const COMPOSITE_FRAGMENT = `
            precision highp float; varying vec2 vUv; uniform sampler2D tColor; uniform sampler2D tGodRays; uniform float uRayIntensity;
            vec3 aces(vec3 x) { return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0); }
            void main() {
                vec3 col = texture2D(tColor, vUv).rgb; vec3 rays = texture2D(tGodRays, vUv).rgb;
                gl_FragColor = vec4(pow(aces(col + rays * uRayIntensity), vec3(1.0/2.2)), 1.0);
            }
        `;

        class FlightControls {
            constructor(camera) {
                this.camera = camera; this.worldPos = new THREE.Vector3(0, 3000, 5000);
                this.currentSpeed = 0.0; this.maxSpeed = 3000.0; this.throttle = 0.0;
                this.velocity = new THREE.Vector3();
                this.pitchRate = 1.2; this.rollRate = 1.5; this.yawRate = 0.5; this.throttleRate = 0.5;
                this.pitchStability = 0.5; this.rollStability = 2.0;
                this.keys = { pitchUp: false, pitchDown: false, rollLeft: false, rollRight: false, yawLeft: false, yawRight: false, throttleUp: false, throttleDown: false };
                this._rotQuat = new THREE.Quaternion(); this._euler = new THREE.Euler(); this._forward = new THREE.Vector3();
                this.initEvents();
            }
            initEvents() {
                this.onKeyDown = (e) => this.handleKey(e, true);
                this.onKeyUp = (e) => this.handleKey(e, false);
                document.addEventListener('keydown', this.onKeyDown); document.addEventListener('keyup', this.onKeyUp);
                const startBtn = document.getElementById('start-screen');
                startBtn.addEventListener('click', () => { startBtn.classList.add('fade-out'); if (audioManager) audioManager.resume(); });
            }
            handleKey(e, isDown) {
                const setKeyActive = (id, active) => { const el = document.getElementById(id); if(el) active ? el.classList.add('active') : el.classList.remove('active'); };
                switch (e.code) {
                    case 'KeyW': this.keys.pitchDown = isDown; setKeyActive('k-w', isDown); break;
                    case 'KeyS': this.keys.pitchUp = isDown; setKeyActive('k-s', isDown); break;
                    case 'KeyA': this.keys.rollLeft = isDown; setKeyActive('k-a', isDown); break;
                    case 'KeyD': this.keys.rollRight = isDown; setKeyActive('k-d', isDown); break;
                    case 'ArrowLeft': this.keys.yawLeft = isDown; setKeyActive('k-l', isDown); break;
                    case 'ArrowRight': this.keys.yawRight = isDown; setKeyActive('k-r', isDown); break;
                    case 'ArrowUp': this.keys.throttleUp = isDown; setKeyActive('k-u', isDown); break;
                    case 'ArrowDown': this.keys.throttleDown = isDown; setKeyActive('k-dn', isDown); break;
                    case 'KeyH': if (isDown) { const ui = document.querySelector('.lil-gui'); const over = document.getElementById('overlay'); if (ui) ui.style.display = ui.style.display === 'none' ? 'block' : 'none'; if (over) over.classList.toggle('hidden'); } break;
                }
            }
            update(dt) {
                const inputPitch = (this.keys.pitchDown ? 1 : 0) + (this.keys.pitchUp ? -1 : 0);
                const inputRoll = (this.keys.rollRight ? -1 : 0) + (this.keys.rollLeft ? 1 : 0);
                const inputYaw = (this.keys.yawRight ? -1 : 0) + (this.keys.yawLeft ? 1 : 0);
                const inputThrottle = (this.keys.throttleUp ? 1 : 0) + (this.keys.throttleDown ? -1 : 0);
                if (inputThrottle !== 0) this.throttle = THREE.MathUtils.clamp(this.throttle + inputThrottle * this.throttleRate * dt, 0.0, 1.0);
                let targetSpeed = this.throttle * this.maxSpeed;
                this.currentSpeed = THREE.MathUtils.lerp(this.currentSpeed, targetSpeed, dt * 0.5);
                this._rotQuat.setFromEuler(this._euler.set(inputPitch * this.pitchRate * dt, inputYaw * this.yawRate * dt, inputRoll * this.rollRate * dt, 'YXZ'));
                this.camera.quaternion.multiply(this._rotQuat);
                const speedRatio = this.currentSpeed / this.maxSpeed;
                const shakeAmt = Math.pow(speedRatio, 3.0) * 0.005; 
                this.camera.rotateX((Math.random()-0.5) * shakeAmt);
                this.camera.rotateZ((Math.random()-0.5) * shakeAmt);
                this._euler.setFromQuaternion(this.camera.quaternion, 'YXZ');
                this._euler.x = Math.max(-1.5, Math.min(1.5, this._euler.x)); 
                if (inputPitch === 0) this._euler.x = THREE.MathUtils.lerp(this._euler.x, 0, 1.0 - Math.exp(-this.pitchStability * dt));
                if (inputRoll === 0) this._euler.z = THREE.MathUtils.lerp(this._euler.z, 0, 1.0 - Math.exp(-this.rollStability * dt));
                this.camera.quaternion.setFromEuler(this._euler).normalize();
                this._forward.set(0, 0, -1).applyQuaternion(this.camera.quaternion);
                this.velocity.lerp(this._forward.multiplyScalar(this.currentSpeed), dt * 1.5);
                this.worldPos.addScaledVector(this.velocity, dt);
                document.getElementById('val-alt').innerText = Math.round(this.worldPos.y * 3.28);
                document.getElementById('val-spd').innerText = Math.round(this.currentSpeed * 1.94);
                document.getElementById('val-pos').innerText = `${(this.worldPos.z/1000).toFixed(1)}, ${(this.worldPos.x/1000).toFixed(1)}`;
            }
        }

        function sampleNoiseData(x, y, z) {
            if (!globalNoiseData) return 0.0;
            const dataSize = Math.round(Math.pow(globalNoiseData.length, 1.0/3.0));
            const idx = (x, y, z) => ((x % dataSize + dataSize) % dataSize) + ((y % dataSize + dataSize) % dataSize) * dataSize + ((z % dataSize + dataSize) % dataSize) * dataSize * dataSize;
            let ix = Math.floor(x); let fx = x - ix; let iy = Math.floor(y); let fy = y - iy; let iz = Math.floor(z); let fz = z - iz;
            const lerp = (a, b, t) => a + t * (b - a);
            const c000 = globalNoiseData[idx(ix, iy, iz)]; const c100 = globalNoiseData[idx(ix+1, iy, iz)];
            const c010 = globalNoiseData[idx(ix, iy+1, iz)]; const c110 = globalNoiseData[idx(ix+1, iy+1, iz)];
            const c001 = globalNoiseData[idx(ix, iy, iz+1)]; const c101 = globalNoiseData[idx(ix+1, iy, iz+1)];
            const c011 = globalNoiseData[idx(ix, iy+1, iz+1)]; const c111 = globalNoiseData[idx(ix+1, iy+1, iz+1)];
            return lerp(lerp(lerp(c000, c100, fx), lerp(c010, c110, fx), fy), lerp(lerp(c001, c101, fx), lerp(c011, c111, fx), fy), fz);
        }

        function generateNoiseTexture(size) {
            return new Promise((resolve) => {
                const blob = new Blob([NOISE_WORKER_CODE], {type: 'application/javascript'});
                if (noiseWorker) noiseWorker.terminate(); 
                noiseWorker = new Worker(URL.createObjectURL(blob));
                const progressFill = document.getElementById('progress-fill');
                noiseWorker.onmessage = function(e) {
                    if (e.data.progress) { progressFill.style.width = (e.data.progress * 100) + '%'; }
                    else if (e.data.done) {
                        globalNoiseData = e.data.data;
                        const tex = new THREE.Data3DTexture(e.data.data, size, size, size);
                        tex.format = THREE.RedFormat; tex.type = THREE.FloatType;
                        tex.minFilter = THREE.LinearFilter; tex.magFilter = THREE.LinearFilter;
                        tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping; tex.wrapR = THREE.RepeatWrapping;
                        tex.needsUpdate = true;
                        resolve(tex);
                    }
                };
                noiseWorker.postMessage({size: size});
            });
        }

        function getCPUDensity(pAbsolute, time) {
            if (!globalNoiseData) return 0.0;
            const dataSize = Math.round(Math.pow(globalNoiseData.length, 1.0/3.0));
            const h = (pAbsolute.y - CONFIG.cloudBottom) / (CONFIG.cloudTop - CONFIG.cloudBottom);
            if (h < 0.0 || h > 1.0) return 0.0;
            const wind = new THREE.Vector3(Math.sin(CONFIG.windAngle), 0, Math.cos(CONFIG.windAngle)).multiplyScalar(time * CONFIG.windSpeed);
            const scale = dataSize / 128.0; 
            let uv1 = pAbsolute.clone().multiplyScalar(0.00001 * CONFIG.macroScale1).add(wind);
            let m1 = sampleNoiseData(uv1.x * 128 * scale, uv1.y * 128 * scale, uv1.z * 128 * scale);
            let uv2 = pAbsolute.clone().multiplyScalar(0.00001 * CONFIG.macroScale2).add(wind.clone().multiplyScalar(0.5)).addScalar(0.4);
            let m2 = sampleNoiseData(uv2.x * 128 * scale, uv2.y * 128 * scale, uv2.z * 128 * scale);
            let macro = THREE.MathUtils.lerp(m1, m2, CONFIG.macroStrength2);
            let biasedH = Math.pow(h, 0.5 + (1.0 - CONFIG.densityProfile));
            let botLimit = (1.0 - macro) * CONFIG.fadeBottom * 0.8;
            let gradBot = THREE.MathUtils.smoothstep(botLimit, CONFIG.fadeBottom + 0.01, biasedH);
            let topLimit = (1.0 - macro) * CONFIG.fadeTop * 0.8;
            let gradTop = 1.0 - THREE.MathUtils.smoothstep(1.0 - CONFIG.fadeTop - 0.01, 1.0 - topLimit, biasedH);
            let grad = gradBot * gradTop;
            const res = 0.5 * grad * CONFIG.cloudDensity;
            return isFinite(res) ? res : 0.0;
        }

        const PresetManager = {
            presets: {
                "Default": DEFAULT_CONFIG,
                "Stormy": { ...DEFAULT_CONFIG, cloudColorBottom: '#1a1f26', cloudColorTop: '#55606e', cloudCover: 0.8, cloudDensity: 2.0, cloudAbsorption: 3.5, erosion: 0.2, sunElevation: 5, lightSteps: 12 },
                "Sunset": { ...DEFAULT_CONFIG, sunElevation: -1.5, cloudColorBottom: '#2d1c30', cloudColorTop: '#ff9d6b', cloudCover: 0.5, godRays: true, rayWeight: 0.8, rayDecay: 0.99, raySamples: 100 },
                "Performance": { ...DEFAULT_CONFIG, resolution: 0.25, steps: 32, lightSteps: 4, godRays: false, noiseOctaves: 1, enableDenoise: false, enableTAA: false }
            },
            savePreset: () => { const b = new Blob([JSON.stringify(CONFIG, null, 2)], {type: 'application/json'}); const u = URL.createObjectURL(b); const a = document.createElement('a'); a.href = u; a.download = 'cloud_preset.json'; a.click(); },
            loadFromFile: () => { const i = document.createElement('input'); i.type = 'file'; i.accept = 'application/json'; i.onchange = (e) => { const f = e.target.files[0]; if(!f) return; const r = new FileReader(); r.onload = (ev) => { try { Object.assign(CONFIG, JSON.parse(ev.target.result)); if(uiGui) { uiGui.controllersRecursive().forEach(c => c.updateDisplay()); window.dispatchEvent(new Event('resize')); } } catch(err) { console.error("Invalid Preset File"); } }; r.readAsText(f); }; i.click(); },
            loadPreset: (name) => { let d = PresetManager.presets[name]; if (d) { Object.assign(CONFIG, d); if (uiGui) { uiGui.controllersRecursive().forEach(c => c.updateDisplay()); if (d.resolution !== undefined) window.dispatchEvent(new Event('resize')); } } },
            exportClipboard: () => { navigator.clipboard.writeText(JSON.stringify(CONFIG)); alert("Preset copied to clipboard!"); },
            regenerateNoise: async () => {
                const el = document.getElementById('loading'); el.classList.remove('hidden'); el.style.opacity = '1'; document.getElementById('loading-text').innerText = "REGENERATING NOISE...";
                globalNoiseData = null;
                const tex = await generateNoiseTexture(CONFIG.textureSize);
                cloudMat.uniforms.uNoiseTexture.value = tex;
                el.style.opacity = '0'; setTimeout(() => el.classList.add('hidden'), 500);
            }
        };

        async function init() {
            audioManager = new AtmosphereAudio();
            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setPixelRatio(1.0); renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            const rtParams = { type: THREE.HalfFloatType, format: THREE.RGBAFormat, minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter };
            cloudTarget = new THREE.WebGLRenderTarget(1, 1, rtParams);
            denoiseTarget = new THREE.WebGLRenderTarget(1, 1, rtParams);
            historyTarget = new THREE.WebGLRenderTarget(1, 1, rtParams);
            taaTarget = new THREE.WebGLRenderTarget(1, 1, rtParams);
            rayTarget = new THREE.WebGLRenderTarget(1, 1, rtParams);

            scene = new THREE.Scene(); camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 200000);
            flightControls = new FlightControls(camera);
            
            rainSystem = new RainSystem(scene);

            const noiseTex = await generateNoiseTexture(CONFIG.textureSize);
            const el = document.getElementById('loading'); el.style.opacity = '0'; setTimeout(() => el.classList.add('hidden'), 500);

            cloudMat = new THREE.ShaderMaterial({ vertexShader: VERTEX_SHADER, fragmentShader: CLOUD_FRAGMENT, uniforms: { uTime: { value: 0 }, uCameraPos: { value: new THREE.Vector3() }, uCameraY: { value: flightControls.worldPos.y }, uInverseView: { value: new THREE.Matrix4() }, uInverseProj: { value: new THREE.Matrix4() }, uSunDir: { value: new THREE.Vector3() }, uSunColor: { value: new THREE.Color(1.0, 1.0, 1.0) }, uSunIntensity: { value: CONFIG.sunIntensity }, uWorldOffset: { value: new THREE.Vector3() }, uCloudColorTop: { value: new THREE.Color(CONFIG.cloudColorTop) }, uCloudColorBottom: { value: new THREE.Color(CONFIG.cloudColorBottom) }, uSkyColorZenith: { value: new THREE.Color(CONFIG.skyColorZenith) }, uSkyColorHorizon: { value: new THREE.Color(CONFIG.skyColorHorizon) }, uSkySunsetZenith: { value: new THREE.Color(CONFIG.skySunsetZenith) }, uSkySunsetHorizon: { value: new THREE.Color(CONFIG.skySunsetHorizon) }, uGroundColor: { value: new THREE.Color(CONFIG.groundColor) }, uCloudCover: { value: CONFIG.cloudCover }, uCloudDensity: { value: CONFIG.cloudDensity }, uCloudAbsorption: { value: CONFIG.cloudAbsorption }, uCloudBottom: { value: CONFIG.cloudBottom }, uCloudTop: { value: CONFIG.cloudTop }, uDetailScale: { value: CONFIG.noiseScale }, uWindSpeed: { value: CONFIG.windSpeed }, uWindDir: { value: new THREE.Vector2(Math.sin(CONFIG.windAngle), Math.cos(CONFIG.windAngle)) }, uErosion: { value: CONFIG.erosion }, uDensityProfile: { value: CONFIG.densityProfile }, uFadeBottom: { value: CONFIG.fadeBottom }, uFadeTop: { value: CONFIG.fadeTop }, uMacroScale1: { value: CONFIG.macroScale1 }, uMacroScale2: { value: CONFIG.macroScale2 }, uMacroStrength2: { value: CONFIG.macroStrength2 }, uMacroScale3: { value: CONFIG.macroScale3 }, uMacroStrength3: { value: CONFIG.macroStrength3 }, uMacroCoverage: { value: CONFIG.macroCoverage }, uMacroDensity: { value: CONFIG.macroDensity }, uSilverLining: { value: CONFIG.silverLining }, uSilverSpread: { value: CONFIG.silverSpread }, uAmbientIntensity: { value: CONFIG.ambientIntensity }, uPowder: { value: CONFIG.powder }, uSteps: { value: CONFIG.steps }, uLightSteps: { value: CONFIG.lightSteps }, uNoiseOctaves: { value: CONFIG.noiseOctaves }, uDithering: { value: CONFIG.dithering }, uLodDistance: { value: CONFIG.lodDistance }, uMaxDist: { value: CONFIG.maxDist }, uRayleigh: { value: CONFIG.rayleigh }, uMieCoeff: { value: CONFIG.mieCoefficient }, uMieG: { value: CONFIG.mieDirectionalG }, uFogDensity: { value: CONFIG.fogDensity }, uNoiseTexture: { value: noiseTex }, uLightningIntensity: { value: 0.0 } }, depthWrite: false, depthTest: false });
            denoiseMat = new THREE.ShaderMaterial({ vertexShader: VERTEX_SHADER, fragmentShader: DENOISE_FRAGMENT, uniforms: { tDiffuse: { value: null }, uResolution: { value: new THREE.Vector2() }, uEnable: { value: CONFIG.enableDenoise } }, depthWrite: false, depthTest: false });
            taaMat = new THREE.ShaderMaterial({ vertexShader: VERTEX_SHADER, fragmentShader: TAA_FRAGMENT, uniforms: { tCurrent: { value: null }, tHistory: { value: null }, uInvViewProj: { value: new THREE.Matrix4() }, uPrevViewProj: { value: new THREE.Matrix4() }, uBlend: { value: CONFIG.taaBlend }, uEnable: { value: CONFIG.enableTAA }, uResolution: { value: new THREE.Vector2() } }, depthWrite: false, depthTest: false });
            rayMat = new THREE.ShaderMaterial({ vertexShader: VERTEX_SHADER, fragmentShader: GODRAY_FRAGMENT, uniforms: { tDiffuse: { value: null }, uSunPosScreen: { value: new THREE.Vector2() }, uSunVisible: { value: true }, uDensity: { value: CONFIG.rayDensity }, uDecay: { value: CONFIG.rayDecay }, uWeight: { value: CONFIG.rayWeight }, uExposure: { value: CONFIG.rayExposure }, uSamples: { value: CONFIG.raySamples } }, depthWrite: false, depthTest: false });
            compositeMat = new THREE.ShaderMaterial({ vertexShader: VERTEX_SHADER, fragmentShader: COMPOSITE_FRAGMENT, uniforms: { tColor: { value: null }, tGodRays: { value: null }, uRayIntensity: { value: CONFIG.rayIntensity } }, depthWrite: false, depthTest: false });

            const quadGeo = new THREE.PlaneGeometry(2, 2);
            const quad = new THREE.Mesh(quadGeo, cloudMat); quad.frustumCulled = false; scene.add(quad);
            postScene = new THREE.Scene(); postQuad = new THREE.Mesh(quadGeo, rayMat); postScene.add(postQuad);

            uiGui = new GUI({ title: 'Cloud Engine v8 - Definitive' });
            
            const presetF = uiGui.addFolder('Presets');
            presetF.add({ load: 'Default' }, 'load', Object.keys(PresetManager.presets)).name('Load Preset').onChange(v => PresetManager.loadPreset(v));
            presetF.add(PresetManager, 'savePreset'); presetF.add(PresetManager, 'loadFromFile'); presetF.add(PresetManager, 'exportClipboard');
            
            const genF = uiGui.addFolder('Texture Gen (Asset)');
            genF.add(CONFIG, 'textureSize', [64, 128, 256]).name('Noise Size'); 
            genF.add(PresetManager, 'regenerateNoise').name('Regenerate Now');

            const autoF = uiGui.addFolder('Automation');
            autoF.add(CONFIG, 'autoSun').name('Cycle Sun');
            const autoSunF = autoF.addFolder('Sun Cycle Details'); 
            autoSunF.add(AUTOMATION.sun, 'enabled'); autoSunF.add(AUTOMATION.sun, 'speed', 0.01, 1.0);
            
            const envF = uiGui.addFolder('Environment');
            envF.add(CONFIG, 'sunElevation', -10, 90).step(0.1); 
            envF.add(CONFIG, 'sunAzimuth', 0, 360); 
            envF.add(CONFIG, 'sunIntensity', 0, 10).onChange(v => cloudMat.uniforms.uSunIntensity.value = v);
            
            const cloudF = uiGui.addFolder('Cloud Properties');
            cloudF.add(CONFIG, 'cloudCover', 0, 1).onChange(v => cloudMat.uniforms.uCloudCover.value = v);
            cloudF.add(CONFIG, 'cloudDensity', 0, 3).onChange(v => cloudMat.uniforms.uCloudDensity.value = v);
            cloudF.add(CONFIG, 'cloudAbsorption', 0, 5).onChange(v => cloudMat.uniforms.uCloudAbsorption.value = v);
            cloudF.add(CONFIG, 'cloudBottom', 0, 10000).onChange(v => cloudMat.uniforms.uCloudBottom.value = v);
            cloudF.add(CONFIG, 'cloudTop', 1000, 20000).onChange(v => cloudMat.uniforms.uCloudTop.value = v);
            cloudF.add(CONFIG, 'windSpeed', 0, 2.0).onChange(v => cloudMat.uniforms.uWindSpeed.value = v);
            
            const shapeF = uiGui.addFolder('Cloud Shape');
            shapeF.add(CONFIG, 'noiseScale', 1, 10).name('Detail Scale').onChange(v => cloudMat.uniforms.uDetailScale.value = v);
            shapeF.add(CONFIG, 'erosion', 0, 1).onChange(v => cloudMat.uniforms.uErosion.value = v);
            shapeF.add(CONFIG, 'densityProfile', 0, 1).onChange(v => cloudMat.uniforms.uDensityProfile.value = v);
            shapeF.add(CONFIG, 'fadeBottom', 0, 1).onChange(v => cloudMat.uniforms.uFadeBottom.value = v);
            shapeF.add(CONFIG, 'fadeTop', 0, 1).onChange(v => cloudMat.uniforms.uFadeTop.value = v);

            const macroF = uiGui.addFolder('Macro Details');
            macroF.add(CONFIG, 'macroScale1', 1, 20).onChange(v => cloudMat.uniforms.uMacroScale1.value = v);
            macroF.add(CONFIG, 'macroScale2', 1, 50).onChange(v => cloudMat.uniforms.uMacroScale2.value = v);
            macroF.add(CONFIG, 'macroStrength2', 0, 1).onChange(v => cloudMat.uniforms.uMacroStrength2.value = v);
            macroF.add(CONFIG, 'macroScale3', 1, 100).onChange(v => cloudMat.uniforms.uMacroScale3.value = v);
            macroF.add(CONFIG, 'macroStrength3', 0, 1).onChange(v => cloudMat.uniforms.uMacroStrength3.value = v);
            macroF.add(CONFIG, 'macroCoverage', 0, 1).onChange(v => cloudMat.uniforms.uMacroCoverage.value = v);
            macroF.add(CONFIG, 'macroDensity', 0, 2).onChange(v => cloudMat.uniforms.uMacroDensity.value = v);

            const lightF = uiGui.addFolder('Lighting Model');
            lightF.add(CONFIG, 'silverLining', 0, 1).onChange(v => cloudMat.uniforms.uSilverLining.value = v);
            lightF.add(CONFIG, 'silverSpread', 0, 2).onChange(v => cloudMat.uniforms.uSilverSpread.value = v);
            lightF.add(CONFIG, 'ambientIntensity', 0, 1).onChange(v => cloudMat.uniforms.uAmbientIntensity.value = v);
            lightF.add(CONFIG, 'powder', 0, 2).onChange(v => cloudMat.uniforms.uPowder.value = v);
            lightF.add(CONFIG, 'lightSteps', 4, 32).step(1).onChange(v => cloudMat.uniforms.uLightSteps.value = v);

            const atmosF = uiGui.addFolder('Atmosphere');
            atmosF.add(CONFIG, 'rayleigh', 0, 4).onChange(v => cloudMat.uniforms.uRayleigh.value = v);
            atmosF.add(CONFIG, 'mieCoefficient', 0, 0.1).onChange(v => cloudMat.uniforms.uMieCoeff.value = v);
            atmosF.add(CONFIG, 'mieDirectionalG', 0, 0.99).onChange(v => cloudMat.uniforms.uMieG.value = v);
            atmosF.add(CONFIG, 'fogDensity', 0, 0.001).decimals(6).onChange(v => cloudMat.uniforms.uFogDensity.value = v);

            const raysF = uiGui.addFolder('God Rays');
            raysF.add(CONFIG, 'godRays').name('Enabled');
            raysF.add(CONFIG, 'rayIntensity', 0, 2).onChange(v => compositeMat.uniforms.uRayIntensity.value = v);
            raysF.add(CONFIG, 'rayDensity', 0, 2).onChange(v => rayMat.uniforms.uDensity.value = v);
            raysF.add(CONFIG, 'rayDecay', 0.8, 1.0).onChange(v => rayMat.uniforms.uDecay.value = v);
            raysF.add(CONFIG, 'rayWeight', 0, 1.0).onChange(v => rayMat.uniforms.uWeight.value = v);
            raysF.add(CONFIG, 'rayExposure', 0, 1.0).onChange(v => rayMat.uniforms.uExposure.value = v);
            raysF.add(CONFIG, 'raySamples', 10, 100).step(1).onChange(v => rayMat.uniforms.uSamples.value = v);

            const renderF = uiGui.addFolder('Performance / Quality');
            const onResChange = () => { const w = window.innerWidth, h = window.innerHeight; cloudTarget.setSize(w*CONFIG.resolution, h*CONFIG.resolution); denoiseTarget.setSize(w*CONFIG.resolution, h*CONFIG.resolution); historyTarget.setSize(w*CONFIG.resolution, h*CONFIG.resolution); taaTarget.setSize(w*CONFIG.resolution, h*CONFIG.resolution); rayTarget.setSize(w/2, h/2); denoiseMat.uniforms.uResolution.value.set(w*CONFIG.resolution, h*CONFIG.resolution); taaMat.uniforms.uResolution.value.set(w*CONFIG.resolution, h*CONFIG.resolution); };
            renderF.add(CONFIG, 'resolution', 0.1, 1.0).onChange(onResChange); 
            renderF.add(CONFIG, 'steps', 16, 256).step(1).onChange(v => cloudMat.uniforms.uSteps.value = v); 
            renderF.add(CONFIG, 'noiseOctaves', 1, 4).step(1).onChange(v => cloudMat.uniforms.uNoiseOctaves.value = v);
            renderF.add(CONFIG, 'lodDistance', 1000, 50000).onChange(v => cloudMat.uniforms.uLodDistance.value = v);
            renderF.add(CONFIG, 'maxDist', 10000, 200000).onChange(v => cloudMat.uniforms.uMaxDist.value = v);
            renderF.add(CONFIG, 'dithering').onChange(v => cloudMat.uniforms.uDithering.value = v);
            renderF.add(CONFIG, 'enableDenoise').onChange(v => denoiseMat.uniforms.uEnable.value = v);
            renderF.add(CONFIG, 'enableTAA').onChange(v => taaMat.uniforms.uEnable.value = v);
            
            const audioF = uiGui.addFolder('Audio Mixer');
            audioF.add(CONFIG, 'masterVolume', 0, 1).onChange(() => audioManager.updateVolumes()); 
            audioF.add(CONFIG, 'volSFX', 0, 1).name('Spatial SFX').onChange(() => audioManager.updateVolumes()); 
            audioF.add(CONFIG, 'volDrums', 0, 1).name('Drums').onChange(() => audioManager.updateVolumes());
            audioF.add(CONFIG, 'volSynths', 0, 1).name('Synths');
            audioF.add(CONFIG, 'volAtmos', 0, 1).name('Atmosphere');

            const updateGuiDisplay = (gui) => { if(gui.controllers) gui.controllers.forEach(c => c.updateDisplay()); if(gui.folders) gui.folders.forEach(f => updateGuiDisplay(f)); };
            const onResize = () => { const w = window.innerWidth, h = window.innerHeight; renderer.setSize(w, h); camera.aspect = w / h; camera.updateProjectionMatrix(); onResChange(); };
            window.addEventListener('resize', onResize); onResize(); 

            const dummyCam = new THREE.Camera();
            const prevViewProj = new THREE.Matrix4();
            const currentViewProj = new THREE.Matrix4();
            let frameCount = 0;

            function render() {
                requestAnimationFrame(render);
                const dt = clock.getDelta(); const elapsed = clock.getElapsedTime();
                if (CONFIG.autoSun || AUTOMATION.sun.enabled) CONFIG.sunElevation = AUTOMATION.sun.minElev + (AUTOMATION.sun.maxElev - AUTOMATION.sun.minElev) * (Math.sin(elapsed * AUTOMATION.sun.speed) * 0.5 + 0.5);
                if (frameCount % 10 === 0) updateGuiDisplay(uiGui);
                
                cloudMat.uniforms.uTime.value += dt;
                flightControls.update(dt);
                
                const localDensity = getCPUDensity(flightControls.worldPos, cloudMat.uniforms.uTime.value);
                document.getElementById('val-dens').innerText = Math.round(localDensity * 100) + '%';
                
                audioManager.update(flightControls.keys, flightControls.currentSpeed, flightControls.worldPos.y, localDensity, CONFIG.sunElevation, flightControls.worldPos, camera.quaternion, dt);

                const WRAP_PERIOD = 200000.0;
                cloudMat.uniforms.uWorldOffset.value.set(flightControls.worldPos.x % WRAP_PERIOD, 0, flightControls.worldPos.z % WRAP_PERIOD);
                cloudMat.uniforms.uCameraY.value = flightControls.worldPos.y;

                const phi = THREE.MathUtils.degToRad(90 - CONFIG.sunElevation); const theta = THREE.MathUtils.degToRad(CONFIG.sunAzimuth);
                const sunDir = new THREE.Vector3(Math.sin(phi) * Math.cos(theta), Math.cos(phi), Math.sin(phi) * Math.sin(theta)).normalize();
                const sunLightColor = new THREE.Color(1.0, 0.3 + 0.7 * Math.max(0, (CONFIG.sunElevation+5)/25), 0.1 + 0.9 * Math.max(0, (CONFIG.sunElevation+5)/25)).multiplyScalar(Math.sin(THREE.MathUtils.degToRad(Math.max(0, CONFIG.sunElevation+5))) + 0.1);
                
                // Lightning & Storm Logic
                const stormRisk = (localDensity > 0.6 && CONFIG.cloudCover > 0.6) ? 1.0 : 0.0;
                stormIntensity = THREE.MathUtils.lerp(stormIntensity, stormRisk, dt * 0.1);
                
                if (stormIntensity > 0.5 && Math.random() < 0.005) {
                    // Trigger lightning event
                    if (spatialSoundSystem) spatialSoundSystem.spawnThunder(flightControls.worldPos, stormIntensity);
                }
                
                // Decay lightning flash
                lightningIntensity *= 0.9;
                cloudMat.uniforms.uLightningIntensity.value = lightningIntensity;

                cloudMat.uniforms.uSunDir.value.copy(sunDir); cloudMat.uniforms.uSunColor.value.copy(sunLightColor);
                cloudMat.uniforms.uCameraPos.value.copy(camera.position);
                cloudMat.uniforms.uInverseView.value.copy(camera.matrixWorld);
                cloudMat.uniforms.uInverseProj.value.copy(camera.projectionMatrixInverse);

                const viewRotOnly = camera.matrixWorldInverse.clone();
                viewRotOnly.elements[12] = 0; viewRotOnly.elements[13] = 0; viewRotOnly.elements[14] = 0;
                currentViewProj.multiplyMatrices(camera.projectionMatrix, viewRotOnly);

                if (CONFIG.enableTAA) {
                    const jitterX = (Math.random() - 0.5) / (window.innerWidth * CONFIG.resolution);
                    const jitterY = (Math.random() - 0.5) / (window.innerHeight * CONFIG.resolution);
                    camera.setViewOffset(window.innerWidth, window.innerHeight, jitterX * window.innerWidth, jitterY * window.innerHeight, window.innerWidth, window.innerHeight);
                } else camera.clearViewOffset();

                camera.updateMatrixWorld(); camera.updateProjectionMatrix();
                
                const camDir = new THREE.Vector3(); camera.getWorldDirection(camDir);
                const isSunVisible = camDir.dot(sunDir) > 0.0;
                rayMat.uniforms.uSunVisible.value = isSunVisible;

                if (isSunVisible) {
                    const sunWorld = camera.position.clone().add(sunDir.clone().multiplyScalar(10000));
                    sunWorld.project(camera);
                    rayMat.uniforms.uSunPosScreen.value.set(sunWorld.x * 0.5 + 0.5, sunWorld.y * 0.5 + 0.5);
                }
                
                if (rainSystem) rainSystem.update(dt, camera.position, stormIntensity);

                renderer.setRenderTarget(cloudTarget); renderer.render(scene, dummyCam);
                
                postQuad.material = denoiseMat; denoiseMat.uniforms.tDiffuse.value = cloudTarget.texture;
                renderer.setRenderTarget(denoiseTarget); renderer.render(postScene, dummyCam);
                
                postQuad.material = taaMat;
                taaMat.uniforms.tCurrent.value = denoiseTarget.texture; taaMat.uniforms.tHistory.value = historyTarget.texture;
                taaMat.uniforms.uInvViewProj.value.copy(currentViewProj).invert(); taaMat.uniforms.uPrevViewProj.value.copy(prevViewProj);
                renderer.setRenderTarget(taaTarget); renderer.render(postScene, dummyCam);
                
                if (CONFIG.godRays) {
                    postQuad.material = rayMat; 
                    rayMat.uniforms.tDiffuse.value = taaTarget.texture;
                    renderer.setRenderTarget(rayTarget); 
                    renderer.render(postScene, dummyCam);
                } else {
                    renderer.setRenderTarget(rayTarget);
                    renderer.clear();
                }
                
                postQuad.material = compositeMat;
                compositeMat.uniforms.tColor.value = taaTarget.texture; compositeMat.uniforms.tGodRays.value = rayTarget.texture;
                renderer.setRenderTarget(null); renderer.render(postScene, dummyCam);
                
                const temp = historyTarget; historyTarget = taaTarget; taaTarget = temp;
                prevViewProj.copy(currentViewProj);
                frameCount++;
            }
            render();
        }
        init();
    </script>
</body>
</html>