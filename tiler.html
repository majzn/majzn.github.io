<!DOCTYPE html>
<!-- saved from url=(0069)file:///E:/Development/Git/Projects/Scratchpad/zentral/utl/tiler.html -->
<html lang="en">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tiling Studio v23.4</title>
    <script src="./tiler_files/saved_resource"></script>
    <style>
        @import url("https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=JetBrains+Mono:wght@500&display=swap");
         :root {
            --c-bg: #050505;
            --c-surf: #111111;
            --c-surf-light: #1a1a1a;
            --c-bord: #262626;
            --c-acc: #3b82f6;
            --c-acc-h: #60a5fa;
            --c-text: #a1a1aa;
            --c-text-hi: #fafafa;
        }
        
        body {
            background-color: var(--c-bg);
            color: var(--c-text);
            font-family: "Inter", sans-serif;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            display: flex;
            font-size: 12px;
        }
        
         ::-webkit-scrollbar {
            width: 5px;
            height: 5px;
        }
        
         ::-webkit-scrollbar-track {
            background: var(--c-bg);
        }
        
         ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 2px;
        }
        
         ::-webkit-scrollbar-thumb:hover {
            background: #444;
        }
        
        .panel {
            width: 340px;
            min-width: 320px;
            max-width: 600px;
            background: var(--c-surf);
            border-right: 1px solid var(--c-bord);
            display: flex;
            flex-direction: column;
            z-index: 50;
            position: relative;
            box-shadow: 5px 0 20px rgba(0, 0, 0, 0.5);
        }
        
        .resizer {
            position: absolute;
            right: -3px;
            top: 0;
            width: 6px;
            height: 100%;
            cursor: col-resize;
            z-index: 60;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .resizer:hover {
            opacity: 1;
            background: var(--c-acc);
        }
        
        .scroll-y {
            overflow-y: auto;
            flex: 1;
            padding: 0;
        }
        
        .section-head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: var(--c-surf-light);
            padding: 8px 16px;
            border-top: 1px solid var(--c-bord);
            border-bottom: 1px solid var(--c-bord);
            cursor: pointer;
            user-select: none;
            transition: background 0.2s;
        }
        
        .section-head:hover {
            background: #222;
        }
        
        .section-head span {
            font-weight: 700;
            color: var(--c-text-hi);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-size: 11px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .section-icon {
            transition: transform 0.2s;
        }
        
        .section-head.collapsed .section-icon {
            transform: rotate(-90deg);
        }
        
        .section-body {
            display: block;
            padding: 12px 16px;
        }
        
        .section-body.collapsed {
            display: none;
        }
        
        .ctrl-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
            height: 24px;
        }
        
        .ctrl-row label {
            font-weight: 500;
            color: #888;
            font-size: 11px;
            width: 75px;
            flex-shrink: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .val {
            font-family: "JetBrains Mono", monospace;
            text-align: right;
            color: var(--c-acc);
            font-size: 10px;
            width: 40px;
            flex-shrink: 0;
        }
        
        input[type="range"] {
            -webkit-appearance: none;
            background: transparent;
            width: 100%;
            cursor: pointer;
            height: 18px;
            flex: 1;
        }
        
        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 3px;
            background: #333;
            border-radius: 2px;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 12px;
            width: 12px;
            background: #ccc;
            margin-top: -4.5px;
            border-radius: 50%;
            box-shadow: 0 0 0 2px var(--c-surf);
            transition: all 0.1s;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            background: var(--c-acc);
            transform: scale(1.2);
        }
        
        .inp-select {
            background: #222;
            border: 1px solid #333;
            color: var(--c-text-hi);
            font-size: 10px;
            padding: 4px 6px;
            width: 100%;
            outline: none;
            border-radius: 3px;
            transition: border 0.2s;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .inp-select:hover {
            border-color: var(--c-acc);
        }
        
        .dropdown-portal {
            position: fixed;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 4px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.9);
            z-index: 1000;
            display: none;
            overflow-y: auto;
            min-width: 200px;
            padding: 4px;
        }
        
        .dropdown-item {
            padding: 8px 12px;
            font-size: 10px;
            font-weight: 700;
            color: #888;
            text-transform: uppercase;
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            margin-bottom: 2px;
        }
        
        .dropdown-item:hover {
            background: var(--c-acc);
            color: white;
        }
        
        .dropdown-item.active {
            color: var(--c-acc);
            background: #222;
        }
        
        .btn {
            border: none;
            padding: 6px 12px;
            border-radius: 3px;
            font-weight: 600;
            font-size: 10px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }
        
        .btn-primary {
            background: var(--c-acc);
            color: white;
            width: 100%;
            padding: 10px;
            margin-top: 8px;
        }
        
        .btn-primary:hover {
            background: var(--c-acc-h);
        }
        
        .btn-sec {
            background: #222;
            color: #ccc;
            border: 1px solid #333;
            flex: 1;
        }
        
        .btn-sec:hover {
            background: #333;
            color: white;
            border-color: #555;
        }
        
        .btn-icon {
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            padding: 4px;
            border-radius: 3px;
        }
        
        .btn-icon:hover {
            color: var(--c-acc);
            background: #222;
        }
        
        .layer-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .layer-item {
            background: #151515;
            border: 1px solid #262626;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .layer-body {
            padding: 8px;
            display: grid;
            gap: 8px;
        }
        
        .color-well {
            width: 40px;
            height: 12px;
            background: #222;
            position: relative;
            overflow: hidden;
            cursor: pointer;
            border: 1px solid #333;
            border-radius: 2px;
            flex-shrink: 0;
        }
        
        .color-well input {
            position: absolute;
            top: -10px;
            left: -10px;
            width: 200%;
            height: 200%;
            opacity: 0;
            cursor: pointer;
        }
        
        .chk {
            accent-color: var(--c-acc);
            cursor: pointer;
            width: 14px;
            height: 14px;
        }
        
        #canvasContainer {
            flex: 1;
            position: relative;
            background-image: linear-gradient(45deg, #080808 25%, transparent 25%), linear-gradient(-45deg, #080808 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #080808 75%), linear-gradient(-45deg, transparent 75%, #080808 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            background-color: #050505;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        
        canvas {
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
        }
        
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: var(--c-acc);
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            font-weight: 600;
            transform: translateY(100px);
            transition: transform 0.3s;
            z-index: 2000;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.3);
        }
        
        .toast.show {
            transform: translateY(0);
        }
        
        #evoOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.95);
            z-index: 1000;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px;
            backdrop-filter: blur(15px);
        }
        
        .evo-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
            width: 100%;
            max-width: 1200px;
        }
        
        .evo-thumb {
            background: #111;
            border: 2px solid #333;
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            aspect-ratio: 4/3;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .evo-thumb:hover {
            border-color: var(--c-acc);
            transform: scale(1.05);
            z-index: 10;
            box-shadow: 0 0 30px rgba(59, 130, 246, 0.4);
        }
        
        .evo-thumb canvas {
            width: 100%;
            height: 100%;
            box-shadow: none;
            pointer-events: none;
        }
        
        .evo-score {
            position: absolute;
            bottom: 8px;
            right: 8px;
            background: rgba(0, 0, 0, 0.8);
            padding: 2px 6px;
            border-radius: 4px;
            color: var(--c-acc);
            font-family: "JetBrains Mono";
            font-size: 10px;
            font-weight: 800;
            border: 1px solid #333;
        }
        
        .topo-preview {
            width: 44px;
            height: 28px;
            background: #000;
            border-radius: 2px;
            overflow: hidden;
            border: 1px solid #333;
        }
    </style>
    <style>
        *,
         ::before,
         ::after {
            --tw-border-spacing-x: 0;
            --tw-border-spacing-y: 0;
            --tw-translate-x: 0;
            --tw-translate-y: 0;
            --tw-rotate: 0;
            --tw-skew-x: 0;
            --tw-skew-y: 0;
            --tw-scale-x: 1;
            --tw-scale-y: 1;
            --tw-pan-x: ;
            --tw-pan-y: ;
            --tw-pinch-zoom: ;
            --tw-scroll-snap-strictness: proximity;
            --tw-gradient-from-position: ;
            --tw-gradient-via-position: ;
            --tw-gradient-to-position: ;
            --tw-ordinal: ;
            --tw-slashed-zero: ;
            --tw-numeric-figure: ;
            --tw-numeric-spacing: ;
            --tw-numeric-fraction: ;
            --tw-ring-inset: ;
            --tw-ring-offset-width: 0px;
            --tw-ring-offset-color: #fff;
            --tw-ring-color: rgb(59 130 246 / 0.5);
            --tw-ring-offset-shadow: 0 0 #0000;
            --tw-ring-shadow: 0 0 #0000;
            --tw-shadow: 0 0 #0000;
            --tw-shadow-colored: 0 0 #0000;
            --tw-blur: ;
            --tw-brightness: ;
            --tw-contrast: ;
            --tw-grayscale: ;
            --tw-hue-rotate: ;
            --tw-invert: ;
            --tw-saturate: ;
            --tw-sepia: ;
            --tw-drop-shadow: ;
            --tw-backdrop-blur: ;
            --tw-backdrop-brightness: ;
            --tw-backdrop-contrast: ;
            --tw-backdrop-grayscale: ;
            --tw-backdrop-hue-rotate: ;
            --tw-backdrop-invert: ;
            --tw-backdrop-opacity: ;
            --tw-backdrop-saturate: ;
            --tw-backdrop-sepia: ;
            --tw-contain-size: ;
            --tw-contain-layout: ;
            --tw-contain-paint: ;
            --tw-contain-style: ;
        }
        
         ::backdrop {
            --tw-border-spacing-x: 0;
            --tw-border-spacing-y: 0;
            --tw-translate-x: 0;
            --tw-translate-y: 0;
            --tw-rotate: 0;
            --tw-skew-x: 0;
            --tw-skew-y: 0;
            --tw-scale-x: 1;
            --tw-scale-y: 1;
            --tw-pan-x: ;
            --tw-pan-y: ;
            --tw-pinch-zoom: ;
            --tw-scroll-snap-strictness: proximity;
            --tw-gradient-from-position: ;
            --tw-gradient-via-position: ;
            --tw-gradient-to-position: ;
            --tw-ordinal: ;
            --tw-slashed-zero: ;
            --tw-numeric-figure: ;
            --tw-numeric-spacing: ;
            --tw-numeric-fraction: ;
            --tw-ring-inset: ;
            --tw-ring-offset-width: 0px;
            --tw-ring-offset-color: #fff;
            --tw-ring-color: rgb(59 130 246 / 0.5);
            --tw-ring-offset-shadow: 0 0 #0000;
            --tw-ring-shadow: 0 0 #0000;
            --tw-shadow: 0 0 #0000;
            --tw-shadow-colored: 0 0 #0000;
            --tw-blur: ;
            --tw-brightness: ;
            --tw-contrast: ;
            --tw-grayscale: ;
            --tw-hue-rotate: ;
            --tw-invert: ;
            --tw-saturate: ;
            --tw-sepia: ;
            --tw-drop-shadow: ;
            --tw-backdrop-blur: ;
            --tw-backdrop-brightness: ;
            --tw-backdrop-contrast: ;
            --tw-backdrop-grayscale: ;
            --tw-backdrop-hue-rotate: ;
            --tw-backdrop-invert: ;
            --tw-backdrop-opacity: ;
            --tw-backdrop-saturate: ;
            --tw-backdrop-sepia: ;
            --tw-contain-size: ;
            --tw-contain-layout: ;
            --tw-contain-paint: ;
            --tw-contain-style: ;
        }
        /* ! tailwindcss v3.4.17 | MIT License | https://tailwindcss.com */
        
        *,
         ::after,
         ::before {
            box-sizing: border-box;
            border-width: 0;
            border-style: solid;
            border-color: #e5e7eb;
        }
        
         ::after,
         ::before {
            --tw-content: "";
        }
        
         :host,
        html {
            line-height: 1.5;
            -webkit-text-size-adjust: 100%;
            -moz-tab-size: 4;
            tab-size: 4;
            font-family: ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
            font-feature-settings: normal;
            font-variation-settings: normal;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            margin: 0;
            line-height: inherit;
        }
        
        hr {
            height: 0;
            color: inherit;
            border-top-width: 1px;
        }
        
        abbr:where([title]) {
            -webkit-text-decoration: underline dotted;
            text-decoration: underline dotted;
        }
        
        h1,
        h2,
        h3,
        h4,
        h5,
        h6 {
            font-size: inherit;
            font-weight: inherit;
        }
        
        a {
            color: inherit;
            text-decoration: inherit;
        }
        
        b,
        strong {
            font-weight: bolder;
        }
        
        code,
        kbd,
        pre,
        samp {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-feature-settings: normal;
            font-variation-settings: normal;
            font-size: 1em;
        }
        
        small {
            font-size: 80%;
        }
        
        sub,
        sup {
            font-size: 75%;
            line-height: 0;
            position: relative;
            vertical-align: baseline;
        }
        
        sub {
            bottom: -0.25em;
        }
        
        sup {
            top: -0.5em;
        }
        
        table {
            text-indent: 0;
            border-color: inherit;
            border-collapse: collapse;
        }
        
        button,
        input,
        optgroup,
        select,
        textarea {
            font-family: inherit;
            font-feature-settings: inherit;
            font-variation-settings: inherit;
            font-size: 100%;
            font-weight: inherit;
            line-height: inherit;
            letter-spacing: inherit;
            color: inherit;
            margin: 0;
            padding: 0;
        }
        
        button,
        select {
            text-transform: none;
        }
        
        button,
        input:where([type="button"]),
        input:where([type="reset"]),
        input:where([type="submit"]) {
            -webkit-appearance: button;
            background-color: transparent;
            background-image: none;
        }
        
         :-moz-focusring {
            outline: auto;
        }
        
         :-moz-ui-invalid {
            box-shadow: none;
        }
        
        progress {
            vertical-align: baseline;
        }
        
         ::-webkit-inner-spin-button,
         ::-webkit-outer-spin-button {
            height: auto;
        }
        
        [type="search"] {
            -webkit-appearance: textfield;
            outline-offset: -2px;
        }
        
         ::-webkit-search-decoration {
            -webkit-appearance: none;
        }
        
         ::-webkit-file-upload-button {
            -webkit-appearance: button;
            font: inherit;
        }
        
        summary {
            display: list-item;
        }
        
        blockquote,
        dd,
        dl,
        figure,
        h1,
        h2,
        h3,
        h4,
        h5,
        h6,
        hr,
        p,
        pre {
            margin: 0;
        }
        
        fieldset {
            margin: 0;
            padding: 0;
        }
        
        legend {
            padding: 0;
        }
        
        menu,
        ol,
        ul {
            list-style: none;
            margin: 0;
            padding: 0;
        }
        
        dialog {
            padding: 0;
        }
        
        textarea {
            resize: vertical;
        }
        
        input::placeholder,
        textarea::placeholder {
            opacity: 1;
            color: #9ca3af;
        }
        
        [role="button"],
        button {
            cursor: pointer;
        }
        
         :disabled {
            cursor: default;
        }
        
        audio,
        canvas,
        embed,
        iframe,
        img,
        object,
        svg,
        video {
            display: block;
            vertical-align: middle;
        }
        
        img,
        video {
            max-width: 100%;
            height: auto;
        }
        
        [hidden]:where(:not([hidden="until-found"])) {
            display: none;
        }
        
        .mb-1 {
            margin-bottom: 0.25rem;
        }
        
        .mb-2 {
            margin-bottom: 0.5rem;
        }
        
        .mb-3 {
            margin-bottom: 0.75rem;
        }
        
        .mb-6 {
            margin-bottom: 1.5rem;
        }
        
        .ml-2 {
            margin-left: 0.5rem;
        }
        
        .mr-2 {
            margin-right: 0.5rem;
        }
        
        .mt-2 {
            margin-top: 0.5rem;
        }
        
        .mt-3 {
            margin-top: 0.75rem;
        }
        
        .mt-4 {
            margin-top: 1rem;
        }
        
        .mt-8 {
            margin-top: 2rem;
        }
        
        .block {
            display: block;
        }
        
        .flex {
            display: flex;
        }
        
        .grid {
            display: grid;
        }
        
        .hidden {
            display: none;
        }
        
        .h-3 {
            height: 0.75rem;
        }
        
        .h-4 {
            height: 1rem;
        }
        
        .h-5 {
            height: 1.25rem;
        }
        
        .w-3 {
            width: 0.75rem;
        }
        
        .w-64 {
            width: 16rem;
        }
        
        .w-full {
            width: 100%;
        }
        
        .min-w-\[75px\] {
            min-width: 75px;
        }
        
        .max-w-\[1200px\] {
            max-width: 1200px;
        }
        
        .flex-1 {
            flex: 1 1 0%;
        }
        
        .grid-cols-3 {
            grid-template-columns: repeat(3, minmax(0, 1fr));
        }
        
        .grid-cols-4 {
            grid-template-columns: repeat(4, minmax(0, 1fr));
        }
        
        .grid-cols-\[40px_1fr_1fr_1fr_24px\] {
            grid-template-columns: 40px 1fr 1fr 1fr 24px;
        }
        
        .grid-cols-\[40px_1fr_1fr_24px\] {
            grid-template-columns: 40px 1fr 1fr 24px;
        }
        
        .grid-cols-\[40px_1fr_24px\] {
            grid-template-columns: 40px 1fr 24px;
        }
        
        .flex-col {
            flex-direction: column;
        }
        
        .items-center {
            align-items: center;
        }
        
        .justify-center {
            justify-content: center;
        }
        
        .justify-between {
            justify-content: space-between;
        }
        
        .gap-1 {
            gap: 0.25rem;
        }
        
        .gap-2 {
            gap: 0.5rem;
        }
        
        .gap-3 {
            gap: 0.75rem;
        }
        
        .gap-4 {
            gap: 1rem;
        }
        
        .rounded {
            border-radius: 0.25rem;
        }
        
        .rounded-sm {
            border-radius: 0.125rem;
        }
        
        .border {
            border-width: 1px;
        }
        
        .border-b {
            border-bottom-width: 1px;
        }
        
        .border-\[\#262626\] {
            --tw-border-opacity: 1;
            border-color: rgb(38 38 38 / var(--tw-border-opacity, 1));
        }
        
        .border-gray-800 {
            --tw-border-opacity: 1;
            border-color: rgb(31 41 55 / var(--tw-border-opacity, 1));
        }
        
        .border-zinc-700 {
            --tw-border-opacity: 1;
            border-color: rgb(63 63 70 / var(--tw-border-opacity, 1));
        }
        
        .border-\[\#222\] {
            --tw-border-opacity: 1;
            border-color: rgb(34 34 34 / var(--tw-border-opacity, 1));
        }
        
        .bg-blue-500 {
            --tw-bg-opacity: 1;
            background-color: rgb(59 130 246 / var(--tw-bg-opacity, 1));
        }
        
        .bg-gray-900 {
            --tw-bg-opacity: 1;
            background-color: rgb(17 24 39 / var(--tw-bg-opacity, 1));
        }
        
        .bg-gray-900\/50 {
            background-color: rgb(17 24 39 / 0.5);
        }
        
        .bg-zinc-800 {
            --tw-bg-opacity: 1;
            background-color: rgb(39 39 42 / var(--tw-bg-opacity, 1));
        }
        
        .p-2 {
            padding: 0.5rem;
        }
        
        .p-4 {
            padding: 1rem;
        }
        
        .p-1\.5 {
            padding: 0.375rem;
        }
        
        .px-1 {
            padding-left: 0.25rem;
            padding-right: 0.25rem;
        }
        
        .px-4 {
            padding-left: 1rem;
            padding-right: 1rem;
        }
        
        .py-1 {
            padding-top: 0.25rem;
            padding-bottom: 0.25rem;
        }
        
        .py-2 {
            padding-top: 0.5rem;
            padding-bottom: 0.5rem;
        }
        
        .px-2 {
            padding-left: 0.5rem;
            padding-right: 0.5rem;
        }
        
        .py-0 {
            padding-top: 0px;
            padding-bottom: 0px;
        }
        
        .pb-2 {
            padding-bottom: 0.5rem;
        }
        
        .text-right {
            text-align: right;
        }
        
        .font-mono {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        }
        
        .text-\[10px\] {
            font-size: 10px;
        }
        
        .text-\[8px\] {
            font-size: 8px;
        }
        
        .text-\[9px\] {
            font-size: 9px;
        }
        
        .text-sm {
            font-size: 0.875rem;
            line-height: 1.25rem;
        }
        
        .text-xl {
            font-size: 1.25rem;
            line-height: 1.75rem;
        }
        
        .text-xs {
            font-size: 0.75rem;
            line-height: 1rem;
        }
        
        .font-black {
            font-weight: 900;
        }
        
        .font-bold {
            font-weight: 700;
        }
        
        .uppercase {
            text-transform: uppercase;
        }
        
        .leading-tight {
            line-height: 1.25;
        }
        
        .tracking-tighter {
            letter-spacing: -0.05em;
        }
        
        .tracking-wide {
            letter-spacing: 0.025em;
        }
        
        .tracking-widest {
            letter-spacing: 0.1em;
        }
        
        .tracking-tight {
            letter-spacing: -0.025em;
        }
        
        .text-blue-500 {
            --tw-text-opacity: 1;
            color: rgb(59 130 246 / var(--tw-text-opacity, 1));
        }
        
        .text-gray-400 {
            --tw-text-opacity: 1;
            color: rgb(156 163 175 / var(--tw-text-opacity, 1));
        }
        
        .text-gray-500 {
            --tw-text-opacity: 1;
            color: rgb(107 114 128 / var(--tw-text-opacity, 1));
        }
        
        .text-gray-600 {
            --tw-text-opacity: 1;
            color: rgb(75 85 99 / var(--tw-text-opacity, 1));
        }
        
        .text-green-500 {
            --tw-text-opacity: 1;
            color: rgb(34 197 94 / var(--tw-text-opacity, 1));
        }
        
        .text-white {
            --tw-text-opacity: 1;
            color: rgb(255 255 255 / var(--tw-text-opacity, 1));
        }
        
        .transition-colors {
            transition-property: color, background-color, border-color, fill, stroke, -webkit-text-decoration-color;
            transition-property: color, background-color, border-color, text-decoration-color, fill, stroke;
            transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, -webkit-text-decoration-color;
            transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
            transition-duration: 150ms;
        }
        
        .hover\:bg-red-600:hover {
            --tw-bg-opacity: 1;
            background-color: rgb(220 38 38 / var(--tw-bg-opacity, 1));
        }
    </style>
</head>

<body>
    <div id="sidebar" class="panel">
        <div id="resizer" class="resizer"></div>
        <div class="p-4 pb-2 border-b border-[#262626]">
            <h1 class="text-sm font-black text-white flex items-center gap-2 tracking-wide mb-1">
                <div class="w-3 h-3 bg-blue-500 rounded-sm"></div>
                TILING STUDIO
                <span class="text-[9px] text-gray-600 bg-gray-900 px-1 rounded uppercase">v23.4</span
          >
        </h1>
        <div class="flex gap-2 mt-3">
          <button id="btnSavePreset" class="btn btn-sec text-[9px] py-1">
            Save</button
          ><button id="btnLoadPreset" class="btn btn-sec text-[9px] py-1">
            Load
          </button>
        </div>
      </div>
      <div class="scroll-y">
        <div class="section-head" onclick="toggleSection(this)">
          <span
            ><div class="section-icon">▼</div>
            Evolution Engine</span
          >
          <button
            id="btnEvolveNow"
            class="btn-icon text-[9px] font-bold text-blue-500 uppercase"
            onclick="event.stopPropagation()"
          >
            Gen Matrix
          </button>
        </div>
        <div class="section-body">
          <div
            class="mb-3 text-[10px] text-gray-500 font-bold uppercase leading-tight"
          >
            Genetic Heuristics
          </div>
          <div class="ctrl-row mb-1">
            <label title="Structural Chaos">Entropy</label
            ><input type="range" id="evo_chaos" min="0" max="100" value="50" />
          </div>
          <div class="ctrl-row mb-1">
            <label title="Visual Density">Mass</label
            ><input
              type="range"
              id="evo_density"
              min="0"
              max="100"
              value="50"
            />
          </div>
          <div class="ctrl-row mb-1">
            <label title="Color Energy">Chroma</label
            ><input
              type="range"
              id="evo_vibrancy"
              min="0"
              max="100"
              value="50"
            />
          </div>
          <div class="ctrl-row mb-3">
            <label title="Lattice Logic">Structure</label
            ><input
              type="range"
              id="evo_symmetry"
              min="0"
              max="100"
              value="50"
            />
          </div>
          <div class="ctrl-row mb-3">
            <label>Mutation</label
            ><input
              type="range"
              id="evo_mutation"
              min="1"
              max="100"
              value="30"
            />
          </div>
          <button id="btnOpenEvo" class="btn btn-primary font-black uppercase">
            Breed Variations
          </button>
        </div>
        <div class="section-head" onclick="toggleSection(this)">
          <span
            ><div class="section-icon">▼</div>
            Grid &amp; Morphology</span
          >
          <button
            id="btnRandGrid"
            class="btn-icon text-[9px] font-bold text-green-500 uppercase"
            onclick="event.stopPropagation()"
          >
            Rnd
          </button>
        </div>
        <div class="section-body">
          <div class="mb-3">
            <label
              class="block text-[9px] font-bold text-gray-500 mb-1 uppercase"
              >Topology</label
            >
            <div id="gridSelector" class="inp-select font-black">
              <span id="gridTypeLabel">SQUARE LATTICE</span>
                <span>▼</span>
        </div>
    </div>
    <div id="core-controls">
        <div class="ctrl-row">
            <label>Zoom</label
              ><select
                id="snap_zoom"
                class="inp-select"
                style="width: 36px; padding: 0; text-align: center"
              >
                <option value="1">1</option>
                <option value="5">5</option>
                <option value="10">10</option></select
              ><input
                type="range"
                id="zoom"
                min="20"
                max="800"
                step="1"
                value="120"
              /><span id="zoomVal" class="val">120.0</span>
            </div>
            <div class="ctrl-row">
              <label>Expand</label
              ><select
                id="snap_expansion"
                class="inp-select"
                style="width: 36px; padding: 0; text-align: center"
              >
                <option value="0.01">0.01</option>
                <option value="0.1">0.1</option>
                <option value="0.25">0.25</option></select
              ><input
                type="range"
                id="expansion"
                min="1"
                max="150"
                step="1"
                value="50"
              /><span id="expansionVal" class="val">0.3</span>
            </div>
            <div class="ctrl-row">
              <label>Spike</label
              ><select
                id="snap_spike"
                class="inp-select"
                style="width: 36px; padding: 0; text-align: center"
              >
                <option value="0.01">0.01</option>
                <option value="0.1">0.1</option>
                <option value="0.25">0.25</option></select
              ><input
                type="range"
                id="spike"
                min="-90"
                max="90"
                step="1"
                value="0"
              /><span id="spikeVal" class="val">0.0</span>
            </div>
            <div class="ctrl-row">
              <label>Round</label
              ><select
                id="snap_rounding"
                class="inp-select"
                style="width: 36px; padding: 0; text-align: center"
              >
                <option value="0.01">0.01</option>
                <option value="0.1">0.1</option>
                <option value="0.25">0.25</option></select
              ><input
                type="range"
                id="rounding"
                min="0"
                max="100"
                step="1"
                value="0"
              /><span id="roundingVal" class="val">0%</span>
            </div>
            <div class="ctrl-row">
              <label>Sides</label
              ><select
                id="snap_polySides"
                class="inp-select"
                style="width: 36px; padding: 0; text-align: center"
              >
                <option value="1">1</option></select
              ><input
                type="range"
                id="polySides"
                min="3"
                max="16"
                step="1"
                value="4"
              /><span id="polySidesVal" class="val">5.0</span>
            </div>
            <div class="ctrl-row">
              <label>Rotate</label
              ><select
                id="snap_polyRot"
                class="inp-select"
                style="width: 36px; padding: 0; text-align: center"
              >
                <option value="1">1</option>
                <option value="5">5</option>
                <option value="15">15</option></select
              ><input
                type="range"
                id="polyRot"
                min="0"
                max="360"
                step="1"
                value="0"
              /><span id="polyRotVal" class="val">4.2°</span>
            </div>
            <div class="ctrl-row">
              <label>Pan X</label
              ><select
                id="snap_offsetX"
                class="inp-select"
                style="width: 36px; padding: 0; text-align: center"
              >
                <option value="0.01">0.01</option>
                <option value="0.1">0.1</option>
                <option value="0.25">0.25</option></select
              ><input
                type="range"
                id="offsetX"
                min="-50"
                max="50"
                step="1"
                value="0"
              /><span id="offsetXVal" class="val">0.1</span>
            </div>
            <div class="ctrl-row">
              <label>Pan Y</label
              ><select
                id="snap_offsetY"
                class="inp-select"
                style="width: 36px; padding: 0; text-align: center"
              >
                <option value="0.01">0.01</option>
                <option value="0.1">0.1</option>
                <option value="0.25">0.25</option></select
              ><input
                type="range"
                id="offsetY"
                min="-50"
                max="50"
                step="1"
                value="0"
              /><span id="offsetYVal" class="val">-0.1</span>
            </div>
          </div>
          <div
            class="flex items-center gap-3 mt-2 bg-gray-900/50 p-2 rounded border border-gray-800"
          >
            <div class="flex items-center gap-2">
              <input type="checkbox" id="polyMirror" class="chk" /><label
                class="text-[9px] font-bold text-gray-400 uppercase"
                >Mirror</label
              >
            </div>
            <div id="truncControl" class="flex-1 hidden">
              <div class="flex items-center gap-2">
                <label class="text-[9px] font-bold text-gray-600 uppercase"
                  >Trunc</label
                ><input
                  type="range"
                  id="latParam1"
                  min="10"
                  max="45"
                  value="33"
                />
              </div>
            </div>
          </div>
        </div>
        <div class="section-head" onclick="toggleSection(this)">
          <span
            ><div class="section-icon">▼</div>
            Compositing</span
          >
          <div
            class="flex items-center gap-2"
            onclick="event.stopPropagation()"
          >
            <div class="flex items-center gap-1 mr-2">
              <input
                type="checkbox"
                id="enableFX"
                class="chk"
                checked=""
              /><span class="text-[9px] font-bold text-gray-400 uppercase"
                >Fx</span
              >
            </div>
            <button
              id="btnRandLayers"
              class="btn-icon text-[9px] font-bold text-green-500 uppercase"
            >
              Rnd
            </button>
          </div>
        </div>
        <div class="section-body">
          <div class="ctrl-row mb-1">
            <label>Complexity</label
            ><input
              type="range"
              id="iterations"
              min="1"
              max="5"
              step="1"
              value="1"
            /><span id="iterationsVal" class="val">2</span>
          </div>
          <div class="ctrl-row mb-1">
            <label>Light Dir</label
            ><input
              type="range"
              id="lightDir"
              min="0"
              max="360"
              step="1"
              value="45"
            /><span id="lightDirVal" class="val">45°</span>
          </div>
          <div class="ctrl-row mb-3">
            <label>BG Color</label>
            <div class="color-well flex-1" style="background-color: rgb(5, 5, 5)">
                <input type="color" id="bgColor" value="#050505" />
            </div>
            <span class="text-[9px] text-gray-600 ml-2 uppercase">Hex</span>
        </div>
        <div id="layers-container" class="layer-list">
            <div class="layer-item" style="border-left: 3px solid rgb(228, 218, 241)">
                <div class="layer-head p-1.5 flex items-center justify-between border-b border-[#222]">
                    <div class="flex items-center gap-1">
                        <input type="checkbox" id="vis0" checked="" class="chk" /><span class="text-[9px] font-bold text-gray-400 uppercase tracking-tight">Base Grid</span
                  >
                </div>
                <div
                  id="blendBtn0"
                  class="inp-select py-0 px-2 h-5 flex items-center justify-center font-bold uppercase text-[8px] min-w-[75px]"
                >
                  source-over
                </div>
              </div>
              <div class="layer-body">
                <div
                  class="grid grid-cols-[40px_1fr_24px] gap-2 items-center h-4"
                >
                  <div class="color-well" style="background-color: #e4daf1">
                    <input type="color" id="c0" value="#e4daf1" />
                  </div>
                  <input
                    type="range"
                    id="o0"
                    min="0"
                    max="100"
                    value="24.38419956498101"
                  /><span
                    class="text-[8px] text-gray-500 font-mono text-right uppercase"
                    >Fil</span
                  >
                </div>
                <div
                  class="grid grid-cols-[40px_1fr_1fr_24px] gap-2 items-center h-4"
                >
                  <div class="color-well" style="background-color: #bbf66f">
                    <input type="color" id="sc0" value="#bbf66f" />
                  </div>
                  <input
                    type="range"
                    id="sw0"
                    min="0"
                    max="1000"
                    value="71.59163589922524"
                  /><input
                    type="range"
                    id="so0"
                    min="0"
                    max="100"
                    value="100"
                  /><span
                    class="text-[8px] text-gray-500 font-mono text-right uppercase"
                    >Str</span
                  >
                </div>
                <div
                  class="grid grid-cols-[40px_1fr_1fr_1fr_24px] gap-2 items-center h-4"
                >
                  <div class="color-well" style="background-color: #000000">
                    <input type="color" id="shC0" value="#000000" />
                  </div>
                  <input
                    type="range"
                    id="shB0"
                    min="0"
                    max="40"
                    value="0"
                    title="Blur"
                  /><input
                    type="range"
                    id="shO0"
                    min="0"
                    max="20"
                    value="0"
                    title="Offset"
                  /><input
                    type="range"
                    id="ld0"
                    min="0"
                    max="360"
                    value="0"
                    title="Direction"
                  /><span
                    class="text-[8px] text-gray-500 font-mono text-right uppercase"
                    >Fx</span
                  >
                </div>
              </div>
            </div>
            <div
              class="layer-item"
              style="border-left: 3px solid rgb(16, 185, 129)"
            >
              <div
                class="layer-head p-1.5 flex items-center justify-between border-b border-[#222]"
              >
                <div class="flex items-center gap-1">
                  <input type="checkbox" id="vis1" class="chk" /><span
                    class="text-[9px] font-bold text-gray-400 uppercase tracking-tight"
                    >Dual Grid</span
                  >
                </div>
                <div
                  id="blendBtn1"
                  class="inp-select py-0 px-2 h-5 flex items-center justify-center font-bold uppercase text-[8px] min-w-[75px]"
                >
                  lighten
                </div>
              </div>
              <div class="layer-body">
                <div
                  class="grid grid-cols-[40px_1fr_24px] gap-2 items-center h-4"
                >
                  <div class="color-well" style="background-color: #10b981">
                    <input type="color" id="c1" value="#10b981" />
                  </div>
                  <input
                    type="range"
                    id="o1"
                    min="0"
                    max="100"
                    value="7.879648857524721"
                  /><span
                    class="text-[8px] text-gray-500 font-mono text-right uppercase"
                    >Fil</span
                  >
                </div>
                <div
                  class="grid grid-cols-[40px_1fr_1fr_24px] gap-2 items-center h-4"
                >
                  <div class="color-well" style="background-color: #1eade1">
                    <input type="color" id="sc1" value="#1eade1" />
                  </div>
                  <input
                    type="range"
                    id="sw1"
                    min="0"
                    max="1000"
                    value="234.34117659698052"
                  /><input
                    type="range"
                    id="so1"
                    min="0"
                    max="100"
                    value="100"
                  /><span
                    class="text-[8px] text-gray-500 font-mono text-right uppercase"
                    >Str</span
                  >
                </div>
                <div
                  class="grid grid-cols-[40px_1fr_1fr_1fr_24px] gap-2 items-center h-4"
                >
                  <div class="color-well" style="background-color: #000000">
                    <input type="color" id="shC1" value="#000000" />
                  </div>
                  <input
                    type="range"
                    id="shB1"
                    min="0"
                    max="40"
                    value="0"
                    title="Blur"
                  /><input
                    type="range"
                    id="shO1"
                    min="0"
                    max="20"
                    value="0"
                    title="Offset"
                  /><input
                    type="range"
                    id="ld1"
                    min="0"
                    max="360"
                    value="0"
                    title="Direction"
                  /><span
                    class="text-[8px] text-gray-500 font-mono text-right uppercase"
                    >Fx</span
                  >
                </div>
              </div>
            </div>
            <div
              class="layer-item"
              style="border-left: 3px solid rgb(59, 130, 246)"
            >
              <div
                class="layer-head p-1.5 flex items-center justify-between border-b border-[#222]"
              >
                <div class="flex items-center gap-1">
                  <input
                    type="checkbox"
                    id="vis2"
                    checked=""
                    class="chk"
                  /><span
                    class="text-[9px] font-bold text-gray-400 uppercase tracking-tight"
                    >Geom 1</span
                  >
                </div>
                <div
                  id="blendBtn2"
                  class="inp-select py-0 px-2 h-5 flex items-center justify-center font-bold uppercase text-[8px] min-w-[75px]"
                >
                  source-over
                </div>
              </div>
              <div class="layer-body">
                <div
                  class="grid grid-cols-[40px_1fr_24px] gap-2 items-center h-4"
                >
                  <div class="color-well" style="background-color: #3b82f6">
                    <input type="color" id="c2" value="#3b82f6" />
                  </div>
                  <input
                    type="range"
                    id="o2"
                    min="0"
                    max="100"
                    value="21.60118690057104"
                  /><span
                    class="text-[8px] text-gray-500 font-mono text-right uppercase"
                    >Fil</span
                  >
                </div>
                <div
                  class="grid grid-cols-[40px_1fr_1fr_24px] gap-2 items-center h-4"
                >
                  <div class="color-well" style="background-color: #60a5fa">
                    <input type="color" id="sc2" value="#60a5fa" />
                  </div>
                  <input
                    type="range"
                    id="sw2"
                    min="0"
                    max="1000"
                    value="127.75471571252208"
                  /><input
                    type="range"
                    id="so2"
                    min="0"
                    max="100"
                    value="100"
                  /><span
                    class="text-[8px] text-gray-500 font-mono text-right uppercase"
                    >Str</span
                  >
                </div>
                <div
                  class="grid grid-cols-[40px_1fr_1fr_1fr_24px] gap-2 items-center h-4"
                >
                  <div class="color-well" style="background-color: #000000">
                    <input type="color" id="shC2" value="#000000" />
                  </div>
                  <input
                    type="range"
                    id="shB2"
                    min="0"
                    max="40"
                    value="10"
                    title="Blur"
                  /><input
                    type="range"
                    id="shO2"
                    min="0"
                    max="20"
                    value="5"
                    title="Offset"
                  /><input
                    type="range"
                    id="ld2"
                    min="0"
                    max="360"
                    value="0"
                    title="Direction"
                  /><span
                    class="text-[8px] text-gray-500 font-mono text-right uppercase"
                    >Fx</span
                  >
                </div>
              </div>
            </div>
            <div
              class="layer-item"
              style="border-left: 3px solid rgb(244, 63, 94)"
            >
              <div
                class="layer-head p-1.5 flex items-center justify-between border-b border-[#222]"
              >
                <div class="flex items-center gap-1">
                  <input type="checkbox" id="vis3" class="chk" /><span
                    class="text-[9px] font-bold text-gray-400 uppercase tracking-tight"
                    >Dual 1</span
                  >
                </div>
                <div
                  id="blendBtn3"
                  class="inp-select py-0 px-2 h-5 flex items-center justify-center font-bold uppercase text-[8px] min-w-[75px]"
                >
                  screen
                </div>
              </div>
              <div class="layer-body">
                <div
                  class="grid grid-cols-[40px_1fr_24px] gap-2 items-center h-4"
                >
                  <div class="color-well" style="background-color: #f43f5e">
                    <input type="color" id="c3" value="#f43f5e" />
                  </div>
                  <input
                    type="range"
                    id="o3"
                    min="0"
                    max="100"
                    value="2.6380909902210314"
                  /><span
                    class="text-[8px] text-gray-500 font-mono text-right uppercase"
                    >Fil</span
                  >
                </div>
                <div
                  class="grid grid-cols-[40px_1fr_1fr_24px] gap-2 items-center h-4"
                >
                  <div class="color-well" style="background-color: #bbf66f">
                    <input type="color" id="sc3" value="#bbf66f" />
                  </div>
                  <input
                    type="range"
                    id="sw3"
                    min="0"
                    max="1000"
                    value="169.61267758609085"
                  /><input
                    type="range"
                    id="so3"
                    min="0"
                    max="100"
                    value="100"
                  /><span
                    class="text-[8px] text-gray-500 font-mono text-right uppercase"
                    >Str</span
                  >
                </div>
                <div
                  class="grid grid-cols-[40px_1fr_1fr_1fr_24px] gap-2 items-center h-4"
                >
                  <div class="color-well" style="background-color: #000000">
                    <input type="color" id="shC3" value="#000000" />
                  </div>
                  <input
                    type="range"
                    id="shB3"
                    min="0"
                    max="40"
                    value="10"
                    title="Blur"
                  /><input
                    type="range"
                    id="shO3"
                    min="0"
                    max="20"
                    value="5"
                    title="Offset"
                  /><input
                    type="range"
                    id="ld3"
                    min="0"
                    max="360"
                    value="0"
                    title="Direction"
                  /><span
                    class="text-[8px] text-gray-500 font-mono text-right uppercase"
                    >Fx</span
                  >
                </div>
              </div>
            </div>
            <div
              class="layer-item"
              style="border-left: 3px solid rgb(214, 41, 69)"
            >
              <div
                class="layer-head p-1.5 flex items-center justify-between border-b border-[#222]"
              >
                <div class="flex items-center gap-1">
                  <input
                    type="checkbox"
                    id="vis4"
                    checked=""
                    class="chk"
                  /><span
                    class="text-[9px] font-bold text-gray-400 uppercase tracking-tight"
                    >Geom 2</span
                  >
                </div>
                <div
                  id="blendBtn4"
                  class="inp-select py-0 px-2 h-5 flex items-center justify-center font-bold uppercase text-[8px] min-w-[75px]"
                >
                  source-over
                </div>
              </div>
              <div class="layer-body">
                <div
                  class="grid grid-cols-[40px_1fr_24px] gap-2 items-center h-4"
                >
                  <div class="color-well" style="background-color: #d62945">
                    <input type="color" id="c4" value="#d62945" />
                  </div>
                  <input
                    type="range"
                    id="o4"
                    min="0"
                    max="100"
                    value="30"
                  /><span
                    class="text-[8px] text-gray-500 font-mono text-right uppercase"
                    >Fil</span
                  >
                </div>
                <div
                  class="grid grid-cols-[40px_1fr_1fr_24px] gap-2 items-center h-4"
                >
                  <div class="color-well" style="background-color: #d66429">
                    <input type="color" id="sc4" value="#d66429" />
                  </div>
                  <input
                    type="range"
                    id="sw4"
                    min="0"
                    max="1000"
                    value="100"
                  /><input
                    type="range"
                    id="so4"
                    min="0"
                    max="100"
                    value="100"
                  /><span
                    class="text-[8px] text-gray-500 font-mono text-right uppercase"
                    >Str</span
                  >
                </div>
                <div
                  class="grid grid-cols-[40px_1fr_1fr_1fr_24px] gap-2 items-center h-4"
                >
                  <div class="color-well" style="background-color: #000000">
                    <input type="color" id="shC4" value="#000000" />
                  </div>
                  <input
                    type="range"
                    id="shB4"
                    min="0"
                    max="40"
                    value="10"
                    title="Blur"
                  /><input
                    type="range"
                    id="shO4"
                    min="0"
                    max="20"
                    value="5"
                    title="Offset"
                  /><input
                    type="range"
                    id="ld4"
                    min="0"
                    max="360"
                    value="0"
                    title="Direction"
                  /><span
                    class="text-[8px] text-gray-500 font-mono text-right uppercase"
                    >Fx</span
                  >
                </div>
              </div>
            </div>
            <div
              class="layer-item"
              style="border-left: 3px solid rgb(214, 186, 41)"
            >
              <div
                class="layer-head p-1.5 flex items-center justify-between border-b border-[#222]"
              >
                <div class="flex items-center gap-1">
                  <input type="checkbox" id="vis5" class="chk" /><span
                    class="text-[9px] font-bold text-gray-400 uppercase tracking-tight"
                    >Dual 2</span
                  >
                </div>
                <div
                  id="blendBtn5"
                  class="inp-select py-0 px-2 h-5 flex items-center justify-center font-bold uppercase text-[8px] min-w-[75px]"
                >
                  screen
                </div>
              </div>
              <div class="layer-body">
                <div
                  class="grid grid-cols-[40px_1fr_24px] gap-2 items-center h-4"
                >
                  <div class="color-well" style="background-color: #d6ba29">
                    <input type="color" id="c5" value="#d6ba29" />
                  </div>
                  <input
                    type="range"
                    id="o5"
                    min="0"
                    max="100"
                    value="30"
                  /><span
                    class="text-[8px] text-gray-500 font-mono text-right uppercase"
                    >Fil</span
                  >
                </div>
                <div
                  class="grid grid-cols-[40px_1fr_1fr_24px] gap-2 items-center h-4"
                >
                  <div class="color-well" style="background-color: #9bd629">
                    <input type="color" id="sc5" value="#9bd629" />
                  </div>
                  <input
                    type="range"
                    id="sw5"
                    min="0"
                    max="1000"
                    value="100"
                  /><input
                    type="range"
                    id="so5"
                    min="0"
                    max="100"
                    value="100"
                  /><span
                    class="text-[8px] text-gray-500 font-mono text-right uppercase"
                    >Str</span
                  >
                </div>
                <div
                  class="grid grid-cols-[40px_1fr_1fr_1fr_24px] gap-2 items-center h-4"
                >
                  <div class="color-well" style="background-color: #000000">
                    <input type="color" id="shC5" value="#000000" />
                  </div>
                  <input
                    type="range"
                    id="shB5"
                    min="0"
                    max="40"
                    value="10"
                    title="Blur"
                  /><input
                    type="range"
                    id="shO5"
                    min="0"
                    max="20"
                    value="5"
                    title="Offset"
                  /><input
                    type="range"
                    id="ld5"
                    min="0"
                    max="360"
                    value="0"
                    title="Direction"
                  /><span
                    class="text-[8px] text-gray-500 font-mono text-right uppercase"
                    >Fx</span
                  >
                </div>
              </div>
            </div>
          </div>
        </div>
        <div class="section-head collapsed" onclick="toggleSection(this)">
          <span
            ><div class="section-icon">▼</div>
            Output &amp; Export</span
          >
        </div>
        <div class="section-body collapsed">
          <div
            class="flex items-center gap-3 mb-3 p-2 bg-gray-900/50 rounded border border-gray-800"
          >
            <input type="checkbox" id="singleTile" class="chk" /><label
              class="text-[9px] font-bold text-gray-400 uppercase tracking-widest"
              >Single Tile Preview</label
            >
          </div>
          <div class="ctrl-row mb-3">
            <label class="text-[9px] font-bold text-gray-500 uppercase"
              >Filtering</label
            ><select id="filterMode" class="inp-select font-bold">
              <option value="nearest">Nearest Neighbor</option>
              <option value="bilinear" selected="">Bilinear (Smooth)</option>
              <option value="bicubic">Bicubic (High Quality)</option>
            </select>
          </div>
          <div class="mb-3">
            <div class="flex justify-between items-center mb-1">
              <label class="text-[9px] font-bold text-gray-500 uppercase"
                >Export Res</label
              ><span
                id="exportResVal"
                class="text-[10px] text-blue-500 font-mono"
                >1024 PX</span
              >
            </div>
            <input
              type="range"
              id="exportResSlider"
              min="3"
              max="12"
              step="1"
              value="10"
            />
          </div>
          <div class="grid grid-cols-3 gap-2">
            <button id="exportPng" class="btn btn-sec">PNG</button
            ><button id="exportSvg" class="btn btn-sec">SVG</button
            ><button id="exportBmp" class="btn btn-sec">BMP</button>
          </div>
          <button id="randBtn" class="btn btn-primary font-bold uppercase mt-4">
            Randomize All
          </button>
        </div>
      </div>
    </div>
    <div id="canvasContainer">
      <canvas
        id="canvas"
        width="2220"
        height="1295"
        style="image-rendering: auto"
      ></canvas>
    </div>
    <div id="evoOverlay" style="display: none">
      <h2
        class="text-white text-xl font-black mb-6 uppercase tracking-tighter flex items-center justify-between w-full max-w-[1200px]"
      >
        Evolutionary Selection
        <button
          id="btnCloseEvo"
          class="text-[10px] uppercase font-bold bg-zinc-800 border border-zinc-700 px-4 py-2 rounded hover:bg-red-600 transition-colors"
        >
          Dismiss
        </button>
      </h2>
      <div id="evoGrid" class="evo-grid">
        <div class="evo-thumb">
          <canvas width="400" height="300"></canvas>
          <div class="evo-score">FIT: 20</div>
        </div>
        <div class="evo-thumb">
          <canvas width="400" height="300"></canvas>
          <div class="evo-score">FIT: 19</div>
        </div>
        <div class="evo-thumb">
          <canvas width="400" height="300"></canvas>
          <div class="evo-score">FIT: 18</div>
        </div>
        <div class="evo-thumb">
          <canvas width="400" height="300"></canvas>
          <div class="evo-score">FIT: 18</div>
        </div>
        <div class="evo-thumb">
          <canvas width="400" height="300"></canvas>
          <div class="evo-score">FIT: 18</div>
        </div>
        <div class="evo-thumb">
          <canvas width="400" height="300"></canvas>
          <div class="evo-score">FIT: 18</div>
        </div>
        <div class="evo-thumb">
          <canvas width="400" height="300"></canvas>
          <div class="evo-score">FIT: 18</div>
        </div>
        <div class="evo-thumb">
          <canvas width="400" height="300"></canvas>
          <div class="evo-score">FIT: 18</div>
        </div>
        <div class="evo-thumb">
          <canvas width="400" height="300"></canvas>
          <div class="evo-score">FIT: 17</div>
        </div>
        <div class="evo-thumb">
          <canvas width="400" height="300"></canvas>
          <div class="evo-score">FIT: 17</div>
        </div>
        <div class="evo-thumb">
          <canvas width="400" height="300"></canvas>
          <div class="evo-score">FIT: 17</div>
        </div>
        <div class="evo-thumb">
          <canvas width="400" height="300"></canvas>
          <div class="evo-score">FIT: 17</div>
        </div>
      </div>
      <div class="mt-8 flex gap-4">
        <button
          id="btnRefreshEvo"
          class="btn btn-primary w-64 font-black uppercase"
        >
          Mutate New Branches
        </button>
      </div>
    </div>
    <div id="blendDropdown" class="dropdown-portal"></div>
    <div
      id="topoDropdown"
      class="dropdown-portal"
      style="top: 461.5px; left: 16px; width: 302px; display: none"
    >
      <div class="dropdown-item">
        <span>Square Lattice</span>
                        <div id="prev_square" class="topo-preview">
                            <canvas width="88" height="56"></canvas>
                        </div>
                    </div>
                    <div class="dropdown-item">
                        <span>Hexagonal Lattice</span>
                        <div id="prev_hex" class="topo-preview">
                            <canvas width="88" height="56"></canvas>
                        </div>
                    </div>
                    <div class="dropdown-item">
                        <span>Triangular Lattice</span>
                        <div id="prev_tri" class="topo-preview">
                            <canvas width="88" height="56"></canvas>
                        </div>
                    </div>
                    <div class="dropdown-item active">
                        <span>Tetrille (3,4,6,4)</span>
                        <div id="prev_tetrille" class="topo-preview">
                            <canvas width="88" height="56"></canvas>
                        </div>
                    </div>
                    <div class="dropdown-item">
                        <span>Truncated Square</span>
                        <div id="prev_truncsquare" class="topo-preview">
                            <canvas width="88" height="56"></canvas>
                        </div>
                    </div>
                </div>
                <div id="toast" class="toast">Action Complete</div>
                <script>
                    // --- BUFFERS FOR ZERO-ALLOCATION MATH ---
                    const MAX_VERTS = 4000000; // Capacity for ~2M points
                    const BUF_A = new Float32Array(MAX_VERTS);
                    const BUF_B = new Float32Array(MAX_VERTS);

                    const glCanvas = document.createElement("canvas");
                    let gl = null;
                    let glProg = null;
                    let glBuf = null;

                    function initWebGL() {
                        gl = glCanvas.getContext("webgl", {
                            alpha: true,
                            antialias: true
                        });
                        if (!gl) return false;
                        const vs = `attribute vec2 p; uniform vec2 r; uniform float s; uniform vec2 t; void main() { vec2 n = (p * s + t) / r * 2.0; gl_Position = vec4(n.x, -n.y, 0.0, 1.0); }`;
                        const fs = `precision mediump float; uniform vec4 c; void main() { gl_FragColor = c; }`;
                        const createShader = (ty, src) => {
                            const s = gl.createShader(ty);
                            gl.shaderSource(s, src);
                            gl.compileShader(s);
                            return s;
                        };
                        const prog = gl.createProgram();
                        gl.attachShader(prog, createShader(gl.VERTEX_SHADER, vs));
                        gl.attachShader(prog, createShader(gl.FRAGMENT_SHADER, fs));
                        gl.linkProgram(prog);
                        gl.useProgram(prog);
                        glProg = {
                            p: gl.getAttribLocation(prog, "p"),
                            r: gl.getUniformLocation(prog, "r"),
                            s: gl.getUniformLocation(prog, "s"),
                            t: gl.getUniformLocation(prog, "t"),
                            c: gl.getUniformLocation(prog, "c"),
                        };
                        glBuf = gl.createBuffer();
                        return true;
                    }

                    // Helper to copy object based geom to buffer
                    function objToBuf(geomList, buf) {
                        let cursor = 0;
                        for (let i = 0; i < geomList.length; i++) {
                            const pts = geomList[i].pts;
                            if (pts.length < 2) continue;
                            for (let j = 0; j < pts.length; j++) {
                                buf[cursor++] = pts[j].x;
                                buf[cursor++] = pts[j].y;
                                buf[cursor++] = pts[(j + 1) % pts.length].x;
                                buf[cursor++] = pts[(j + 1) % pts.length].y;
                            }
                        }
                        return cursor; // Return used size
                    }

                    function bufToObj(buf, size) {
                        const res = [];
                        if (size < 4) return res;
                        let pts = [];
                        const eps = 0.001;
                        pts.push({
                            x: buf[0],
                            y: buf[1]
                        });
                        pts.push({
                            x: buf[2],
                            y: buf[3]
                        });
                        for (let i = 4; i < size; i += 4) {
                            const x1 = buf[i],
                                y1 = buf[i + 1];
                            const x2 = buf[i + 2],
                                y2 = buf[i + 3];
                            const last = pts[pts.length - 1];
                            if (Math.abs(x1 - last.x) < eps && Math.abs(y1 - last.y) < eps) {
                                pts.push({
                                    x: x2,
                                    y: y2
                                });
                            } else {
                                if (pts.length > 2) {
                                    const first = pts[0];
                                    const end = pts[pts.length - 1];
                                    if (
                                        Math.abs(first.x - end.x) < eps &&
                                        Math.abs(first.y - end.y) < eps
                                    )
                                        pts.pop();
                                }
                                res.push({
                                    pts: pts
                                });
                                pts = [{
                                    x: x1,
                                    y: y1
                                }, {
                                    x: x2,
                                    y: y2
                                }, ];
                            }
                        }
                        if (pts.length > 0) {
                            if (pts.length > 2) {
                                const first = pts[0];
                                const end = pts[pts.length - 1];
                                if (
                                    Math.abs(first.x - end.x) < eps &&
                                    Math.abs(first.y - end.y) < eps
                                )
                                    pts.pop();
                            }
                            res.push({
                                pts: pts
                            });
                        }
                        return res;
                    }

                    function rad(deg) {
                        return (deg * Math.PI) / 180;
                    }

                    function hashCoord(p) {
                        const x = (Math.round(p.x * 1000) + 20000000) & 0x3ffffff;
                        const y = (Math.round(p.y * 1000) + 20000000) & 0x3ffffff;
                        return x + y * 67108864;
                    }

                    function getRGBA(h, a) {
                        const r = parseInt(h.slice(1, 3), 16),
                            g = parseInt(h.slice(3, 5), 16),
                            b = parseInt(h.slice(5, 7), 16);
                        return `rgba(${r},${g},${b},${a})`;
                    }

                    function hslToHex(h, s, l) {
                        l /= 100;
                        const a = (s * Math.min(l, 1 - l)) / 100;
                        const f = (n) => {
                            const k = (n + h / 30) % 12;
                            const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
                            return Math.round(255 * color)
                                .toString(16)
                                .padStart(2, "0");
                        };
                        return `#${f(0)}${f(8)}${f(4)}`;
                    }

                    function generatePalette() {
                        const h = Math.random() * 360,
                            s = 40 + Math.random() * 60,
                            type = Math.random();
                        let colors = [];
                        if (type < 0.2)
                            for (let i = 0; i < 5; i++) colors.push(hslToHex(h, s, 20 + i * 15));
                        else if (type < 0.5)
                            for (let i = 0; i < 5; i++)
                                colors.push(hslToHex((h + i * 30) % 360, s, 50));
                        else if (type < 0.8)
                            colors = [
                                hslToHex(h, s, 50),
                                hslToHex((h + 180) % 360, s, 50),
                                hslToHex(h, s, 30),
                                hslToHex((h + 180) % 360, s, 70),
                                hslToHex(h, s * 0.5, 90),
                            ];
                        else
                            for (let i = 0; i < 5; i++)
                                colors.push(hslToHex(Math.random() * 360, 90, 60));
                        return colors;
                    }

                    function renderBufferDirect(ctx, buf, rounding, sides) {
                        if (!buf || buf.length < 4) return;

                        const polySegments = (sides || 4) * 2;
                        const stride = polySegments * 4;
                        const size = buf.length;
                        const isSharp = rounding < 0.01;
                        const BATCH_SIZE = 2000;
                        let batchCount = 0;

                        const offsets = new Int32Array(polySegments);
                        for (let k = 0; k < polySegments; k++) {
                            offsets[k] = k * 4 + 2;
                        }

                        const pBuf = isSharp ? null : new Float32Array(polySegments * 2);

                        ctx.beginPath();

                        for (let i = 0; i < size; i += stride) {
                            if (isSharp) {
                                ctx.moveTo(buf[i], buf[i + 1]);
                                for (let k = 0; k < polySegments - 1; k++) {
                                    const idx = i + offsets[k];
                                    ctx.lineTo(buf[idx], buf[idx + 1]);
                                }
                                ctx.closePath();
                            } else {
                                let pIdx = 0;
                                pBuf[pIdx++] = buf[i];
                                pBuf[pIdx++] = buf[i + 1];

                                for (let k = 0; k < polySegments - 1; k++) {
                                    const idx = i + offsets[k];
                                    pBuf[pIdx++] = buf[idx];
                                    pBuf[pIdx++] = buf[idx + 1];
                                }

                                const vCount = polySegments;
                                const last = vCount - 1;

                                for (let k = 0; k < vCount; k++) {
                                    const i1 = k * 2;
                                    const i0 = (k === 0 ? last : k - 1) * 2;
                                    const i2 = (k === last ? 0 : k + 1) * 2;

                                    const p1x = pBuf[i1],
                                        p1y = pBuf[i1 + 1];
                                    const p0x = pBuf[i0],
                                        p0y = pBuf[i0 + 1];
                                    const p2x = pBuf[i2],
                                        p2y = pBuf[i2 + 1];

                                    const v1x = p0x - p1x,
                                        v1y = p0y - p1y;
                                    const v2x = p2x - p1x,
                                        v2y = p2y - p1y;
                                    const l1 = Math.sqrt(v1x * v1x + v1y * v1y);
                                    const l2 = Math.sqrt(v2x * v2x + v2y * v2y);

                                    const r = (l1 < l2 ? l1 : l2) * 0.5 * rounding;

                                    const sx = p1x + (v1x / l1) * r;
                                    const sy = p1y + (v1y / l1) * r;
                                    const ex = p1x + (v2x / l2) * r;
                                    const ey = p1y + (v2y / l2) * r;

                                    if (k === 0) ctx.moveTo(sx, sy);
                                    else ctx.lineTo(sx, sy);
                                    ctx.quadraticCurveTo(p1x, p1y, ex, ey);
                                }
                                ctx.closePath();
                            }

                            if (++batchCount >= BATCH_SIZE) {
                                ctx.fill();
                                if (ctx.lineWidth > 0) ctx.stroke();
                                ctx.beginPath();
                                batchCount = 0;
                            }
                        }

                        if (batchCount > 0) {
                            ctx.fill();
                            if (ctx.lineWidth > 0) ctx.stroke();
                        }
                    }

                    function drawPathDirect(ctx, list, rounding) {
                        if (!list || list.length === 0) return;
                        ctx.beginPath();
                        const len = list.length;
                        const isSharp = rounding < 0.01;
                        for (let k = 0; k < len; k++) {
                            const pts = list[k].pts;
                            if (pts.length < 3 && pts.length > 0) {
                                // Handle Lines from buffer conversion
                                ctx.moveTo(pts[0].x, pts[0].y);
                                ctx.lineTo(pts[1].x, pts[1].y);
                                continue;
                            }
                            if (pts.length < 3) continue;
                            if (isSharp) {
                                ctx.moveTo(pts[0].x, pts[0].y);
                                for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
                                ctx.closePath();
                            } else {
                                const pLen = pts.length;
                                for (let i = 0; i < pLen; i++) {
                                    const p1 = pts[i];
                                    const p0 = pts[i === 0 ? pLen - 1 : i - 1];
                                    const p2 = pts[i === pLen - 1 ? 0 : i + 1];
                                    const v1x = p0.x - p1.x,
                                        v1y = p0.y - p1.y;
                                    const v2x = p2.x - p1.x,
                                        v2y = p2.y - p1.y;
                                    const l1 = Math.sqrt(v1x * v1x + v1y * v1y),
                                        l2 = Math.sqrt(v2x * v2x + v2y * v2y);
                                    const r = Math.min(l1, l2) * 0.5 * rounding;
                                    const sx = p1.x + (v1x / l1) * r,
                                        sy = p1.y + (v1y / l1) * r;
                                    const ex = p1.x + (v2x / l2) * r,
                                        ey = p1.y + (v2y / l2) * r;
                                    if (i === 0) ctx.moveTo(sx, sy);
                                    else ctx.lineTo(sx, sy);
                                    ctx.quadraticCurveTo(p1.x, p1.y, ex, ey);
                                }
                                ctx.closePath();
                            }
                        }
                        ctx.fill();
                        if (ctx.lineWidth > 0) ctx.stroke();
                    }

                    function updateColorWell(input) {
                        if (input && input.parentNode)
                            input.parentNode.style.backgroundColor = input.value;
                    }

                    function toggleSection(head) {
                        head.classList.toggle("collapsed");
                        head.nextElementSibling.classList.toggle("collapsed");
                    }

                    function setFiltering(tCtx, mode) {
                        if (mode === "nearest") {
                            tCtx.imageSmoothingEnabled = false;
                            cvs.style.imageRendering = "pixelated";
                        } else {
                            tCtx.imageSmoothingEnabled = true;
                            tCtx.imageSmoothingQuality = mode === "bicubic" ? "high" : "low";
                            cvs.style.imageRendering = "auto";
                        }
                    }

                    function showToast(msg) {
                        const t = document.getElementById("toast");
                        if (!t) return;
                        t.textContent = msg;
                        t.classList.add("show");
                        setTimeout(() => t.classList.remove("show"), 2000);
                    }

                    function resize() {
                        const container = document.getElementById("canvasContainer");
                        if (!container) return;
                        cW = cvs.width = container.clientWidth;
                        cH = cvs.height = container.clientHeight;
                        markDirty();
                    }

                    function markDirty() {
                        isDirty = true;
                        if (!cfg.autoAnim) requestAnimationFrame(render);
                    }

                    function invalidateGeomCache() {
                        geomCache.baseGridType = null;
                        geomCache.sig = "";
                        geomCache.glData = null;
                        markDirty();
                    }

                    function getUnitCellDimensions(pGridType) {
                        const s = 100;
                        switch (pGridType || cfg.gridType) {
                            case "hex":
                                return {
                                    w: s * 3,
                                    h: s * Math.sqrt(3)
                                };
                            case "tri":
                                return {
                                    w: s,
                                    h: s * Math.sqrt(3)
                                };
                            case "tetrille":
                                return {
                                    w: s * 3,
                                    h: s * Math.sqrt(3)
                                };
                            default:
                                return {
                                    w: s,
                                    h: s
                                };
                        }
                    }

                    const BLEND_MODES = [
                        "source-over",
                        "multiply",
                        "screen",
                        "overlay",
                        "darken",
                        "lighten",
                        "color-dodge",
                        "hard-light",
                        "difference",
                        "exclusion",
                    ];
                    const LATTICES = [{
                        id: "square",
                        label: "Square Lattice"
                    }, {
                        id: "hex",
                        label: "Hexagonal Lattice"
                    }, {
                        id: "tri",
                        label: "Triangular Lattice"
                    }, {
                        id: "tetrille",
                        label: "Tetrille (3,4,6,4)"
                    }, {
                        id: "truncsquare",
                        label: "Truncated Square"
                    }, ];

                    let cfg = {
                        gridType: "square",
                        polySides: 4,
                        expansion: 0.5,
                        zoom: 120,
                        rounding: 0,
                        spike: 0,
                        polyRot: 0,
                        offsetY: 0,
                        offsetX: 0,
                        polyMirror: false,
                        bgColor: "#050505",
                        autoAnim: false,
                        animTempo: 1.0,
                        iterations: 1,
                        mod_rot: 0,
                        mod_round: 0,
                        mod_exp: 0,
                        mod_offset: 0,
                        latParam1: 0.33,
                        enableFX: true,
                        singleTile: false,
                        filterMode: "bilinear",
                        lightDir: 45,
                    };
                    let layerCfgs = [{
                        id: "base",
                        name: "Base Grid",
                        vis: true,
                        c: "#1f2937",
                        o: 0.1,
                        sc: "#374151",
                        sw: 1,
                        so: 1,
                        b: "source-over",
                        shB: 0,
                        shO: 0,
                        shC: "#000000",
                        ld: 0,
                    }, {
                        id: "dual",
                        name: "Dual Grid",
                        vis: false,
                        c: "#10b981",
                        o: 0.1,
                        sc: "#34d399",
                        sw: 1,
                        so: 1,
                        b: "overlay",
                        shB: 0,
                        shO: 0,
                        shC: "#000000",
                        ld: 0,
                    }, {
                        id: "ag1",
                        name: "Geom 1",
                        vis: true,
                        c: "#3b82f6",
                        o: 0.25,
                        sc: "#60a5fa",
                        sw: 1,
                        so: 1,
                        b: "source-over",
                        shB: 10,
                        shO: 5,
                        shC: "#000000",
                        ld: 0,
                    }, {
                        id: "ad1",
                        name: "Dual 1",
                        vis: false,
                        c: "#f43f5e",
                        o: 0,
                        sc: "#fb7185",
                        sw: 1,
                        so: 1,
                        b: "screen",
                        shB: 10,
                        shO: 5,
                        shC: "#000000",
                        ld: 0,
                    }, ];

                    const coreControlDefs = [{
                        id: "zoom",
                        label: "Zoom",
                        min: 20,
                        max: 800,
                        step: 1,
                        mult: 1,
                        unit: "",
                        snaps: [1, 5, 10],
                    }, {
                        id: "expansion",
                        label: "Expand",
                        min: 1,
                        max: 150,
                        step: 1,
                        mult: 0.01,
                        unit: "",
                        snaps: [0.01, 0.1, 0.25],
                    }, {
                        id: "spike",
                        label: "Spike",
                        min: -90,
                        max: 90,
                        step: 1,
                        mult: 0.01,
                        unit: "",
                        snaps: [0.01, 0.1, 0.25],
                    }, {
                        id: "rounding",
                        label: "Round",
                        min: 0,
                        max: 100,
                        step: 1,
                        mult: 0.01,
                        unit: "%",
                        unitMul: 100,
                        snaps: [0.01, 0.1, 0.25],
                    }, {
                        id: "polySides",
                        label: "Sides",
                        min: 3,
                        max: 16,
                        step: 1,
                        mult: 1,
                        unit: "",
                        snaps: [1],
                    }, {
                        id: "polyRot",
                        label: "Rotate",
                        min: 0,
                        max: 360,
                        step: 1,
                        mult: 1,
                        unit: "°",
                        snaps: [1, 5, 15],
                    }, {
                        id: "offsetX",
                        label: "Pan X",
                        min: -50,
                        max: 50,
                        step: 1,
                        mult: 0.01,
                        unit: "",
                        snaps: [0.01, 0.1, 0.25],
                    }, {
                        id: "offsetY",
                        label: "Pan Y",
                        min: -50,
                        max: 50,
                        step: 1,
                        mult: 0.01,
                        unit: "",
                        snaps: [0.01, 0.1, 0.25],
                    }, ];

                    const cvs = document.getElementById("canvas"),
                        ctx = cvs.getContext("2d", {
                            alpha: false
                        });
                    const offCanvas = document.createElement("canvas"),
                        offCtx = offCanvas.getContext("2d");
                    const tileCanvas = document.createElement("canvas"),
                        tCtx = tileCanvas.getContext("2d");
                    const shadowBuffer = document.createElement("canvas"),
                        sbCtx = shadowBuffer.getContext("2d");
                    const tileStack = document.createElement("canvas"),
                        tsCtx = tileStack.getContext("2d");
                    let cW,
                        cH,
                        animT = 0,
                        isDirty = true,
                        geomCache = {
                            baseGridType: null,
                            baseFaces: null,
                            baseDuals: null,
                            sig: "",
                            glData: null,
                        };

                    function generateBaseGrid(dim, pCfg) {
                        const currentCfg = pCfg || cfg;
                        const neededPad =
                            2.5 + currentCfg.iterations * 0.4 * Math.max(1, currentCfg.expansion);

                        if (!pCfg &&
                            geomCache.baseGridType === currentCfg.gridType &&
                            geomCache.baseFaces &&
                            geomCache.basePad >= neededPad &&
                            geomCache.baseLatParam === currentCfg.latParam1
                        ) {
                            return {
                                faces: geomCache.baseFaces,
                                duals: geomCache.baseDuals
                            };
                        }

                        const s = 100;
                        const b = {
                            x1: -dim.w * neededPad,
                            x2: dim.w * neededPad,
                            y1: -dim.h * neededPad,
                            y2: dim.h * neededPad,
                        };

                        let faces = [];
                        const gt = currentCfg.gridType;

                        if (gt === "square") {
                            for (let y = Math.floor(b.y1 / s) * s; y < b.y2; y += s)
                                for (let x = Math.floor(b.x1 / s) * s; x < b.x2; x += s)
                                    faces.push({
                                        pts: [{
                                            x,
                                            y
                                        }, {
                                            x: x + s,
                                            y
                                        }, {
                                            x: x + s,
                                            y: y + s
                                        }, {
                                            x,
                                            y: y + s
                                        }, ],
                                    });
                        } else if (gt === "hex") {
                            const h = (s * Math.sqrt(3)) / 2;
                            for (
                                let r = Math.floor(b.y1 / (h * 2)) - 2; r * h * 2 < b.y2 + h; r++
                            )
                                for (
                                    let c = Math.floor(b.x1 / (s * 1.5)) - 2; c * s * 1.5 < b.x2 + s; c++
                                ) {
                                    const cx = c * s * 1.5,
                                        cy = r * h * 2 + (Math.abs(c) % 2 ? h : 0);
                                    const pts = [];
                                    for (let i = 0; i < 6; i++)
                                        pts.push({
                                            x: cx + s * Math.cos((i * Math.PI) / 3),
                                            y: cy + s * Math.sin((i * Math.PI) / 3),
                                        });
                                    faces.push({
                                        pts
                                    });
                                }
                        } else if (gt === "tri") {
                            const h = (s * Math.sqrt(3)) / 2;
                            for (let r = Math.floor(b.y1 / h) - 1; r * h < b.y2 + h; r++) {
                                const off = Math.abs(r) % 2 ? s / 2 : 0;
                                for (let c = Math.floor(b.x1 / s) - 1; c * s < b.x2 + s; c++) {
                                    const x = c * s + off;
                                    faces.push({
                                        pts: [{
                                            x,
                                            y: r * h
                                        }, {
                                            x: x + s,
                                            y: r * h
                                        }, {
                                            x: x + s / 2,
                                            y: (r + 1) * h
                                        }, ],
                                    });
                                    faces.push({
                                        pts: [{
                                            x: x + s,
                                            y: r * h
                                        }, {
                                            x: x + s * 1.5,
                                            y: (r + 1) * h
                                        }, {
                                            x: x + s / 2,
                                            y: (r + 1) * h
                                        }, ],
                                    });
                                }
                            }
                        } else if (gt === "tetrille") {
                            const h = s * Math.sqrt(3);
                            for (let r = Math.floor(b.y1 / h) - 1; r * h < b.y2 + h; r++)
                                for (
                                    let c = Math.floor(b.x1 / (s * 1.5)) - 1; c * s * 1.5 < b.x2 + s; c++
                                ) {
                                    const cx = c * s * 1.5,
                                        cy = r * h + (Math.abs(c) % 2 ? h / 2 : 0);
                                    for (let i = 0; i < 6; i++) {
                                        const a = (i * Math.PI) / 3;
                                        faces.push({
                                            pts: [{
                                                x: cx,
                                                y: cy
                                            }, {
                                                x: cx + s * 0.5 * Math.cos(a),
                                                y: cy + s * 0.5 * Math.sin(a),
                                            }, {
                                                x: cx + s * 0.866 * Math.cos(a + Math.PI / 6),
                                                y: cy + s * 0.866 * Math.sin(a + Math.PI / 6),
                                            }, {
                                                x: cx + s * 0.5 * Math.cos(a + Math.PI / 3),
                                                y: cy + s * 0.5 * Math.sin(a + Math.PI / 3),
                                            }, ],
                                        });
                                    }
                                }
                        } else if (gt === "truncsquare") {
                            const k = s * (currentCfg.latParam1 || 0.33);
                            for (let y = Math.floor(b.y1 / s) * s; y < b.y2; y += s)
                                for (let x = Math.floor(b.x1 / s) * s; x < b.x2; x += s) {
                                    faces.push({
                                        pts: [{
                                            x: x + k,
                                            y: y
                                        }, {
                                            x: x + s - k,
                                            y: y
                                        }, {
                                            x: x + s,
                                            y: y + k
                                        }, {
                                            x: x + s,
                                            y: y + s - k
                                        }, {
                                            x: x + s - k,
                                            y: y + s
                                        }, {
                                            x: x + k,
                                            y: y + s
                                        }, {
                                            x: x,
                                            y: y + s - k
                                        }, {
                                            x: x,
                                            y: y + k
                                        }, ],
                                    });
                                    faces.push({
                                        pts: [{
                                            x: x + s - k,
                                            y: y + s
                                        }, {
                                            x: x + s,
                                            y: y + s - k
                                        }, {
                                            x: x + s + k,
                                            y: y + s
                                        }, {
                                            x: x + s,
                                            y: y + s + k
                                        }, ],
                                    });
                                }
                        }

                        const extractDuals = (polyList) => {
                            const vertMap = new Map();
                            polyList.forEach((f, fIdx) => {
                                f.pts.forEach((p) => {
                                    const vK = hashCoord(p);
                                    if (!vertMap.has(vK)) vertMap.set(vK, {
                                        p,
                                        f: []
                                    });
                                    vertMap.get(vK).f.push(fIdx);
                                });
                            });
                            const duals = [];
                            vertMap.forEach((v) => {
                                if (v.f.length < 3) return;
                                const pts = v.f
                                    .map((fi) => {
                                        const f = polyList[fi];
                                        const cx = f.pts.reduce((a, b) => a + b.x, 0) / f.pts.length,
                                            cy = f.pts.reduce((a, b) => a + b.y, 0) / f.pts.length;
                                        return {
                                            x: cx,
                                            y: cy,
                                            a: Math.atan2(cy - v.p.y, cx - v.p.x)
                                        };
                                    })
                                    .sort((a, b) => a.a - b.a);
                                duals.push({
                                    pts
                                });
                            });
                            return duals;
                        };

                        const duals = extractDuals(faces);

                        if (!pCfg) {
                            geomCache.baseGridType = gt;
                            geomCache.baseFaces = faces;
                            geomCache.baseDuals = duals;
                            geomCache.basePad = neededPad;
                            geomCache.baseLatParam = currentCfg.latParam1;
                        }
                        return {
                            faces,
                            duals
                        };
                    }

                    function generateActiveGeom(baseData, pCfg, maxIter) {
                        const currentCfg = pCfg || cfg;
                        const limit =
                            maxIter !== undefined ?
                            Math.min(currentCfg.iterations, maxIter) :
                            currentCfg.iterations;
                        const sig = `${
          currentCfg.gridType
        }_${limit}_${currentCfg.expansion.toFixed(
          3
        )}_${currentCfg.polyRot.toFixed(3)}_${currentCfg.spike.toFixed(3)}_${
          currentCfg.polySides
        }_${currentCfg.offsetX.toFixed(3)}_${currentCfg.offsetY.toFixed(3)}_${
          currentCfg.polyMirror
        }`;

                        if (geomCache.sig === sig && geomCache.glData) return geomCache.glData;

                        const sides = Math.floor(currentCfg.polySides);
                        const rotA = rad(currentCfg.polyRot);
                        const expVal = currentCfg.expansion;
                        const biasY = 0.5 + currentCfg.offsetY;
                        const shX = currentCfg.offsetX;

                        const computeSet = (sourceObjList) => {
                            let currSize = objToBuf(sourceObjList, BUF_A);
                            let activeSrc = BUF_A;
                            let activeDst = BUF_B;
                            let finalSizes = [];

                            for (let iter = 0; iter < limit; iter++) {
                                let wIdx = 0;
                                for (let rIdx = 0; rIdx < currSize; rIdx += 4) {
                                    const px1 = activeSrc[rIdx],
                                        py1 = activeSrc[rIdx + 1];
                                    const px2 = activeSrc[rIdx + 2],
                                        py2 = activeSrc[rIdx + 3];
                                    const dx = px2 - px1,
                                        dy = py2 - py1;
                                    const len = Math.sqrt(dx * dx + dy * dy);
                                    const ang = Math.atan2(dy, dx);
                                    const R = (len * expVal * 0.5) / Math.sin(Math.PI / sides);
                                    const flat = R * Math.cos(Math.PI / sides);

                                    const processPoly = (centerX, centerY) => {
                                        let firstVX, firstVY, prevSX, prevSY;
                                        for (let i = 0; i < sides; i++) {
                                            const a =
                                                ang + Math.PI / 2 + rotA + (i * 2 * Math.PI) / sides;
                                            const vx = centerX + R * Math.cos(a);
                                            const vy = centerY + R * Math.sin(a);
                                            const am = a + Math.PI / sides;
                                            const sx =
                                                centerX + (flat + currentCfg.spike * R) * Math.cos(am);
                                            const sy =
                                                centerY + (flat + currentCfg.spike * R) * Math.sin(am);
                                            if (i === 0) {
                                                firstVX = vx;
                                                firstVY = vy;
                                            } else {
                                                activeDst[wIdx++] = prevSX;
                                                activeDst[wIdx++] = prevSY;
                                                activeDst[wIdx++] = vx;
                                                activeDst[wIdx++] = vy;
                                            }
                                            activeDst[wIdx++] = vx;
                                            activeDst[wIdx++] = vy;
                                            activeDst[wIdx++] = sx;
                                            activeDst[wIdx++] = sy;
                                            prevSX = sx;
                                            prevSY = sy;
                                        }
                                        activeDst[wIdx++] = prevSX;
                                        activeDst[wIdx++] = prevSY;
                                        activeDst[wIdx++] = firstVX;
                                        activeDst[wIdx++] = firstVY;
                                    };

                                    const cx = px1 + dx * biasY - (dy / len) * shX * len;
                                    const cy = py1 + dy * biasY + (dx / len) * shX * len;
                                    processPoly(cx, cy);

                                    if (currentCfg.polyMirror) {
                                        const cxm = px1 + dx * biasY - (dy / len) * -shX * len;
                                        const cym = py1 + dy * biasY + (dx / len) * -shX * len;
                                        processPoly(cxm, cym);
                                    }
                                }
                                const temp = activeSrc;
                                activeSrc = activeDst;
                                activeDst = temp;
                                currSize = wIdx;
                                finalSizes.push(new Float32Array(activeSrc.subarray(0, currSize)));
                            }
                            return finalSizes;
                        };

                        const geomArrs = computeSet(baseData.faces);
                        const dualArrs = computeSet(baseData.duals);
                        const res = {
                            activeGeoms: geomArrs,
                            activeDuals: dualArrs,
                            flatGeom: geomArrs,
                            flatDual: dualArrs,
                        };
                        geomCache.sig = sig;
                        geomCache.glData = res;
                        return res;
                    }

                    function renderLayer(
                        targetCtx,
                        layer,
                        data,
                        w,
                        h,
                        rounding,
                        scale,
                        pCfg
                    ) {
                        const currentCfg = pCfg || cfg;
                        const sides = Math.floor(currentCfg.polySides);
                        const hasShadow =
                            (layer.shB > 0 || Math.abs(layer.shO) > 0) && currentCfg.enableFX;

                        if (!hasShadow) {
                            targetCtx.save();
                            targetCtx.globalCompositeOperation = layer.b;
                            targetCtx.translate(-w / 2, -h / 2);
                            targetCtx.scale(scale, scale);
                            targetCtx.lineJoin = "round";
                            targetCtx.lineCap = "round";
                            targetCtx.fillStyle = getRGBA(layer.c, layer.o);
                            targetCtx.strokeStyle = getRGBA(layer.sc, layer.so);
                            targetCtx.lineWidth = layer.sw;
                            if (data instanceof Float32Array)
                                renderBufferDirect(targetCtx, data, rounding, sides);
                            else drawPathDirect(targetCtx, data, rounding);
                            targetCtx.restore();
                            return;
                        }

                        if (tileCanvas.width !== w || tileCanvas.height !== h) {
                            tileCanvas.width = w;
                            tileCanvas.height = h;
                        } else tCtx.clearRect(0, 0, w, h);

                        tCtx.save();
                        tCtx.scale(scale, scale);
                        tCtx.lineJoin = "round";
                        tCtx.lineCap = "round";
                        tCtx.fillStyle = getRGBA(layer.c, layer.o);
                        tCtx.strokeStyle = getRGBA(layer.sc, layer.so);
                        tCtx.lineWidth = layer.sw;
                        if (data instanceof Float32Array)
                            renderBufferDirect(tCtx, data, rounding, sides);
                        else drawPathDirect(tCtx, data, rounding);
                        tCtx.restore();

                        const tw = w * 3,
                            th = h * 3;
                        if (tileStack.width !== tw || tileStack.height !== th) {
                            tileStack.width = tw;
                            tileStack.height = th;
                        } else tsCtx.clearRect(0, 0, tw, th);

                        for (let ty = 0; ty < 3; ty++)
                            for (let tx = 0; tx < 3; tx++)
                                tsCtx.drawImage(tileCanvas, tx * w, ty * h);

                        if (shadowBuffer.width !== tw || shadowBuffer.height !== th) {
                            shadowBuffer.width = tw;
                            shadowBuffer.height = th;
                        } else sbCtx.clearRect(0, 0, tw, th);

                        sbCtx.save();
                        sbCtx.shadowBlur = layer.shB * scale;
                        sbCtx.shadowColor = getRGBA(layer.shC || "#000000", 0.6);
                        const lightAngle = rad((layer.ld || 0) + currentCfg.lightDir);
                        sbCtx.shadowOffsetX = Math.cos(lightAngle) * layer.shO * scale;
                        sbCtx.shadowOffsetY = Math.sin(lightAngle) * layer.shO * scale;
                        sbCtx.drawImage(tileStack, 0, 0);
                        sbCtx.restore();

                        targetCtx.save();
                        targetCtx.globalCompositeOperation = layer.b;
                        targetCtx.drawImage(shadowBuffer, w, h, w, h, -w / 2, -h / 2, w, h);
                        targetCtx.restore();
                    }

                    function renderTile(
                        targetCtx,
                        targetW,
                        targetH,
                        scaleFactor,
                        pCfg,
                        pLayers
                    ) {
                        const currentCfg = pCfg || cfg;
                        const currentLayers = pLayers || layerCfgs;
                        const dim = getUnitCellDimensions(currentCfg.gridType);

                        let maxVisibleIter = 0;
                        for (let i = 1; i <= currentCfg.iterations; i++) {
                            const ag = currentLayers.find((l) => l.id === `ag${i}`);
                            const ad = currentLayers.find((l) => l.id === `ad${i}`);
                            if ((ag && ag.vis) || (ad && ad.vis)) maxVisibleIter = i;
                        }

                        const baseData = generateBaseGrid(dim, currentCfg);
                        const activeData = generateActiveGeom(
                            baseData,
                            currentCfg,
                            maxVisibleIter
                        );
                        const curRounding = currentCfg.rounding;

                        targetCtx.fillStyle = currentCfg.bgColor;
                        targetCtx.fillRect(0, 0, targetW, targetH);
                        targetCtx.save();
                        targetCtx.translate(targetW / 2, targetH / 2);

                        const baseL = currentLayers.find((l) => l.id === "base");
                        if (baseL && baseL.vis)
                            renderLayer(
                                targetCtx,
                                baseL,
                                baseData.faces,
                                targetW,
                                targetH,
                                curRounding,
                                scaleFactor,
                                currentCfg
                            );

                        const dualL = currentLayers.find((l) => l.id === "dual");
                        if (dualL && dualL.vis)
                            renderLayer(
                                targetCtx,
                                dualL,
                                baseData.duals,
                                targetW,
                                targetH,
                                curRounding,
                                scaleFactor,
                                currentCfg
                            );

                        for (let i = 0; i < maxVisibleIter; i++) {
                            const agL = currentLayers.find((l) => l.id === `ag${i + 1}`);
                            if (agL && agL.vis && activeData.flatGeom && activeData.flatGeom[i])
                                renderLayer(
                                    targetCtx,
                                    agL,
                                    activeData.activeGeoms[i],
                                    targetW,
                                    targetH,
                                    curRounding,
                                    scaleFactor,
                                    currentCfg
                                );
                            const adL = currentLayers.find((l) => l.id === `ad${i + 1}`);
                            if (adL && adL.vis && activeData.flatDual && activeData.flatDual[i])
                                renderLayer(
                                    targetCtx,
                                    adL,
                                    activeData.activeDuals[i],
                                    targetW,
                                    targetH,
                                    curRounding,
                                    scaleFactor,
                                    currentCfg
                                );
                        }
                        targetCtx.restore();
                    }

                    function render() {
                        if (!isDirty && !cfg.autoAnim) return;
                        const dim = getUnitCellDimensions();
                        const dpr = window.devicePixelRatio || 1,
                            zoomS = cfg.zoom / 100,
                            scaleF = Math.max(1, zoomS * dpr);
                        const expW = Math.round(dim.w * scaleF),
                            expH = Math.round(dim.h * scaleF);
                        if (offCanvas.width !== expW || offCanvas.height !== expH) {
                            offCanvas.width = expW;
                            offCanvas.height = expH;
                        }
                        renderTile(offCtx, expW, expH, scaleF);
                        ctx.fillStyle = cfg.bgColor;
                        ctx.fillRect(0, 0, cW, cH);
                        setFiltering(ctx, cfg.filterMode);
                        if (cfg.singleTile) {
                            ctx.drawImage(
                                offCanvas,
                                cW / 2 - (expW * zoomS) / scaleF / 2,
                                cH / 2 - (expH * zoomS) / scaleF / 2,
                                (expW * zoomS) / scaleF,
                                (expH * zoomS) / scaleF
                            );
                        } else {
                            const pat = ctx.createPattern(offCanvas, "repeat");
                            ctx.save();
                            ctx.translate(cW / 2, cH / 2);
                            const fS = zoomS / scaleF;
                            const mat = new DOMMatrix()
                                .scale(fS, fS)
                                .translate(-expW / 2, -expH / 2);
                            pat.setTransform(mat);
                            ctx.fillStyle = pat;
                            ctx.fillRect(-cW / 2, -cH / 2, cW, cH);
                            ctx.restore();
                        }
                        isDirty = false;
                    }

                    function mutate(pCfg, pLayers, strength) {
                        const nCfg = JSON.parse(JSON.stringify(pCfg));
                        const nLayers = JSON.parse(JSON.stringify(pLayers));
                        const tweak = (v, min, max, s) => {
                            let nv = v + (Math.random() - 0.5) * (max - min) * s;
                            return Math.max(min, Math.min(max, nv));
                        };
                        nCfg.polyRot = tweak(nCfg.polyRot, 0, 360, strength);
                        nCfg.expansion = tweak(nCfg.expansion, 0.1, 1.5, strength);
                        nCfg.rounding = tweak(nCfg.rounding, 0, 1.0, strength);
                        nCfg.spike = tweak(nCfg.spike, -0.9, 0.9, strength);
                        nCfg.polySides = Math.round(tweak(nCfg.polySides, 3, 12, strength));
                        if (Math.random() < strength * 0.2)
                            nCfg.gridType =
                            LATTICES[Math.floor(Math.random() * LATTICES.length)].id;
                        const pal = generatePalette();
                        nLayers.forEach((l) => {
                            if (Math.random() < strength)
                                l.c = pal[Math.floor(Math.random() * pal.length)];
                            if (Math.random() < strength)
                                l.sc = pal[Math.floor(Math.random() * pal.length)];
                            l.o = tweak(l.o, 0, 0.6, strength);
                            l.sw = tweak(l.sw, 0.1, 8, strength);
                            if (Math.random() < strength * 0.4)
                                l.b = BLEND_MODES[Math.floor(Math.random() * BLEND_MODES.length)];
                        });
                        return {
                            cfg: nCfg,
                            layers: nLayers
                        };
                    }

                    function calculateFitness(pCfg, pLayers, heuristics) {
                        let score = 0;
                        score += pCfg.polySides * 0.2 * heuristics.chaos;
                        score += Math.abs(pCfg.spike) * 30 * heuristics.chaos;
                        const avgOp = pLayers.reduce((a, b) => a + b.o, 0) / pLayers.length;
                        const avgSw = pLayers.reduce((a, b) => a + b.sw, 0) / pLayers.length;
                        score += (avgOp * 20 + avgSw * 3) * heuristics.density;
                        if (pCfg.polyMirror) score += 5 * heuristics.symmetry;
                        if (["hex", "tetrille"].includes(pCfg.gridType))
                            score += 10 * heuristics.symmetry;
                        const vibrancy =
                            pLayers.reduce((a, b) => {
                                const c = b.c;
                                const r = parseInt(c.slice(1, 3), 16),
                                    g = parseInt(c.slice(3, 5), 16),
                                    b_val = parseInt(c.slice(5, 7), 16);
                                return a + (Math.max(r, g, b_val) - Math.min(r, g, b_val));
                            }, 0) / pLayers.length;
                        score += (vibrancy / 255) * 30 * heuristics.vibrancy;
                        return Math.min(99, Math.max(1, Math.round(score)));
                    }

                    function openEvolution() {
                        const overlay = document.getElementById("evoOverlay"),
                            grid = document.getElementById("evoGrid");
                        overlay.style.display = "flex";
                        grid.innerHTML = "";
                        const heuristics = {
                            chaos: document.getElementById("evo_chaos").value / 100,
                            density: document.getElementById("evo_density").value / 100,
                            vibrancy: document.getElementById("evo_vibrancy").value / 100,
                            symmetry: document.getElementById("evo_symmetry").value / 100,
                        };
                        const mutationS = document.getElementById("evo_mutation").value / 100;
                        let candidates = [];
                        for (let i = 0; i < 32; i++) {
                            const v = mutate(cfg, layerCfgs, mutationS);
                            v.fitness = calculateFitness(v.cfg, v.layers, heuristics);
                            candidates.push(v);
                        }
                        candidates
                            .sort((a, b) => b.fitness - a.fitness)
                            .slice(0, 12)
                            .forEach((v) => {
                                const thumb = document.createElement("div");
                                thumb.className = "evo-thumb";
                                const tCvs = document.createElement("canvas");
                                tCvs.width = 400;
                                tCvs.height = 300;
                                thumb.appendChild(tCvs);
                                const score = document.createElement("div");
                                score.className = "evo-score";
                                score.textContent = `FIT: ${v.fitness}`;
                                thumb.appendChild(score);
                                grid.appendChild(thumb);
                                const tCtxLocal = tCvs.getContext("2d");
                                const tDim = getUnitCellDimensions(v.cfg.gridType);
                                const tScale = 180 / tDim.w;
                                const tExpW = Math.round(tDim.w * tScale),
                                    tExpH = Math.round(tDim.h * tScale);
                                const tOffCvs = document.createElement("canvas");
                                tOffCvs.width = tExpW;
                                tOffCvs.height = tExpH;
                                renderTile(
                                    tOffCvs.getContext("2d"),
                                    tExpW,
                                    tExpH,
                                    tScale,
                                    v.cfg,
                                    v.layers
                                );
                                tCtxLocal.fillStyle = v.cfg.bgColor;
                                tCtxLocal.fillRect(0, 0, 400, 300);
                                const tPat = tCtxLocal.createPattern(tOffCvs, "repeat");
                                const pMat = new DOMMatrix()
                                    .translate(200, 150)
                                    .scale(1.2, 1.2)
                                    .translate(-tExpW / 2, -tExpH / 2);
                                tPat.setTransform(pMat);
                                tCtxLocal.fillStyle = tPat;
                                tCtxLocal.fillRect(0, 0, 400, 300);
                                thumb.onclick = () => {
                                    Object.assign(cfg, v.cfg);
                                    layerCfgs = v.layers;
                                    overlay.style.display = "none";
                                    syncUI();
                                    invalidateGeomCache();
                                    setupLayerUI();
                                    markDirty();
                                };
                            });
                    }

                    function setupCoreUI() {
                        const container = document.getElementById("core-controls");
                        container.innerHTML = "";
                        coreControlDefs.forEach((d) => {
                            const row = document.createElement("div");
                            row.className = "ctrl-row";
                            let snapOpts = d.snaps
                                .map((s) => `<option value="${s}">${s}</option>`)
                                .join("");
                            row.innerHTML = `<label>${d.label}</label><select id="snap_${
            d.id
          }" class="inp-select" style="width:36px; padding:0; text-align:center;">${snapOpts}</select><input type="range" id="${
            d.id
          }" min="${d.min}" max="${d.max}" step="${d.step}" value="${
            cfg[d.id] / d.mult
          }"><span id="${d.id}Val" class="val"></span>`;
                            container.appendChild(row);
                            const input = document.getElementById(d.id),
                                snapSel = document.getElementById("snap_" + d.id);
                            input.oninput = (e) => {
                                let val = parseFloat(e.target.value) * d.mult;
                                const snap = parseFloat(snapSel.value);
                                if (snap > 0) val = Math.round(val / snap) * snap;
                                cfg[d.id] = val;
                                syncLabels();
                                markDirty();
                            };
                        });
                    }

                    function setupLayerUI() {
                        const container = document.getElementById("layers-container");
                        container.innerHTML = "";
                        layerCfgs.forEach((l, idx) => {
                            const card = document.createElement("div");
                            card.className = `layer-item`;
                            card.style.borderLeft = `3px solid ${l.c}`;
                            card.innerHTML = `<div class="layer-head p-1.5 flex items-center justify-between border-b border-[#222]"><div class="flex items-center gap-1"><input type="checkbox" id="vis${idx}" ${
            l.vis ? "checked" : ""
          } class="chk"><span class="text-[9px] font-bold text-gray-400 uppercase tracking-tight">${
            l.name
          }</span></div><div id="blendBtn${idx}" class="inp-select py-0 px-2 h-5 flex items-center justify-center font-bold uppercase text-[8px] min-w-[75px]">${
            l.b
          }</div></div><div class="layer-body"><div class="grid grid-cols-[40px_1fr_24px] gap-2 items-center h-4"><div class="color-well" style="background-color:${
            l.c
          }"><input type="color" id="c${idx}" value="${
            l.c
          }"></div><input type="range" id="o${idx}" min="0" max="100" value="${
            l.o * 100
          }"><span class="text-[8px] text-gray-500 font-mono text-right uppercase">Fil</span></div><div class="grid grid-cols-[40px_1fr_1fr_24px] gap-2 items-center h-4"><div class="color-well" style="background-color:${
            l.sc
          }"><input type="color" id="sc${idx}" value="${
            l.sc
          }"></div><input type="range" id="sw${idx}" min="0" max="1000" value="${
            l.sw * 100
          }"><input type="range" id="so${idx}" min="0" max="100" value="${
            l.so * 100
          }"><span class="text-[8px] text-gray-500 font-mono text-right uppercase">Str</span></div><div class="grid grid-cols-[40px_1fr_1fr_1fr_24px] gap-2 items-center h-4"><div class="color-well" style="background-color:${
            l.shC
          }"><input type="color" id="shC${idx}" value="${
            l.shC
          }"></div><input type="range" id="shB${idx}" min="0" max="40" value="${
            l.shB
          }" title="Blur"><input type="range" id="shO${idx}" min="0" max="20" value="${
            l.shO
          }" title="Offset"><input type="range" id="ld${idx}" min="0" max="360" value="${
            l.ld
          }" title="Direction"><span class="text-[8px] text-gray-500 font-mono text-right uppercase">Fx</span></div></div>`;
                            container.appendChild(card);
                            document.getElementById(`blendBtn${idx}`).onclick = (e) =>
                                showBlendDropdown(e.target, l);
                            [
                                "vis",
                                "c",
                                "o",
                                "sc",
                                "sw",
                                "so",
                                "shB",
                                "shO",
                                "shC",
                                "ld",
                            ].forEach((key) => {
                                const el = document.getElementById(key + idx);
                                if (el)
                                    el.oninput = (e) => {
                                        if (key === "vis") l.vis = e.target.checked;
                                        else if (["c", "sc", "shC"].includes(key)) {
                                            l[key] = e.target.value;
                                            updateColorWell(el);
                                            if (key === "c") card.style.borderLeftColor = l.c;
                                        } else if (["shB", "shO", "ld"].includes(key))
                                            l[key] = parseFloat(e.target.value);
                                        else l[key] = e.target.value / 100;
                                        markDirty();
                                    };
                            });
                        });
                    }

                    function showBlendDropdown(target, currentLayer) {
                        const menu = document.getElementById("blendDropdown"),
                            rect = target.getBoundingClientRect();
                        menu.style.top = rect.bottom + "px";
                        menu.style.left = rect.left + "px";
                        menu.style.width = rect.width + "px";
                        menu.style.display = "block";
                        menu.innerHTML = "";
                        const originalValue = currentLayer.b;
                        let finalized = false;
                        BLEND_MODES.forEach((mode) => {
                            const item = document.createElement("div");
                            item.className = `dropdown-item ${
            originalValue === mode ? "active" : ""
          }`;
                            item.textContent = mode.replace("-", " ");
                            item.onmouseenter = () => {
                                if (!finalized) {
                                    currentLayer.b = mode;
                                    markDirty();
                                }
                            };
                            item.onclick = (e) => {
                                e.stopPropagation();
                                finalized = true;
                                currentLayer.b = mode;
                                target.textContent = mode.toUpperCase();
                                menu.style.display = "none";
                                markDirty();
                            };
                            menu.appendChild(item);
                        });
                        const close = (e) => {
                            if (!menu.contains(e.target) && e.target !== target) {
                                if (!finalized) currentLayer.b = originalValue;
                                menu.style.display = "none";
                                document.removeEventListener("mousedown", close);
                                markDirty();
                            }
                        };
                        document.addEventListener("mousedown", close);
                    }

                    function showTopoDropdown(target) {
                        const menu = document.getElementById("topoDropdown"),
                            rect = target.getBoundingClientRect();
                        menu.style.top = rect.bottom + "px";
                        menu.style.left = rect.left + "px";
                        menu.style.width = rect.width + "px";
                        menu.style.display = "block";
                        menu.innerHTML = "";
                        const originalValue = cfg.gridType;
                        let topoHandler = null;

                        LATTICES.forEach((lat) => {
                            const item = document.createElement("div");
                            item.className = `dropdown-item ${
            originalValue === lat.id ? "active" : ""
          }`;
                            item.innerHTML = `<span>${lat.label}</span><div id="prev_${lat.id}" class="topo-preview"></div>`;
                            item.onmouseenter = () => {
                                cfg.gridType = lat.id;
                                invalidateGeomCache();
                            };
                            item.onclick = (e) => {
                                e.stopPropagation();
                                cfg.gridType = lat.id;
                                document.getElementById("gridTypeLabel").textContent =
                                    lat.label.toUpperCase();
                                document
                                    .getElementById("truncControl")
                                    .classList.toggle("hidden", cfg.gridType !== "truncsquare");
                                menu.style.display = "none";
                                document.removeEventListener("mousedown", topoHandler);
                                invalidateGeomCache();
                            };
                            menu.appendChild(item);

                            const container = document.getElementById(`prev_${lat.id}`);
                            container.innerHTML = "";
                            const pCvs = document.createElement("canvas");
                            pCvs.width = 88;
                            pCvs.height = 56;
                            container.appendChild(pCvs);

                            const pCtx = pCvs.getContext("2d");
                            const tDim = getUnitCellDimensions(lat.id);
                            const tScale = 44 / tDim.w;
                            const tempCfg = JSON.parse(JSON.stringify(cfg));
                            tempCfg.gridType = lat.id;
                            tempCfg.bgColor = "#000";
                            tempCfg.iterations = 1;
                            tempCfg.expansion = Math.min(tempCfg.expansion, 0.8);
                            tempCfg.autoAnim = false;

                            try {
                                renderTile(pCtx, 88, 56, tScale, tempCfg);
                            } catch (e) {}
                        });

                        topoHandler = (e) => {
                            if (!menu.contains(e.target) && e.target !== target) {
                                cfg.gridType = originalValue;
                                menu.style.display = "none";
                                document.removeEventListener("mousedown", topoHandler);
                                invalidateGeomCache();
                            }
                        };
                        document.addEventListener("mousedown", topoHandler);
                    }

                    function syncLabels() {
                        coreControlDefs.forEach((d) => {
                            const v = document.getElementById(d.id + "Val");
                            if (v)
                                v.innerText =
                                (cfg[d.id] * (d.unitMul || 1)).toFixed(d.unitMul ? 0 : 1) +
                                d.unit;
                        });
                        [
                            "mod_rot",
                            "mod_round",
                            "mod_exp",
                            "mod_offset",
                            "animTempo",
                            "iterations",
                            "lightDir",
                        ].forEach((id) => {
                            const v = document.getElementById(id + "Val");
                            if (v)
                                v.innerText =
                                id === "animTempo" ?
                                cfg[id].toFixed(1) :
                                id === "iterations" ?
                                cfg[id] :
                                id === "lightDir" ?
                                cfg[id] + "°" :
                                Math.round(cfg[id] * 100) + "%";
                        });
                        const resSlider = document.getElementById("exportResSlider");
                        if (resSlider)
                            document.getElementById("exportResVal").innerText = `${Math.pow(
            2,
            parseInt(resSlider.value)
          )} PX`;
                    }

                    function syncUI() {
                        Object.keys(cfg).forEach((id) => {
                            const el = document.getElementById(id);
                            if (el && el.type !== "color") {
                                if (el.type === "checkbox") el.checked = cfg[id];
                                else if (el.type === "range") {
                                    const def = coreControlDefs.find((d) => d.id === id);
                                    el.value = def ?
                                        cfg[id] / def.mult : ["animTempo", "iterations", "lightDir"].includes(id) ?
                                        cfg[id] :
                                        cfg[id] * 100;
                                } else el.value = cfg[id];
                            }
                        });
                        const bgInp = document.querySelector("input#bgColor");
                        if (bgInp) {
                            bgInp.value = cfg.bgColor;
                            updateColorWell(bgInp);
                        }
                        const lat = LATTICES.find((l) => l.id === cfg.gridType);
                        if (lat)
                            document.getElementById("gridTypeLabel").textContent =
                            lat.label.toUpperCase();
                        document
                            .getElementById("truncControl")
                            .classList.toggle("hidden", cfg.gridType !== "truncsquare");
                        syncLabels();
                    }

                    function rebuildLayers() {
                        const newLayers = [];
                        const getOld = (id) => layerCfgs.find((l) => l.id === id);
                        newLayers.push(
                            getOld("base") || {
                                id: "base",
                                name: "Base Grid",
                                vis: true,
                                c: "#1f2937",
                                o: 0.1,
                                sc: "#374151",
                                sw: 1,
                                so: 1,
                                b: "source-over",
                                shB: 0,
                                shO: 0,
                                shC: "#000000",
                                ld: 0,
                            }
                        );
                        newLayers.push(
                            getOld("dual") || {
                                id: "dual",
                                name: "Dual Grid",
                                vis: false,
                                c: "#10b981",
                                o: 0.1,
                                sc: "#34d399",
                                sw: 1,
                                so: 1,
                                b: "overlay",
                                shB: 0,
                                shO: 0,
                                shC: "#000000",
                                ld: 0,
                            }
                        );
                        for (let i = 1; i <= cfg.iterations; i++) {
                            const pal = generatePalette();
                            newLayers.push(
                                getOld(`ag${i}`) || {
                                    id: `ag${i}`,
                                    name: `Geom ${i}`,
                                    vis: true,
                                    c: pal[0],
                                    o: 0.3,
                                    sc: pal[1],
                                    sw: 1,
                                    so: 1,
                                    b: "source-over",
                                    shB: 10,
                                    shO: 5,
                                    shC: "#000000",
                                    ld: 0,
                                }
                            );
                            newLayers.push(
                                getOld(`ad${i}`) || {
                                    id: `ad${i}`,
                                    name: `Dual ${i}`,
                                    vis: false,
                                    c: pal[2],
                                    o: 0.3,
                                    sc: pal[3],
                                    sw: 1,
                                    so: 1,
                                    b: "screen",
                                    shB: 10,
                                    shO: 5,
                                    shC: "#000000",
                                    ld: 0,
                                }
                            );
                        }
                        layerCfgs = newLayers;
                        setupLayerUI();
                        markDirty();
                    }

                    function savePresetToFile() {
                        const data = JSON.stringify({
                            cfg,
                            layerCfgs
                        }, null, 2);
                        const blob = new Blob([data], {
                            type: "application/json"
                        });
                        const url = URL.createObjectURL(blob);
                        const link = document.createElement("a");
                        link.href = url;
                        link.download = `tiling_preset_${Date.now()}.json`;
                        link.click();
                        URL.revokeObjectURL(url);
                        showToast("Preset Downloaded");
                    }

                    function loadPresetFromFile() {
                        const input = document.createElement("input");
                        input.type = "file";
                        input.accept = ".json";
                        input.onchange = (e) => {
                            const file = e.target.files[0];
                            if (!file) return;
                            const reader = new FileReader();
                            reader.onload = (re) => {
                                try {
                                    const d = JSON.parse(re.target.result);
                                    if (d.cfg && d.layerCfgs) {
                                        Object.assign(cfg, d.cfg);
                                        layerCfgs = d.layerCfgs;
                                        setupLayerUI();
                                        syncUI();
                                        invalidateGeomCache();
                                        markDirty();
                                        showToast("Preset Imported");
                                    } else {
                                        showToast("Invalid Preset File");
                                    }
                                } catch (err) {
                                    console.error("Import error", err);
                                    showToast("Failed to Read Preset");
                                }
                            };
                            reader.readAsText(file);
                        };
                        input.click();
                    }

                    function exportImage(type) {
                        const resW = Math.pow(
                                2,
                                parseInt(document.getElementById("exportResSlider").value)
                            ),
                            dim = getUnitCellDimensions();
                        const target = document.createElement("canvas");
                        target.width = resW;
                        target.height = Math.round(resW * (dim.h / dim.w));
                        const eCtx = target.getContext("2d");
                        setFiltering(eCtx, cfg.filterMode);
                        renderTile(eCtx, target.width, target.height, resW / dim.w);
                        const link = document.createElement("a");
                        link.download = `exported_tile_${Date.now()}.${type}`;
                        link.href = target.toDataURL(`image/${type}`);
                        link.click();
                        showToast(`${type.toUpperCase()} EXPORTED`);
                    }

                    function generateBaseGrid(dim, pCfg) {
                        const currentCfg = pCfg || cfg;
                        const neededPad =
                            2.5 + currentCfg.iterations * 0.4 * Math.max(1, currentCfg.expansion);

                        if (!pCfg &&
                            geomCache.baseGridType === currentCfg.gridType &&
                            geomCache.baseFaces &&
                            geomCache.basePad >= neededPad &&
                            geomCache.baseLatParam === currentCfg.latParam1
                        ) {
                            return {
                                faces: geomCache.baseFaces,
                                duals: geomCache.baseDuals
                            };
                        }

                        const s = 100;
                        const b = {
                            x1: -dim.w * neededPad,
                            x2: dim.w * neededPad,
                            y1: -dim.h * neededPad,
                            y2: dim.h * neededPad,
                        };

                        let faces = [];
                        const gt = currentCfg.gridType;

                        if (gt === "square") {
                            for (let y = Math.floor(b.y1 / s) * s; y < b.y2; y += s)
                                for (let x = Math.floor(b.x1 / s) * s; x < b.x2; x += s)
                                    faces.push({
                                        pts: [{
                                            x,
                                            y
                                        }, {
                                            x: x + s,
                                            y
                                        }, {
                                            x: x + s,
                                            y: y + s
                                        }, {
                                            x,
                                            y: y + s
                                        }, ],
                                    });
                        } else if (gt === "hex") {
                            const h = (s * Math.sqrt(3)) / 2;
                            for (
                                let r = Math.floor(b.y1 / (h * 2)) - 2; r * h * 2 < b.y2 + h; r++
                            )
                                for (
                                    let c = Math.floor(b.x1 / (s * 1.5)) - 2; c * s * 1.5 < b.x2 + s; c++
                                ) {
                                    const cx = c * s * 1.5,
                                        cy = r * h * 2 + (Math.abs(c) % 2 ? h : 0);
                                    const pts = [];
                                    for (let i = 0; i < 6; i++)
                                        pts.push({
                                            x: cx + s * Math.cos((i * Math.PI) / 3),
                                            y: cy + s * Math.sin((i * Math.PI) / 3),
                                        });
                                    faces.push({
                                        pts
                                    });
                                }
                        } else if (gt === "tri") {
                            const h = (s * Math.sqrt(3)) / 2;
                            for (let r = Math.floor(b.y1 / h) - 1; r * h < b.y2 + h; r++) {
                                const off = Math.abs(r) % 2 ? s / 2 : 0;
                                for (let c = Math.floor(b.x1 / s) - 1; c * s < b.x2 + s; c++) {
                                    const x = c * s + off;
                                    faces.push({
                                        pts: [{
                                            x,
                                            y: r * h
                                        }, {
                                            x: x + s,
                                            y: r * h
                                        }, {
                                            x: x + s / 2,
                                            y: (r + 1) * h
                                        }, ],
                                    });
                                    faces.push({
                                        pts: [{
                                            x: x + s,
                                            y: r * h
                                        }, {
                                            x: x + s * 1.5,
                                            y: (r + 1) * h
                                        }, {
                                            x: x + s / 2,
                                            y: (r + 1) * h
                                        }, ],
                                    });
                                }
                            }
                        } else if (gt === "tetrille") {
                            const h = s * Math.sqrt(3);
                            for (let r = Math.floor(b.y1 / h) - 1; r * h < b.y2 + h; r++)
                                for (
                                    let c = Math.floor(b.x1 / (s * 1.5)) - 1; c * s * 1.5 < b.x2 + s; c++
                                ) {
                                    const cx = c * s * 1.5,
                                        cy = r * h + (Math.abs(c) % 2 ? h / 2 : 0);
                                    for (let i = 0; i < 6; i++) {
                                        const a = (i * Math.PI) / 3;
                                        faces.push({
                                            pts: [{
                                                x: cx,
                                                y: cy
                                            }, {
                                                x: cx + s * 0.5 * Math.cos(a),
                                                y: cy + s * 0.5 * Math.sin(a),
                                            }, {
                                                x: cx + s * 0.866 * Math.cos(a + Math.PI / 6),
                                                y: cy + s * 0.866 * Math.sin(a + Math.PI / 6),
                                            }, {
                                                x: cx + s * 0.5 * Math.cos(a + Math.PI / 3),
                                                y: cy + s * 0.5 * Math.sin(a + Math.PI / 3),
                                            }, ],
                                        });
                                    }
                                }
                        } else if (gt === "truncsquare") {
                            const k = s * (currentCfg.latParam1 || 0.33);
                            for (let y = Math.floor(b.y1 / s) * s; y < b.y2; y += s)
                                for (let x = Math.floor(b.x1 / s) * s; x < b.x2; x += s) {
                                    faces.push({
                                        pts: [{
                                            x: x + k,
                                            y: y
                                        }, {
                                            x: x + s - k,
                                            y: y
                                        }, {
                                            x: x + s,
                                            y: y + k
                                        }, {
                                            x: x + s,
                                            y: y + s - k
                                        }, {
                                            x: x + s - k,
                                            y: y + s
                                        }, {
                                            x: x + k,
                                            y: y + s
                                        }, {
                                            x: x,
                                            y: y + s - k
                                        }, {
                                            x: x,
                                            y: y + k
                                        }, ],
                                    });
                                    faces.push({
                                        pts: [{
                                            x: x + s - k,
                                            y: y + s
                                        }, {
                                            x: x + s,
                                            y: y + s - k
                                        }, {
                                            x: x + s + k,
                                            y: y + s
                                        }, {
                                            x: x + s,
                                            y: y + s + k
                                        }, ],
                                    });
                                }
                        }

                        const extractDuals = (polyList) => {
                            const vertMap = new Map();
                            polyList.forEach((f, fIdx) => {
                                f.pts.forEach((p) => {
                                    const vK = hashCoord(p);
                                    if (!vertMap.has(vK)) vertMap.set(vK, {
                                        p,
                                        f: []
                                    });
                                    vertMap.get(vK).f.push(fIdx);
                                });
                            });
                            const duals = [];
                            vertMap.forEach((v) => {
                                if (v.f.length < 3) return;
                                const pts = v.f
                                    .map((fi) => {
                                        const f = polyList[fi];
                                        const cx = f.pts.reduce((a, b) => a + b.x, 0) / f.pts.length,
                                            cy = f.pts.reduce((a, b) => a + b.y, 0) / f.pts.length;
                                        return {
                                            x: cx,
                                            y: cy,
                                            a: Math.atan2(cy - v.p.y, cx - v.p.x)
                                        };
                                    })
                                    .sort((a, b) => a.a - b.a);
                                duals.push({
                                    pts
                                });
                            });
                            return duals;
                        };

                        const duals = extractDuals(faces);

                        if (!pCfg) {
                            geomCache.baseGridType = gt;
                            geomCache.baseFaces = faces;
                            geomCache.baseDuals = duals;
                            geomCache.basePad = neededPad;
                            geomCache.baseLatParam = currentCfg.latParam1;
                        }
                        return {
                            faces,
                            duals
                        };
                    }

                    function showTopoDropdown(target) {
                        const menu = document.getElementById("topoDropdown"),
                            rect = target.getBoundingClientRect();
                        menu.style.top = rect.bottom + "px";
                        menu.style.left = rect.left + "px";
                        menu.style.width = rect.width + "px";
                        menu.style.display = "block";
                        menu.innerHTML = "";
                        const originalValue = cfg.gridType;
                        let topoHandler = null;

                        LATTICES.forEach((lat) => {
                            const item = document.createElement("div");
                            item.className = `dropdown-item ${
            originalValue === lat.id ? "active" : ""
          }`;
                            item.innerHTML = `<span>${lat.label}</span><div id="prev_${lat.id}" class="topo-preview"></div>`;
                            item.onmouseenter = () => {
                                cfg.gridType = lat.id;
                                invalidateGeomCache();
                            };
                            item.onclick = (e) => {
                                e.stopPropagation();
                                cfg.gridType = lat.id;
                                document.getElementById("gridTypeLabel").textContent =
                                    lat.label.toUpperCase();
                                document
                                    .getElementById("truncControl")
                                    .classList.toggle("hidden", cfg.gridType !== "truncsquare");
                                menu.style.display = "none";
                                document.removeEventListener("mousedown", topoHandler);
                                invalidateGeomCache();
                            };
                            menu.appendChild(item);

                            const container = document.getElementById(`prev_${lat.id}`);
                            container.innerHTML = "";
                            const pCvs = document.createElement("canvas");
                            pCvs.width = 88;
                            pCvs.height = 56;
                            container.appendChild(pCvs);

                            const pCtx = pCvs.getContext("2d");
                            const tDim = getUnitCellDimensions(lat.id);
                            const tScale = 44 / tDim.w;
                            const tempCfg = JSON.parse(JSON.stringify(cfg));
                            tempCfg.gridType = lat.id;
                            tempCfg.bgColor = "#000";
                            tempCfg.iterations = 1;
                            tempCfg.expansion = Math.min(tempCfg.expansion, 0.8);
                            tempCfg.autoAnim = false;

                            try {
                                renderTile(pCtx, 88, 56, tScale, tempCfg);
                            } catch (e) {}
                        });

                        topoHandler = (e) => {
                            if (!menu.contains(e.target) && e.target !== target) {
                                cfg.gridType = originalValue;
                                menu.style.display = "none";
                                document.removeEventListener("mousedown", topoHandler);
                                invalidateGeomCache();
                            }
                        };
                        document.addEventListener("mousedown", topoHandler);
                    }

                    function renderLayer(
                        targetCtx,
                        layer,
                        data,
                        w,
                        h,
                        rounding,
                        scale,
                        pCfg
                    ) {
                        const currentCfg = pCfg || cfg;
                        const sides = Math.floor(currentCfg.polySides);
                        const hasShadow =
                            (layer.shB > 0 || Math.abs(layer.shO) > 0) && currentCfg.enableFX;

                        if (!hasShadow) {
                            targetCtx.save();
                            targetCtx.globalCompositeOperation = layer.b;
                            targetCtx.translate(-w / 2, -h / 2);
                            targetCtx.scale(scale, scale);
                            targetCtx.lineJoin = "round";
                            targetCtx.lineCap = "round";
                            targetCtx.fillStyle = getRGBA(layer.c, layer.o);
                            targetCtx.strokeStyle = getRGBA(layer.sc, layer.so);
                            targetCtx.lineWidth = layer.sw;
                            if (data instanceof Float32Array)
                                renderBufferDirect(targetCtx, data, rounding, sides);
                            else drawPathDirect(targetCtx, data, rounding);
                            targetCtx.restore();
                            return;
                        }

                        if (tileCanvas.width !== w || tileCanvas.height !== h) {
                            tileCanvas.width = w;
                            tileCanvas.height = h;
                        } else tCtx.clearRect(0, 0, w, h);

                        tCtx.save();
                        tCtx.scale(scale, scale);
                        tCtx.lineJoin = "round";
                        tCtx.lineCap = "round";
                        tCtx.fillStyle = getRGBA(layer.c, layer.o);
                        tCtx.strokeStyle = getRGBA(layer.sc, layer.so);
                        tCtx.lineWidth = layer.sw;
                        if (data instanceof Float32Array)
                            renderBufferDirect(tCtx, data, rounding, sides);
                        else drawPathDirect(tCtx, data, rounding);
                        tCtx.restore();

                        const tw = w * 3,
                            th = h * 3;
                        if (tileStack.width !== tw || tileStack.height !== th) {
                            tileStack.width = tw;
                            tileStack.height = th;
                        } else tsCtx.clearRect(0, 0, tw, th);

                        for (let ty = 0; ty < 3; ty++)
                            for (let tx = 0; tx < 3; tx++)
                                tsCtx.drawImage(tileCanvas, tx * w, ty * h);

                        if (shadowBuffer.width !== tw || shadowBuffer.height !== th) {
                            shadowBuffer.width = tw;
                            shadowBuffer.height = th;
                        } else sbCtx.clearRect(0, 0, tw, th);

                        sbCtx.save();
                        sbCtx.shadowBlur = layer.shB * scale;
                        sbCtx.shadowColor = getRGBA(layer.shC || "#000000", 0.6);
                        const lightAngle = rad((layer.ld || 0) + currentCfg.lightDir);
                        sbCtx.shadowOffsetX = Math.cos(lightAngle) * layer.shO * scale;
                        sbCtx.shadowOffsetY = Math.sin(lightAngle) * layer.shO * scale;
                        sbCtx.drawImage(tileStack, 0, 0);
                        sbCtx.restore();

                        targetCtx.save();
                        targetCtx.globalCompositeOperation = layer.b;
                        targetCtx.drawImage(shadowBuffer, w, h, w, h, -w / 2, -h / 2, w, h);
                        targetCtx.restore();
                    }

                    function exportSVG() {
                        const dim = getUnitCellDimensions();
                        const baseData = generateBaseGrid(dim);
                        const activeData = generateActiveGeom(baseData);
                        const sides = Math.floor(cfg.polySides);
                        const curRounding = cfg.rounding;

                        let svg = `<svg width="${dim.w}" height="${dim.h}" viewBox="0 0 ${dim.w} ${dim.h}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="background:${cfg.bgColor}">`;
                        svg += `<defs>`;

                        const buildPath = (data, isRaw) => {
                            let d = "";
                            if (isRaw) {
                                const polyVertices = sides * 2;
                                const stride = polyVertices * 4;
                                const isSharp = curRounding < 0.01;
                                for (let i = 0; i < data.length; i += stride) {
                                    const pts = [];
                                    for (let k = 0; k < stride; k += 4)
                                        pts.push({
                                            x: data[i + k],
                                            y: data[i + k + 1]
                                        });
                                    if (isSharp) {
                                        d +=
                                            `M ${pts[0].x} ${pts[0].y} ` +
                                            pts
                                            .slice(1)
                                            .map((p) => `L ${p.x} ${p.y}`)
                                            .join(" ") +
                                            " Z ";
                                    } else {
                                        for (let j = 0; j < pts.length; j++) {
                                            const p1 = pts[j],
                                                p0 = pts[(j - 1 + pts.length) % pts.length],
                                                p2 = pts[(j + 1) % pts.length];
                                            const v1 = {
                                                    x: p0.x - p1.x,
                                                    y: p0.y - p1.y
                                                },
                                                v2 = {
                                                    x: p2.x - p1.x,
                                                    y: p2.y - p1.y
                                                };
                                            const l1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y),
                                                l2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);
                                            const r = Math.min(l1, l2) * 0.5 * curRounding;
                                            const sx = p1.x + (v1.x / l1) * r,
                                                sy = p1.y + (v1.y / l1) * r;
                                            const ex = p1.x + (v2.x / l2) * r,
                                                ey = p1.y + (v2.y / l2) * r;
                                            d +=
                                                (j === 0 ? `M ${sx} ${sy} ` : `L ${sx} ${sy} `) +
                                                `Q ${p1.x} ${p1.y}, ${ex} ${ey} `;
                                        }
                                        d += "Z ";
                                    }
                                }
                            } else {
                                data.forEach((item) => {
                                    const pts = item.pts;
                                    if (pts.length < 3) return;
                                    if (curRounding < 0.01) {
                                        d +=
                                            `M ${pts[0].x} ${pts[0].y} ` +
                                            pts
                                            .slice(1)
                                            .map((p) => `L ${p.x} ${p.y}`)
                                            .join(" ") +
                                            " Z ";
                                    } else {
                                        for (let i = 0; i < pts.length; i++) {
                                            const p1 = pts[i],
                                                p0 = pts[(i - 1 + pts.length) % pts.length],
                                                p2 = pts[(i + 1) % pts.length];
                                            const v1 = {
                                                    x: p0.x - p1.x,
                                                    y: p0.y - p1.y
                                                },
                                                v2 = {
                                                    x: p2.x - p1.x,
                                                    y: p2.y - p1.y
                                                };
                                            const l1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y),
                                                l2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);
                                            const r = Math.min(l1, l2) * 0.5 * curRounding;
                                            const sx = p1.x + (v1.x / l1) * r,
                                                sy = p1.y + (v1.y / l1) * r;
                                            const ex = p1.x + (v2.x / l2) * r,
                                                ey = p1.y + (v2.y / l2) * r;
                                            d +=
                                                (i === 0 ? `M ${sx} ${sy} ` : `L ${sx} ${sy} `) +
                                                `Q ${p1.x} ${p1.y}, ${ex} ${ey} `;
                                        }
                                        d += "Z ";
                                    }
                                });
                            }
                            return d;
                        };

                        const drawLayerToDefs = (id, data, l, isRaw) => {
                                if (!data) return;
                                const pathData = buildPath(data, isRaw);
                                const hasSh = (l.shB > 0 || l.shO !== 0) && cfg.enableFX;
                                if (hasSh) {
                                    const lightAngle = rad((l.ld || 0) + cfg.lightDir);
                                    svg += `<filter id="f_${id}" x="-50%" y="-50%" width="200%" height="200%">
                        <feGaussianBlur in="SourceAlpha" stdDeviation="${
                          l.shB / 2
                        }" result="blur"/>
                        <feOffset in="blur" dx="${
                          Math.cos(lightAngle) * l.shO
                        }" dy="${
              Math.sin(lightAngle) * l.shO
            }" result="offsetBlur"/>
                        <feFlood flood-color="${
                          l.shC
                        }" flood-opacity="0.6" result="colorBlur"/>
                        <feComposite in="colorBlur" in2="offsetBlur" operator="in" result="shadow"/>
                        <feMerge><feMergeNode in="shadow"/><feMergeNode in="SourceGraphic"/></feMerge>
                    </filter>`;
                                }
                                svg += `<symbol id="${id}"><path d="${pathData}" fill="${
            l.c
          }" fill-opacity="${l.o}" stroke="${l.sc}" stroke-width="${
            l.sw
          }" stroke-opacity="${l.so || 1}" ${
            hasSh ? `filter="url(#f_${id})"` : ""
          } /></symbol>`;
        };

        const layersToExport = [];
        const baseL = layerCfgs.find((l) => l.id === "base");
        if (baseL && baseL.vis)
          layersToExport.push({
            id: "base",
            data: baseData.faces,
            cfg: baseL,
            raw: false,
          });
        const dualL = layerCfgs.find((l) => l.id === "dual");
        if (dualL && dualL.vis)
          layersToExport.push({
            id: "dual",
            data: baseData.duals,
            cfg: dualL,
            raw: false,
          });
        for (let i = 0; i < cfg.iterations; i++) {
          const agL = layerCfgs.find((l) => l.id === `ag${i + 1}`);
          if (agL && agL.vis)
            layersToExport.push({
              id: `ag${i + 1}`,
              data: activeData.activeGeoms[i],
              cfg: agL,
              raw: true,
            });
          const adL = layerCfgs.find((l) => l.id === `ad${i + 1}`);
          if (adL && adL.vis)
            layersToExport.push({
              id: `ad${i + 1}`,
              data: activeData.activeDuals[i],
              cfg: adL,
              raw: true,
            });
        }

        layersToExport.forEach((l) =>
          drawLayerToDefs(l.id, l.data, l.cfg, l.raw)
        );
        svg += `</defs>`;
        layersToExport.forEach((l) => {
          svg += `<g style="mix-blend-mode:${l.cfg.b}">`;
          for (let ty = -1; ty <= 1; ty++)
            for (let tx = -1; tx <= 1; tx++)
              svg += `<use xlink:href="#${l.id}" x="${tx * dim.w}" y="${
                ty * dim.h
              }" />`;
          svg += `</g>`;
        });
        svg += `</svg>`;

        const link = document.createElement("a");
        link.download = `exported_tile_${Date.now()}.svg`;
        link.href = URL.createObjectURL(
          new Blob([svg], { type: "image/svg+xml" })
        );
        link.click();
        showToast("SVG EXPORTED");
      }

      window.onload = () => {
        setupCoreUI();
        setupLayerUI();
        syncUI();
        const rsz = document.getElementById("resizer"),
          sdb = document.getElementById("sidebar");
        let dragging = false;
        rsz.onmousedown = () => (dragging = true);
        document.onmouseup = () => (dragging = false);
        document.onmousemove = (e) => {
          if (dragging) {
            sdb.style.width = Math.max(320, Math.min(e.clientX, 600)) + "px";
            resize();
          }
        };
        document.getElementById("gridSelector").onclick = (e) =>
          showTopoDropdown(e.currentTarget);
        document.getElementById("bgColor").oninput = (e) => {
          cfg.bgColor = e.target.value;
          updateColorWell(e.target);
          markDirty();
        };
        document.getElementById("iterations").oninput = (e) => {
          cfg.iterations = parseInt(e.target.value);
          syncLabels();
          rebuildLayers();
        };
        document.getElementById("lightDir").oninput = (e) => {
          cfg.lightDir = parseInt(e.target.value);
          markDirty();
          syncLabels();
        };
        document.getElementById("enableFX").onchange = (e) => {
          cfg.enableFX = e.target.checked;
          markDirty();
        };
        document.getElementById("singleTile").onchange = (e) => {
          cfg.singleTile = e.target.checked;
          markDirty();
        };
        document.getElementById("filterMode").onchange = (e) => {
          cfg.filterMode = e.target.value;
          markDirty();
        };
        document.getElementById("exportResSlider").oninput = () => syncLabels();
        document.getElementById("btnRandGrid").onclick = () => {
          cfg.gridType =
            LATTICES[Math.floor(Math.random() * LATTICES.length)].id;
          cfg.polySides = 3 + Math.floor(Math.random() * 13);
          cfg.expansion = 0.1 + Math.random();
          cfg.polyRot = Math.random() * 360;
          cfg.rounding = Math.random() * 1.0;
          cfg.spike = (Math.random() - 0.5) * 0.8;
          cfg.offsetX = (Math.random() - 0.5) * 0.4;
          cfg.offsetY = (Math.random() - 0.5) * 0.4;
          cfg.polyMirror = Math.random() > 0.5;
          cfg.latParam1 = 0.1 + Math.random() * 0.35;
          invalidateGeomCache();
          syncUI();
          markDirty();
        };
        document.getElementById("btnRandLayers").onclick = () => {
          const pal = generatePalette();
          cfg.bgColor = pal[0];
          layerCfgs.forEach((l, idx) => {
            l.c = pal[Math.floor(Math.random() * pal.length)];
            l.sc = pal[Math.floor(Math.random() * pal.length)];
            l.o = idx === 0 ? 0.1 : Math.random() * 0.4;
            l.so = 0.5 + Math.random() * 0.5;
            l.sw = 0.5 + Math.random() * 3;
            l.b =
              idx === 0
                ? "source-over"
                : BLEND_MODES[Math.floor(Math.random() * BLEND_MODES.length)];
            l.shB = Math.random() < 0.5 ? 0 : Math.random() * 20;
            l.shO = Math.random() * 8;
            l.ld = Math.floor(Math.random() * 360);
          });
          const bgInp = document.querySelector("input#bgColor");
          if (bgInp) {
            bgInp.value = cfg.bgColor;
            updateColorWell(bgInp);
          }
          setupLayerUI();
          markDirty();
        };
        document.getElementById("randBtn").onclick = () => {
          document.getElementById("btnRandGrid").onclick();
          document.getElementById("btnRandLayers").onclick();
        };
        document.getElementById("btnOpenEvo").onclick = openEvolution;
        document.getElementById("btnEvolveNow").onclick = openEvolution;
        document.getElementById("btnRefreshEvo").onclick = openEvolution;
        document.getElementById("btnCloseEvo").onclick = () => {
          document.getElementById("evoOverlay").style.display = "none";
        };
        document.getElementById("exportPng").onclick = () => exportImage("png");
        document.getElementById("exportBmp").onclick = () => exportImage("bmp");
        document.getElementById("exportSvg").onclick = exportSVG;
        document.getElementById("btnSavePreset").onclick = savePresetToFile;
        document.getElementById("btnLoadPreset").onclick = loadPresetFromFile;
        ["polyMirror", "latParam1"].forEach((id) => {
          const el = document.getElementById(id);
          if (el)
            el.oninput = (e) => {
              if (id === "latParam1") {
                cfg[id] = e.target.value / 100;
                invalidateGeomCache();
              } else
                cfg[id] =
                  e.target.type === "checkbox"
                    ? e.target.checked
                    : parseFloat(e.target.value) / 100;
              markDirty();
              syncLabels();
            };
        });
        window.onresize = resize;
        resize();
        render();
      };

      function loop() {}
                </script>
</body>

</html>