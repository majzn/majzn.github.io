<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pro Pia Studio v19.2 - Production Grade Tiling Engine</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&family=JetBrains+Mono:wght@500;700&display=swap');
        :root { --acc: #3b82f6; --bg-deep: #020617; --bg-panel: #0f172a; }
        body { background-color: var(--bg-deep); color: #f1f5f9; overflow: hidden; font-family: 'Inter', sans-serif; }
        canvas { touch-action: none; display: block; image-rendering: -webkit-optimize-contrast; image-rendering: crisp-edges; }
        .control-panel { position: relative; width: 340px; min-width: 300px; max-width: 550px; }
        .resizer { position: absolute; right: 0; top: 0; width: 4px; height: 100%; cursor: col-resize; z-index: 50; }
        .resizer:hover { background: rgba(59, 130, 246, 0.4); }
        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-thumb { background: #334155; border-radius: 2px; }
        input[type="range"] { accent-color: var(--acc); height: 4px; cursor: pointer; background: #334155; appearance: none; width: 100%; border-radius: 2px; }
        input[type="range"]::-webkit-slider-thumb { appearance: none; width: 12px; height: 12px; background: #fff; border-radius: 50%; border: 2px solid var(--acc); }
        .card { background: rgba(30, 41, 59, 0.35); border: 1px solid rgba(51, 65, 85, 0.4); border-radius: 8px; padding: 10px; margin-bottom: 8px; }
        .g-title { font-size: 0.6rem; text-transform: uppercase; letter-spacing: 0.15em; color: #64748b; font-weight: 900; margin: 12px 0 6px 0; display: flex; align-items: center; gap: 8px; }
        .g-title::after { content: ""; height: 1px; flex: 1; background: linear-gradient(to right, #1e293b, transparent); }
        .row-header { display: flex; align-items: center; justify-content: space-between; height: 20px; margin-bottom: 2px; }
        .row-header label { font-size: 9px; color: #94a3b8; font-weight: 800; text-transform: uppercase; letter-spacing: 0.05em; white-space: nowrap; }
        .val { font-family: 'JetBrains Mono', monospace; font-size: 10px; color: var(--acc); min-width: 3.5rem; text-align: right; font-weight: 700; }
        .snap-select { background: #020617; border: 1px solid #334155; border-radius: 4px; color: #64748b; font-size: 8px; font-weight: 900; width: 48px; height: 18px; outline: none; cursor: pointer; appearance: none; text-align: center; }
        select { background: #020617; border: 1px solid #334155; border-radius: 4px; color: white; font-size: 10px; padding: 2px 4px; outline: none; }
        .layer-card { background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(51, 65, 85, 0.3); border-radius: 8px; padding: 10px; margin-bottom: 8px; border-left-width: 4px; }
        .control-row { display: flex; align-items: center; gap: 8px; height: 20px; margin-bottom: 2px; }
        .control-row label { font-size: 8px; color: #475569; width: 45px; font-weight: 900; }
        .color-wrap { position: relative; width: 18px; height: 18px; border-radius: 4px; overflow: hidden; border: none; flex-shrink: 0; background: #1e293b; }
        .color-wrap input[type="color"] { position: absolute; top: -50%; left: -50%; width: 200%; height: 200%; cursor: pointer; border: none; background: none; }
        .btn-rand-small { font-size: 8px; font-weight: 900; color: #475569; opacity: 0.4; transition: opacity 0.2s; cursor: pointer; }
        .btn-rand-small:hover { opacity: 1; color: var(--acc); }
    </style>
</head>
<body class="flex h-screen w-screen m-0 p-0 overflow-hidden select-none">

    <div id="sidebar" class="control-panel bg-[#0f172a] border-r border-slate-800 flex flex-col p-4 overflow-y-auto z-20 shrink-0 shadow-2xl">
        <div id="resizer" class="resizer"></div>
        <div class="mb-4">
            <h1 class="text-base font-black text-white flex items-center gap-2">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="text-blue-500"><path d="M12 2l10 6.5v7L12 22 2 15.5v-7L12 2z"/><path d="M12 22v-6.5M2 15.5l10-6.5 10 6.5"/></svg>
                PIA STUDIO ULTRA
            </h1>
            <p class="text-[9px] text-slate-500 font-black tracking-[0.25em] pl-10 uppercase opacity-70">Production Grade Engine</p>
        </div>

        <div class="g-title"><span>Lattice Kernel</span><button onclick="randomizeLattice()" class="btn-rand-small">RAND</button></div>
        <div class="card">
            <select id="gridType" class="w-full mb-3 p-1.5 font-bold uppercase tracking-wider text-[10px]">
                <option value="square">Square Grid (4.4.4.4)</option>
                <option value="hex">Hexagonal Grid (6.6.6)</option>
                <option value="tri">Triangular Grid (3.3.3.3.3.3)</option>
                <option value="tetrille">Tetrille (Crystalline)</option>
                <option value="truncsquare">Truncated Square (4.8.8)</option>
            </select>
            <div id="latticeControls"></div>
        </div>

        <div class="g-title"><span>Morphology Controls</span><button onclick="randomizeMorphology()" class="btn-rand-small">RAND</button></div>
        <div class="card">
            <div class="row">
                <div class="row-header"><label>Global Scale</label><select id="snap_zoom" class="snap-select"><option value="0">OFF</option><option value="1" selected>1.0</option></select></div>
                <div class="flex items-center gap-3"><input type="range" id="zoom" min="20" max="800" value="120"><span id="zoomVal" class="val">120.0</span></div>
            </div>
            <div class="row">
                <div class="row-header"><label>Expansion Bias</label><select id="snap_expansion" class="snap-select"><option value="0">OFF</option><option value="0.05" selected>0.05</option></select></div>
                <div class="flex items-center gap-3"><input type="range" id="expansion" min="1" max="150" value="50"><span id="expansionVal" class="val">0.50</span></div>
            </div>
            <div class="row">
                <div class="row-header"><label>Segment Curvature</label><select id="snap_rounding" class="snap-select"><option value="0">OFF</option><option value="0.05" selected>0.05</option></select></div>
                <div class="flex items-center gap-3"><input type="range" id="rounding" min="0" max="100" value="0"><span id="roundingVal" class="val">0%</span></div>
            </div>
        </div>

        <div class="g-title"><span>Edge Generator</span><button onclick="randomizeEdge()" class="btn-rand-small">RAND</button></div>
        <div class="card">
            <div class="row"><div class="row-header"><label>Polygon Vertex Count</label></div><div class="flex items-center gap-3"><input type="range" id="polySides" min="3" max="32" step="1" value="4"><span id="polySidesVal" class="val">4</span></div></div>
            <div class="row"><div class="row-header"><label>Local Phase Offset</label><select id="snap_polyRot" class="snap-select"><option value="0">OFF</option><option value="15" selected>15.0°</option></select></div><div class="flex items-center gap-3"><input type="range" id="polyRot" min="0" max="360" step="0.5" value="0"><span id="polyRotVal" class="val">0.0°</span></div></div>
            <div class="row"><div class="row-header"><label>Linear Pivot X</label></div><div class="flex items-center gap-3"><input type="range" id="offsetX" min="-100" max="100" step="1" value="0"><span id="offsetXVal" class="val">0.00</span></div></div>
            <div class="row"><div class="row-header"><label>Linear Pivot Y</label></div><div class="flex items-center gap-3"><input type="range" id="offsetY" min="0" max="100" step="1" value="50"><span id="offsetYVal" class="val">0.50</span></div></div>
            <div class="flex items-center gap-3 mt-2"><input type="checkbox" id="polyMirror" class="w-4 h-4 rounded accent-blue-500"><label class="text-[10px] font-bold text-slate-400 uppercase tracking-widest">Mirror Dual Symmetry</label></div>
        </div>

        <div class="g-title"><span>LFO Modular Engine</span><button onclick="randomizeLFO()" class="btn-rand-small">RAND</button></div>
        <div class="card">
            <div class="flex items-center gap-3 mb-3"><input type="checkbox" id="autoAnim" class="w-4 h-4 accent-indigo-500"><label class="text-[11px] font-black text-indigo-400 uppercase tracking-widest">Studio Loop Master</label></div>
            <div class="row"><div class="row-header"><label>Master Tempo</label></div><input type="range" id="animTempo" min="1" max="100" value="30"></div>
            <div class="mt-4 space-y-3">
                <div class="flex flex-col gap-1">
                    <div class="flex justify-between items-center"><span class="text-[8px] font-black text-slate-500 uppercase">Local Poly Rotation</span><span id="mod_rotVal" class="text-[8px] text-blue-500 font-bold">0%</span></div>
                    <input type="range" id="mod_rot" min="0" max="100" value="0">
                </div>
                <div class="flex flex-col gap-1">
                    <div class="flex justify-between items-center"><span class="text-[8px] font-black text-slate-500 uppercase">Curvature Morph</span><span id="mod_roundVal" class="text-[8px] text-blue-500 font-bold">0%</span></div>
                    <input type="range" id="mod_round" min="0" max="100" value="0">
                </div>
                <div class="flex flex-col gap-1">
                    <div class="flex justify-between items-center"><span class="text-[8px] font-black text-slate-500 uppercase">Expansion LFO</span><span id="mod_expVal" class="text-[8px] text-blue-500 font-bold">0%</span></div>
                    <input type="range" id="mod_exp" min="0" max="100" value="0">
                </div>
                <div class="flex flex-col gap-1">
                    <div class="flex justify-between items-center"><span class="text-[8px] font-black text-slate-500 uppercase">Pivot Symmetry LFO</span><span id="mod_offsetVal" class="text-[8px] text-blue-500 font-bold">0%</span></div>
                    <input type="range" id="mod_offset" min="0" max="100" value="0">
                </div>
            </div>
        </div>

        <div class="g-title"><span>Multi-Layer Stylist</span><button onclick="randomizeLayers()" class="btn-rand-small">RAND</button></div>
        <div id="layers-container"></div>

        <div class="mt-auto pt-6 flex flex-col gap-3">
            <div class="row-header px-1"><label class="text-[10px] text-slate-500 uppercase font-black">Environment BG</label><div class="color-wrap"><input type="color" id="bgColor" value="#020617"></div></div>
            <button id="randBtn" class="w-full py-3 bg-blue-600 hover:bg-blue-500 text-white font-black text-[11px] uppercase tracking-widest rounded-lg shadow-xl active:scale-95 transition-all">Randomize Studio Core</button>
            <div class="grid grid-cols-3 gap-2">
                <button id="exportPng" class="py-2 bg-slate-800 hover:bg-slate-700 text-slate-300 font-bold text-[9px] uppercase rounded-md">PNG High</button>
                <button id="exportBmp" class="py-2 bg-slate-800 hover:bg-slate-700 text-slate-300 font-bold text-[9px] uppercase rounded-md">BMP Raw</button>
                <button id="exportSvg" class="py-2 bg-indigo-900 hover:bg-indigo-800 text-indigo-300 font-bold text-[9px] uppercase rounded-md border border-indigo-500/30">SVG Vector</button>
            </div>
        </div>
    </div>

    <div id="canvasContainer" class="flex-1 relative bg-[#020617] overflow-hidden">
        <canvas id="canvas"></canvas>
    </div>

    <script>
        const cvs = document.getElementById('canvas'), ctx = cvs.getContext('2d', { alpha: false, desynchronized: true });
        const offCanvas = document.createElement('canvas');
        const offCtx = offCanvas.getContext('2d');
        
        // Secondary buffers to handle layered shadow bleed and flattening
        const layerTileCanvas = document.createElement('canvas');
        const ltCtx = layerTileCanvas.getContext('2d');
        const bleedCanvas = document.createElement('canvas');
        const blCtx = bleedCanvas.getContext('2d');

        const ctr = document.getElementById('canvasContainer');
        const sdb = document.getElementById('sidebar'), rsz = document.getElementById('resizer');
        const latCtrlCnt = document.getElementById('latticeControls');
        
        let cW, cH, animT = 0, isDirty = true, lastOversample = 1;

        const cfg = {
            gridType: 'square', polySides: 4, expansion: 0.5, zoom: 120, rounding: 0,
            polyRot: 0, offsetY: 0.5, offsetX: 0, polyMirror: false, bgColor: '#020617',
            autoAnim: false, animTempo: 30, 
            mod_rot: 0, mod_round: 0, mod_exp: 0, mod_offset: 0,
            latParam1: 0.4
        };

        const layerCfgs = [
            { id: 0, name: 'Lattice Foundation', vis: true, c: '#1e293b', o: 0.15, sc: '#334155', sw: 0.5, b: 'source-over', shB: 0, shO: 0 },
            { id: 1, name: 'Primal Mesh', vis: true, c: '#3b82f6', o: 0.5, sc: '#60a5fa', sw: 1.0, b: 'source-over', shB: 0, shO: 0 },
            { id: 2, name: 'Dual Harmonic', vis: true, c: '#10b981', o: 0.4, sc: '#34d399', sw: 1.0, b: 'difference', shB: 15, shO: 2 },
            { id: 3, name: 'Morph Edges', vis: true, c: '#f59e0b', o: 0.3, sc: '#fbbf24', sw: 1.0, b: 'source-over', shB: 0, shO: 0 }
        ];

        const BLEND_MODES = ['source-over', 'multiply', 'screen', 'overlay', 'darken', 'lighten', 'color-dodge', 'color-burn', 'hard-light', 'soft-light', 'difference', 'exclusion', 'hue', 'saturation', 'color', 'luminosity'];

        const rad = (deg) => deg * Math.PI / 180;
        const getRGBA = (h, a) => {
            const r = parseInt(h.slice(1,3), 16), g = parseInt(h.slice(3,5), 16), b = parseInt(h.slice(5,7), 16);
            return `rgba(${r},${g},${b},${a})`;
        };
        const hashCoord = (p) => `${(p.x*1000).toFixed(0)}|${(p.y*1000).toFixed(0)}`;
        const randHex = () => '#' + Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0');

        function randomizeLattice() {
            cfg.gridType = ['square', 'hex', 'tri', 'tetrille', 'truncsquare'][Math.floor(Math.random() * 5)];
            cfg.latParam1 = 0.2 + Math.random() * 0.25;
            updateLatticeControls(); syncUI(); markDirty();
        }

        function randomizeMorphology() {
            cfg.zoom = 40 + Math.random() * 400;
            cfg.expansion = 0.1 + Math.random() * 1.0;
            cfg.rounding = Math.random() < 0.3 ? 0 : Math.random() * 0.6;
            syncUI(); markDirty();
        }

        function randomizeEdge() {
            cfg.polySides = 3 + Math.floor(Math.random() * 12);
            cfg.polyRot = Math.random() * 360;
            cfg.offsetX = (Math.random() - 0.5) * 120;
            cfg.offsetY = Math.random() * 100;
            cfg.polyMirror = Math.random() > 0.5;
            syncUI(); markDirty();
        }

        function randomizeLFO() {
            cfg.mod_rot = Math.random() * 0.8;
            cfg.mod_round = Math.random() * 0.8;
            cfg.mod_exp = Math.random() * 0.8;
            cfg.mod_offset = Math.random() * 0.8;
            syncUI(); markDirty();
        }

        function randomizeLayers() {
            layerCfgs.forEach(l => {
                l.c = randHex();
                l.sc = randHex();
                l.o = 0.1 + Math.random() * 0.7;
                l.sw = 0.5 + Math.random() * 4;
                l.b = BLEND_MODES[Math.floor(Math.random() * BLEND_MODES.length)];
                l.shB = Math.random() < 0.4 ? 0 : Math.random() * 40;
                l.shO = Math.random() * 10;
            });
            setupUI(); markDirty();
        }

        function randomizeAll() {
            randomizeLattice(); randomizeMorphology(); randomizeEdge(); randomizeLFO(); randomizeLayers();
            cfg.bgColor = randHex();
            document.getElementById('bgColor').value = cfg.bgColor;
            markDirty();
        }

        function syncUI() {
            Object.keys(cfg).forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    if (el.type === 'checkbox') el.checked = cfg[id];
                    else if (el.type === 'range') {
                        let div = 100;
                        if (['zoom', 'polySides', 'polyRot', 'animTempo'].includes(id)) div = 1;
                        el.value = cfg[id] * div;
                    } else if (el.tagName === 'SELECT') el.value = cfg[id];
                }
            });
            syncLabels();
        }

        function setupUI() {
            const container = document.getElementById('layers-container');
            container.innerHTML = '';
            layerCfgs.forEach(l => {
                const card = document.createElement('div');
                card.className = `layer-card shadow-lg`;
                card.style.borderLeftColor = l.c;
                let blendOptions = BLEND_MODES.map(b => `<option value="${b}" ${l.b===b?'selected':''}>${b.replace('-',' ').toUpperCase()}</option>`).join('');
                card.innerHTML = `
                    <div class="flex justify-between items-center mb-2">
                        <span class="text-[10px] font-black text-white tracking-widest uppercase">${l.name}</span>
                        <input type="checkbox" id="vis${l.id}" ${l.vis?'checked':''} class="w-3.5 h-3.5 accent-blue-500">
                    </div>
                    <div class="control-row"><label>FILL</label><div class="color-wrap"><input type="color" id="c${l.id}" value="${l.c}"></div><input type="range" id="o${l.id}" min="0" max="100" value="${l.o*100}"></div>
                    <div class="control-row"><label>STROKE</label><div class="color-wrap"><input type="color" id="sc${l.id}" value="${l.sc}"></div><input type="range" id="sw${l.id}" min="0" max="1000" value="${l.sw*100}"></div>
                    <div class="control-row"><label>GLOW/SHB</label><input type="range" id="shB${l.id}" min="0" max="60" value="${l.shB}"><input type="range" id="shO${l.id}" min="0" max="20" value="${l.shO}"></div>
                    <div class="control-row"><label>MODE</label><select id="b${l.id}" class="flex-1 h-5 text-[8px] font-bold uppercase tracking-tighter">${blendOptions}</select></div>
                `;
                container.appendChild(card);
                ['vis','c','o','sc','sw','shB','shO','b'].forEach(key => {
                    const el = document.getElementById(key+l.id);
                    el.oninput = (e) => {
                        if(key === 'vis') l.vis = e.target.checked;
                        else if(['c', 'sc', 'b'].includes(key)) { l[key] = e.target.value; if(key==='c') card.style.borderLeftColor = l.c; }
                        else if(['shB', 'shO'].includes(key)) l[key] = parseFloat(e.target.value);
                        else l[key] = e.target.value / 100;
                        markDirty();
                    };
                });
            });

            const inputs = ['gridType','polySides','expansion','rounding','zoom','bgColor', 'polyRot', 'offsetY', 'offsetX', 'polyMirror', 'autoAnim', 'animTempo', 'mod_rot', 'mod_round', 'mod_exp', 'mod_offset'];
            inputs.forEach(id => {
                const el = document.getElementById(id); if(!el) return;
                el.oninput = (e) => {
                    if(el.type === 'checkbox') cfg[id] = e.target.checked;
                    else if(id === 'gridType') { cfg[id] = e.target.value; updateLatticeControls(); }
                    else {
                        let div = 100;
                        if(['zoom', 'polySides', 'polyRot', 'animTempo'].includes(id)) div = 1;
                        cfg[id] = el.type === 'color' ? e.target.value : parseFloat(e.target.value)/div;
                    }
                    syncLabels(); markDirty();
                };
            });
            updateLatticeControls(); syncLabels();
        }

        function syncLabels() {
            ['polyRot','zoom','expansion','rounding','polySides','offsetX','offsetY', 'mod_rot', 'mod_round', 'mod_exp', 'mod_offset'].forEach(id => {
                const v = document.getElementById(id+'Val'); if(!v) return;
                if(id === 'polyRot') v.innerText = cfg[id].toFixed(1) + '°';
                else if(id === 'rounding' || id.startsWith('mod_')) v.innerText = Math.round(cfg[id]*100) + '%';
                else if(id === 'polySides') v.innerText = Math.round(cfg[id]);
                else v.innerText = cfg[id].toFixed(2);
            });
        }

        function updateLatticeControls() {
            latCtrlCnt.innerHTML = '';
            if(cfg.gridType === 'truncsquare') {
                const row = document.createElement('div'); row.className = 'row';
                row.innerHTML = `<div class="row-header"><label>Octagon Aspect</label></div><div class="flex items-center gap-3"><input type="range" id="latParam1" min="15" max="48" value="${cfg.latParam1*100}"><span id="latParam1Val" class="val">${cfg.latParam1.toFixed(2)}</span></div>`;
                latCtrlCnt.appendChild(row);
                document.getElementById('latParam1').oninput = (e) => { cfg.latParam1 = parseFloat(e.target.value)/100; document.getElementById('latParam1Val').innerText = cfg.latParam1.toFixed(2); markDirty(); };
            }
        }

        function markDirty() { isDirty = true; reqDraw(); }

        function getUnitCellDimensions() {
            const s = 80;
            switch(cfg.gridType) {
                case 'hex': return { w: s * 3, h: s * Math.sqrt(3) };
                case 'tri': return { w: s, h: s * Math.sqrt(3) };
                case 'tetrille': return { w: s * 3, h: s * Math.sqrt(3) };
                default: return { w: s, h: s };
            }
        }

        function generateUnitGeom(dim) {
            const s = 80;
            const faces = [];
            // Generate a larger buffer to ensure no geometric clipping before the 3x3 bleed step
            const b = { x1: -dim.w * 2, x2: dim.w * 2, y1: -dim.h * 2, y2: dim.h * 2 };
            const type = cfg.gridType;

            if(type === 'square') {
                for(let y=Math.floor(b.y1/s)*s; y<b.y2; y+=s)
                for(let x=Math.floor(b.x1/s)*s; x<b.x2; x+=s)
                faces.push({ pts: [{x,y}, {x:x+s,y}, {x:x+s,y:y+s}, {x,y:y+s}] });
            } else if(type === 'hex' || type === 'tri') {
                const h = s * Math.sqrt(3)/2;
                if(type === 'hex') {
                    for(let r=Math.floor(b.y1/(h*2))-1; r*h*2<b.y2+h; r++)
                    for(let c=Math.floor(b.x1/(s*1.5))-1; c*s*1.5<b.x2+s; c++) {
                        const cx = c*s*1.5, cy = r*h*2 + (Math.abs(c)%2 ? h : 0);
                        const pts = []; for(let i=0; i<6; i++) pts.push({x:cx+s*Math.cos(i*Math.PI/3), y:cy+s*Math.sin(i*Math.PI/3)});
                        faces.push({ pts });
                    }
                } else {
                    for(let r=Math.floor(b.y1/h)-1; r*h<b.y2+h; r++) {
                        const off = (Math.abs(r)%2?s/2:0);
                        for(let c=Math.floor(b.x1/s)-1; c*s<b.x2+s; c++) {
                            const x = c*s+off;
                            faces.push({ pts: [{x,y:r*h}, {x:x+s,y:r*h}, {x:x+s/2,y:(r+1)*h}] });
                            faces.push({ pts: [{x:x+s,y:r*h}, {x:x+s*1.5,y:(r+1)*h}, {x:x+s/2,y:(r+1)*h}] });
                        }
                    }
                }
            } else if(type === 'tetrille') {
                const h = s * Math.sqrt(3);
                for (let r = Math.floor(b.y1/h)-1; r*h < b.y2+h; r++) {
                    for (let c = Math.floor(b.x1/(s*1.5))-1; c*s*1.5 < b.x2+s; c++) {
                        const cx = c*s*1.5, cy = r*h + (Math.abs(c)%2 ? h/2 : 0);
                        for(let i=0; i<6; i++){
                            const a = i*Math.PI/3;
                            faces.push({ pts: [{x:cx,y:cy}, {x:cx+s*0.5*Math.cos(a),y:cy+s*0.5*Math.sin(a)}, {x:cx+s*0.866*Math.cos(a+Math.PI/6),y:cy+s*0.866*Math.sin(a+Math.PI/6)}, {x:cx+s*0.5*Math.cos(a+Math.PI/3),y:cy+s*0.5*Math.sin(a+Math.PI/3)}] });
                        }
                    }
                }
            } else if(type === 'truncsquare') {
                const k = s * cfg.latParam1;
                for(let y=Math.floor(b.y1/s)*s; y<b.y2; y+=s)
                for(let x=Math.floor(b.x1/s)*s; x<b.x2; x+=s) {
                    faces.push({ pts: [{x:x+k, y:y}, {x:x+s-k, y:y}, {x:x+s, y:y+k}, {x:x+s, y:y+s-k}, {x:x+s-k, y:y+s}, {x:x+k, y:y+s}, {x:x, y:y+s-k}, {x:x, y:y+k}] });
                    faces.push({ pts: [{x:x+s-k, y:y+s}, {x:x+s, y:y+s-k}, {x:x+s+k, y:y+s}, {x:x+s, y:y+s+k}] });
                }
            }

            const edgeMap = new Map(), vertMap = new Map();
            faces.forEach((f, fIdx) => {
                f.pts.forEach((p1, i) => {
                    const p2 = f.pts[(i+1)%f.pts.length], eK = [p1,p2].map(hashCoord).sort().join('|');
                    if(!edgeMap.has(eK)) edgeMap.set(eK, { p1, p2, f: [] });
                    edgeMap.get(eK).f.push(fIdx);
                    const vK = hashCoord(p1);
                    if(!vertMap.has(vK)) vertMap.set(vK, { p: p1, f: [] });
                    if(!vertMap.get(vK).f.includes(fIdx)) vertMap.get(vK).f.push(fIdx);
                });
            });

            const duals = [];
            vertMap.forEach(v => {
                if(v.f.length < 3) return;
                const pts = v.f.map(fi => {
                    const f = faces[fi], cx = f.pts.reduce((a,b)=>a+b.x,0)/f.pts.length, cy = f.pts.reduce((a,b)=>a+b.y,0)/f.pts.length;
                    return { x:cx, y:cy, a: Math.atan2(cy-v.p.y, cx-v.p.x) };
                }).sort((a,b) => a.a - b.a);
                duals.push({ pts });
            });

            const sides = Math.floor(cfg.polySides);
            const rotA = rad(cfg.polyRot + (cfg.autoAnim ? Math.sin(animT*0.012 * cfg.animTempo)*120 * cfg.mod_rot : 0));
            const expVal = cfg.expansion + (cfg.autoAnim ? Math.sin(animT*0.008 * cfg.animTempo)*0.4 * cfg.mod_exp : 0);
            const biasY = cfg.offsetY + (cfg.autoAnim ? Math.sin(animT*0.015 * cfg.animTempo)*0.3 * cfg.mod_offset : 0);
            const shX = cfg.offsetX + (cfg.autoAnim ? Math.sin(animT*0.01 * cfg.animTempo)*0.2 * cfg.mod_offset : 0);

            const edges = [];
            edgeMap.forEach(e => {
                const { p1, p2 } = e;
                const dx = p2.x-p1.x, dy = p2.y-p1.y, len = Math.sqrt(dx*dx+dy*dy), ang = Math.atan2(dy,dx), nx = -dy/len, ny = dx/len;
                const mk = (sX) => {
                    const cx = p1.x + dx*biasY + nx*sX*len, cy = p1.y + dy*biasY + ny*sX*len;
                    const R = (len*expVal)*0.5/Math.sin(Math.PI/sides), pts = [];
                    for(let i=0; i<sides; i++) {
                        const a = ang + Math.PI/2 + rotA + (i*2*Math.PI/sides);
                        pts.push({ x: cx + R*Math.cos(a), y: cy + R*Math.sin(a) });
                    }
                    return pts;
                };
                edges.push({ pts: mk(shX) });
                if(cfg.polyMirror) edges.push({ pts: mk(-shX) });
            });

            return { faces, duals, edges };
        }

        function renderMasterTile() {
            const dim = getUnitCellDimensions();
            const dpr = window.devicePixelRatio || 1;
            const currentZoomScale = cfg.zoom / 100;
            const oversample = Math.min(8, Math.max(2, currentZoomScale * dpr)); 
            lastOversample = oversample;

            // Integer dimensions are mandatory to prevent sub-pixel "dark gap" seams
            const expW = Math.round(dim.w * oversample);
            const expH = Math.round(dim.h * oversample);
            
            offCanvas.width = expW;
            offCanvas.height = expH;
            layerTileCanvas.width = expW;
            layerTileCanvas.height = expH;
            bleedCanvas.width = expW;
            bleedCanvas.height = expH;

            const data = generateUnitGeom(dim);
            const curRounding = cfg.rounding + (cfg.autoAnim ? (Math.sin(animT * 0.007 * cfg.animTempo) * 0.5 + 0.5) * cfg.mod_round * 0.8 : 0);

            offCtx.fillStyle = cfg.bgColor;
            offCtx.fillRect(0, 0, expW, expH);

            const drawLayer = (list, l) => {
                if(!l || !l.vis || list.length === 0) return;
                
                // 1. Render base layer geometry to a single tile buffer (flat sourcing)
                ltCtx.clearRect(0, 0, expW, expH);
                ltCtx.save();
                ltCtx.scale(oversample, oversample);
                ltCtx.lineJoin = 'round';
                ltCtx.lineCap = 'round';
                ltCtx.fillStyle = getRGBA(l.c, l.o);
                ltCtx.strokeStyle = getRGBA(l.sc, 1);
                ltCtx.lineWidth = l.sw;

                const batchPath = new Path2D();
                list.forEach(item => {
                    const pts = item.pts;
                    if(curRounding < 0.01) {
                        batchPath.moveTo(pts[0].x, pts[0].y);
                        for(let i=1; i<pts.length; i++) batchPath.lineTo(pts[i].x, pts[i].y);
                        batchPath.closePath();
                    } else {
                        for(let i=0; i<pts.length; i++) {
                            const p1 = pts[i], p0 = pts[(i-1+pts.length)%pts.length], p2 = pts[(i+1)%pts.length];
                            const v1 = {x:p0.x-p1.x,y:p0.y-p1.y}, v2 = {x:p2.x-p1.x,y:p2.y-p1.y};
                            const l1 = Math.sqrt(v1.x*v1.x+v1.y*v1.y), l2 = Math.sqrt(v2.x*v2.x+v2.y*v2.y);
                            const r = Math.min(l1,l2)*0.5*curRounding;
                            const s = {x:p1.x+v1.x/l1*r, y:p1.y+v1.y/l1*r}, e = {x:p1.x+v2.x/l2*r, y:p1.y+v2.y/l2*r};
                            if(i===0) batchPath.moveTo(s.x, s.y); else batchPath.lineTo(s.x, s.y);
                            batchPath.quadraticCurveTo(p1.x, p1.y, e.x, e.y);
                        }
                        batchPath.closePath();
                    }
                });
                ltCtx.fill(batchPath);
                if(l.sw > 0) ltCtx.stroke(batchPath);
                ltCtx.restore();

                // 2. Perform 3x3 shadow bleed into the Bleed Buffer
                blCtx.clearRect(0, 0, expW, expH);
                blCtx.save();
                if(l.shB > 0) {
                    // Shadow blur is scaled by oversample to remain sharp
                    blCtx.shadowBlur = l.shB * oversample;
                    blCtx.shadowColor = 'rgba(0,0,0,0.5)';
                    blCtx.shadowOffsetX = l.shO * oversample;
                    blCtx.shadowOffsetY = l.shO * oversample;
                }
                
                // Draw 9 tiles: the 8 neighbors' shadows will bleed into the center (0,0) frame
                for(let ty=-1; ty<=1; ty++) {
                    for(let tx=-1; tx<=1; tx++) {
                        blCtx.drawImage(layerTileCanvas, tx * expW, ty * expH);
                    }
                }
                blCtx.restore();

                // 3. Composite the resulting seamless layer buffer onto the master tile
                offCtx.save();
                offCtx.globalCompositeOperation = l.b;
                offCtx.drawImage(bleedCanvas, 0, 0);
                offCtx.restore();
            };

            // Process Bottom-to-Top: Foundation -> Mesh -> Dual -> Edges
            drawLayer(data.faces, layerCfgs[0]);
            drawLayer(data.faces, layerCfgs[1]);
            drawLayer(data.duals, layerCfgs[2]);
            drawLayer(data.edges, layerCfgs[3]);
        }

        function render() {
            if(isDirty || cfg.autoAnim) {
                renderMasterTile();
                isDirty = false;
            }

            ctx.fillStyle = cfg.bgColor;
            ctx.fillRect(0, 0, cW, cH);

            const pattern = ctx.createPattern(offCanvas, 'repeat');
            const scale = cfg.zoom / 100;
            
            ctx.save();
            ctx.translate(cW/2, cH/2);
            
            const patternScale = scale / lastOversample;
            const matrix = new DOMMatrix();
            matrix.scaleSelf(patternScale, patternScale);
            // Center alignment offset
            matrix.translateSelf(-offCanvas.width / 2, -offCanvas.height / 2);
            pattern.setTransform(matrix);

            ctx.fillStyle = pattern;
            ctx.fillRect(-cW, -cH, cW*2, cH*2);
            ctx.restore();
        }

        function loop() { if(cfg.autoAnim) { animT++; render(); } requestAnimationFrame(loop); }
        function reqDraw() { if(!cfg.autoAnim) requestAnimationFrame(() => render()); }
        function resize() { cW = cvs.width = ctr.clientWidth; cH = cvs.height = ctr.clientHeight; markDirty(); }

        document.getElementById('randBtn').onclick = randomizeAll;
        document.getElementById('exportPng').onclick = () => {
            const link = document.createElement('a');
            link.download = `seamless_pattern_${Date.now()}.png`;
            link.href = offCanvas.toDataURL('image/png');
            link.click();
        };
        document.getElementById('exportBmp').onclick = () => {
            const link = document.createElement('a');
            link.download = `seamless_pattern_${Date.now()}.bmp`;
            link.href = offCanvas.toDataURL('image/bmp');
            link.click();
        };
        document.getElementById('exportSvg').onclick = () => {
            const dim = getUnitCellDimensions();
            const data = generateUnitGeom(dim);
            const curRounding = cfg.rounding + (cfg.autoAnim ? (Math.sin(animT * 0.007 * cfg.animTempo) * 0.5 + 0.5) * cfg.mod_round * 0.8 : 0);

            let svg = `<svg width="${dim.w}" height="${dim.h}" viewBox="0 0 ${dim.w} ${dim.h}" xmlns="http://www.w3.org/2000/svg" style="background:${cfg.bgColor}">`;
            svg += `<defs><clipPath id="tileClip"><rect x="0" y="0" width="${dim.w}" height="${dim.h}" /></clipPath></defs>`;
            svg += `<g clip-path="url(#tileClip)">`;

            const addLayerSvg = (list, l) => {
                if(!l.vis) return;
                for(let ty=-1; ty<=1; ty++) {
                    for(let tx=-1; tx<=1; tx++) {
                        svg += `<g transform="translate(${tx*dim.w}, ${ty*dim.h})" style="mix-blend-mode:${l.b};">`;
                        list.forEach(item => {
                            let pathData = "";
                            const pts = item.pts;
                            if(curRounding < 0.01) {
                                pathData = `M ${pts[0].x} ${pts[0].y} ` + pts.slice(1).map(p => `L ${p.x} ${p.y}`).join(' ') + " Z";
                            } else {
                                for(let i=0; i<pts.length; i++) {
                                    const p1 = pts[i], p0 = pts[(i-1+pts.length)%pts.length], p2 = pts[(i+1)%pts.length];
                                    const v1 = {x:p0.x-p1.x,y:p0.y-p1.y}, v2 = {x:p2.x-p1.x,y:p2.y-p1.y};
                                    const l1 = Math.sqrt(v1.x*v1.x+v1.y*v1.y), l2 = Math.sqrt(v2.x*v2.x+v2.y*v2.y);
                                    const r = Math.min(l1,l2)*0.5*curRounding;
                                    const s = {x:p1.x+v1.x/l1*r, y:p1.y+v1.y/l1*r}, e = {x:p1.x+v2.x/l2*r, y:p1.y+v2.y/l2*r};
                                    pathData += (i===0 ? `M ${s.x} ${s.y} ` : `L ${s.x} ${s.y} `) + `Q ${p1.x} ${p1.y}, ${e.x} ${e.y} `;
                                }
                                pathData += "Z";
                            }
                            svg += `<path d="${pathData}" fill="${getRGBA(l.c, l.o)}" stroke="${l.sc}" stroke-width="${l.sw}" stroke-linejoin="round" stroke-linecap="round" />`;
                        });
                        svg += `</g>`;
                    }
                }
            };
            addLayerSvg(data.faces, layerCfgs[0]);
            addLayerSvg(data.faces, layerCfgs[1]);
            addLayerSvg(data.duals, layerCfgs[2]);
            addLayerSvg(data.edges, layerCfgs[3]);
            svg += `</g></svg>`;

            const link = document.createElement('a');
            link.download = `seamless_vector_${Date.now()}.svg`;
            link.href = URL.createObjectURL(new Blob([svg], {type: 'image/svg+xml'}));
            link.click();
        };

        window.onresize = resize;
        setupUI(); resize(); loop();
    </script>
</body>
</html>